<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effective Modern C++ | Bitdewy]]></title>
  <link href="http://bitdewy.github.com/blog/categories/effective-modern-c-plus-plus/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2014-10-21T21:12:26+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译] Item 2: Understand `auto` type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2/"/>
    <updated>2014-09-18T23:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2</id>
    <content type="html"><![CDATA[<p>如果你已经阅读了 Item 1 模板类型推导，那么你应该已经掌握了 <code>auto</code> 的类型推导，出了下面要讲到的一个不同之外，其他都和 Item 1 完全一致，但是你肯定还有疑问，为什么模板类型推导涉及到了模板，函数以及参数，而 <code>auto</code> 却不涉及这些。</p>

<p>没错，但是这也没什么关系。其实模板类型推导与 <code>auto</code> 类型推导有直接的映射关系。有很直观的转换关系。</p>

<p>在 Item 1 中，我们使用下面的模板函数用来描述模板类型推导，</p>

<p><code>
template &lt;typename T&gt;
void f(ParamType param);
</code></p>

<p>调用如下：</p>

<p><code>
f (expr);    // call f with some expression
</code></p>

<p>在调用函数 <code>f</code> 时，编译器使用表达式 <code>expr</code> 来推导类型 <code>T</code> 和 <code>ParamType</code>。</p>

<p>当使用 <code>auto</code> 来声明变量时，<code>auto</code> 代替了上面 <code>T</code> 的位置，同时变量的类型就是 <code>ParamType</code> 的类型。看下面的例子会更直观，</p>

<p><code>
auto x = 27;
</code></p>

<p>在这里，变量 <code>x</code> 的类型标识符就是一个简单的 <code>auto</code>，在</p>

<p><code>
const auto cx = x;
</code></p>

<p>中，类型标识符是 <code>const auto</code>，在</p>

<p><code>
const auto&amp; rx = x;
</code></p>

<p>中，类型标识符是 <code>const auto&amp;</code>。推导上面 <code>x</code>, <code>cx</code> 以及 <code>rx</code> 的类型，编译器所做的事情就像是有一个模板函数一样，</p>

<p>```
template <typename T>
void func_for_x(T param);           // conceptual template for deducing x&rsquo;s type</p>

<p>func_for_x(27);                     // conceptual call: param&rsquo;s deduced type is x&rsquo;s type</p>

<p>template <typename T>
void func_for_cx(const T param);    // conceptual template for deducing cx&rsquo;s type</p>

<p>func_for_cx(x);                     // conceptual call: param&rsquo;s deduced type is cx&rsquo;s type</p>

<p>template <typename T>
void func_for_rx(const T&amp; param);   // conceptual template for deducing rx&rsquo;s type</p>

<p>func_for_rx(x);                     // conceptual call: param&rsquo;s deduced type is rx&rsquo;s type
```</p>

<p>就像刚才说的一样，<code>auto</code> 的类型推导只有一点（一会儿会讲到）不一样之外，其他与模板类型推导完全一致。</p>

<p>Item 1 中根据 <code>ParamType</code> 的类型，把类型推导分了三种情况来处理，在 <code>auto</code> 类型推导时，<code>auto</code> 替代了 <code>ParamType</code>  也同样分为三种情况，</p>

<ul>
<li>情况1：类型标识符是一个指针或者引用，但不是右值引用</li>
<li>情况2：类型标识符是一个全局引用</li>
<li>情况3：类型标识符既不是指针也不是引用</li>
</ul>


<p>我们已经见过了情况1 与情况3 的例子了，</p>

<p>```
auto x = 27;           // case 3 (x is neither ptr nor reference)</p>

<p>const auto cx = x;     // case 3 (cx isn&rsquo;t neither)</p>

<p>const auto&amp; rx = x;    // case 1 (rx is a non-universal ref.)</p>

<p>```</p>

<p>情况2 就像你预期的那样，</p>

<p>```
auto&amp;&amp; uref1 = x;     // x is int lvalue, so uref1&rsquo;s type is int&amp;</p>

<p>auto&amp;&amp; uref2 = cx;    // cx is const int and lvalue, so uref2&rsquo;s type is const int&amp;</p>

<p>auto&amp;&amp; uref3 = 27;    // 27 is int and rvalue, so uref3&rsquo;s type is int&amp;&amp;
```</p>

<p>Item 1 中我们讨论了非引用的数组和函数是如何退化成指针的。在 <code>auto</code> 类型推导中也是一样的，</p>

<p>```
const char name[] = &ldquo;R. N. Briggs&rdquo;;    // name&rsquo;s type is const char[13]</p>

<p>auto arr1 = name;                      // arr1&rsquo;s type is const char *</p>

<p>auto&amp; arr2 = name;                     // arr2&rsquo;s type is const char (&amp;)[13]</p>

<p>void someFunc(int, double);            // someFunc is function, type is void(int, double)</p>

<p>auto func1 = someFunc;                 // func1&rsquo;s type is void(*)(int, double)</p>

<p>auto&amp; func2 = someFunc;                // func2&rsquo;s type is void(&amp;)(int, double)
```</p>

<p>就像你看到这样，<code>auto</code> 类型推导就像模板类型推导一样。</p>

<p>仅有一种情况，他们是不一样的。我们从一个简单的例子开始，在 C++98 中，我们用 27 来初始化一个 int 变量，我们可以有下面两种写法，</p>

<p><code>
int x1 = 27;
int x2(27);
</code></p>

<p>C++11 统一初始化，增加了下面的写法，</p>

<p><code>
int x3 = { 27 };
int x4{ 27 };
</code></p>

<p>总而言之，4中不同的写法的结果都是一样的，初始化了一个值为 27 的整型。</p>

<p>但是，就像 Item 5 中解释的一样，使用 <code>auto</code> 来声明类型是可以获得好处的，所有我们可以将上面的 <code>int</code> 全部替换为 <code>auto</code>：</p>

<p><code>
auto x1 = 27;
auto x2(27);
auto x3 = { 27 };
auto x4{ 27 };
</code></p>

<p>这 4 种写法都能够正常编译，但是却表达了不同的含义。前两种写法定义了一个值为 27 的整型。但后两种写法实际上定义了一个只有一个元素 27 的 <code>std::initializer_list&lt;int&gt;</code>！</p>

<p><code>
auto x1 = 27;        // type is int, value is 27
auto x2(27);         // ditto
auto x3 = { 27 };    // type is std::initializier_list&lt;int&gt;, value is { 27 }
auto x4{ 27 };       // ditto
</code></p>

<p>这是 <code>auto</code> 类型推导的一个特殊规则。当使用大括号初始化一个 <code>auto</code> 变量时，类型会被推导为 <code>std::initializer_list</code>，如果类型推导不成功（比如，大括号中的某个元素类型与其他的不一致），那么将会编译失败：</p>

<p><code>
auto x5 = { 1, 2, 3.0 };    // error! can't deduce T for std::initializer_list&lt;int&gt;
</code></p>

<p>就像上面注释中写的一样，类型推导在这种情况下会失败，但是要明白这里有两个类型推导，这是很重要的。第一个是 <code>auto</code>，<code>x5</code> 使用了大括号来初始化，那么 <code>auto</code> 会被推导为 <code>std::initializer_list</code> 类型，但同时 <code>std::initializer_list</code> 是一个模板类型，模板参数 <code>T</code> 同样需要推导，类型推导失败产生于第二步：模板类型推导。在上面的例子中，就是由于大括号中的元素类型不一致而导致的模板类型推导失败。</p>

<p><code>auto</code> 类型推导与模板类型推导的唯一不同在于大括号初始化。当使用大括号初始化时，<code>auto</code> 会推到为 <code>std::initializer_list</code> 类型，但对于模板类型推导来说，这会产生一个错误，</p>

<p>```
auto x = { 11, 23, 9 };  // x&rsquo;s type is std::initializer_list<int></p>

<p>template<typename T>
void f(T param);         // template with parameter declaration equivalent to x&rsquo;s</p>

<p>f({ 11, 23, 9});         // error! can&rsquo;t deduce type for T
```</p>

<p>不过，如果你明确指定了 <code>param</code> 的类型为 <code>std::initializer_list&lt;T&gt;</code> 那么模板类型推导会推导出 <code>T</code> 的类型，</p>

<p>```
template<typename T>
void f(std::initializer_list<T> initList);</p>

<p>f({ 11, 23, 9 });    // T deduce as int, and initList&rsquo;s type is std::initializer_list<int>
```</p>

<p>因此，<code>auto</code> 类型推导与模板类型推导唯一的不同在于，对于大括号初始化，<code>auto</code> 类型推导会将它推导为 <code>std::initializer_list</code>，而模板类型推导不会。</p>

<p>也许你会想知道为什么会有这样的区别。我也曾想过，但是没有找到一个很好的解释。不过规则就是规则，你只需要记住，当使用大括号初始化 <code>auto</code> 类型时，它会被自动推到为 <code>std::initializer_list</code> 类型。如果你想要使用新的统一初始化，那么记住这一点是非常重要的。一个典型的 C++11 错误就是当你想要一个其他类型时却意外的声明了一个 <code>std::initializer_list</code> 类型。这也是为什么有些开发者仅仅在必要的时候才使用大括号初始化的一个原因。（我们会在 Item 7 中详细讨论）</p>

<p>对 C++11 来说，这就是全部了。但是对于 C++14，还有些其他内容。C++14 允许使用 <code>auto</code> 来表示需要被推导的函数返回值类型（详见 Item 3），C++14 的 lambda 中也允许 <code>auto</code> 用作参数类型。但是这些 <code>auto</code> 遵循的是模板类型推导，而不是 <code>auto</code> 类型推导。因此，一个返回值类型声明为 <code>auto</code> 返回一个大括号初始化时，会导致编译失败，</p>

<p>```
auto createInitList()
{</p>

<pre><code>return { 1, 2, 3 };    // error: can't deduce type for { 1, 2, 3 }
</code></pre>

<p>}
```</p>

<p>lambda:</p>

<p>```
std::vector<int> v;
// &hellip;
auto resetV = <a href="const%20auto&amp;%20newValue">&amp;v</a> { v = newValue; };    // C++14
// &hellip;</p>

<p>resetV({ 1, 2, 3 });    // error! can&rsquo;t deduce type for { 1, 2, 3 }
```</p>

<h2>需要记住的</h2>

<ul>
<li><code>auto</code> 类型推导通常和模板类型推导是一致的，但是 <code>auto</code> 类型推导会将大括号初始化推到为 <code>std::initializer_list</code>，而模板类型推导不会</li>
<li><code>auto</code> 在函数返回值以及 lambda 参数类型推导时，遵循模板类型推导，而不是 <code>auto</code> 类型推导。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 1: Understand template type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/08/23/emcpp-item-1/"/>
    <updated>2014-08-23T00:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/08/23/emcpp-item-1</id>
    <content type="html"><![CDATA[<p>在使用一个复杂的系统时，我们可以不用知道具体的细节。从这个方面来说，C++ 的模板类型推导是很成功的。数以百万的程序员都使用过模板，即使他们可能很难描述清楚这些类型是如何推导的。</p>

<p>如果你是其中的一员，我有一个好消息，也有一个坏消息。好消息是，模板类型推导是最引人注目的 C++11 新特性 <code>auto</code> 的基础。如果你很清楚 C++98 中的模板类型推导，那么你会很容易明白 C++11 中的 <code>auto</code>。坏消息是，当使用 <code>auto</code> 时，有些类型推导会变得没有那么直观。因此完全掌握类型推导的规则是非常有必要的。Item 1 会介绍你必须知道的类型推导规则。</p>

<p>我们从一小段伪代码开始：</p>

<p><code>
template &lt;typename T&gt;
void f(ParamType param);
</code>
调用如下：
<code>
f (expr);    // call f with some expression
</code>
在编译期间，编译器使用表达式 <code>expr</code> 来推导两个类型：一个是 <code>T</code> 另一个是 <code>ParamType</code>。这两个类型通常是不一样的，因为 <code>ParamType</code> 通常是含有修饰的，比如 <code>const</code> 或者引用。举个例子，如果模板的声明如下：
<code>
template &lt;typename T&gt;
void f (const T&amp; param);    // ParamType is const T&amp;
</code>
然后调用如下：
<code>
int x = 0;
f(x);    // call f with an int
</code>
类型 <code>T</code> 会被推导为 <code>int</code>，而 <code>ParamType</code> 被推导为 <code>const int&amp;</code>。</p>

<p>将类型 <code>T</code> 推导为传入的参数类型是很自然的，即 <code>T</code> 的类型就是 <code>expr</code> 的类型。在上面的例子中，<code>x</code> 是 <code>int</code> 类型，<code>T</code> 被推导为 <code>int</code> 类型。但是有时候却不是这样的。类型推导不仅仅依赖于表达式 <code>expr</code> 的类型，同时还依赖于 <code>ParamType</code> 的形式。有下面三种情况：</p>

<ul>
<li>ParamType 是一个指针或者引用类型，但是不是全局引用。（全局引用将会在 Item 24 中讲述。现在你只需要知道他不同于引用，也不同于右值引用即可）。</li>
<li>ParamType 是一个全局引用。</li>
<li>ParamType 即不是指针也不是引用</li>
</ul>


<p>因此我们需要考虑上面描述的三种场景来一一讲述。每个都基于下面的伪代码，</p>

<p>```
template <typename T>
void f(ParamType param);</p>

<p>f(expr);    // deduce T and ParamType from expr
```</p>

<h3>情况1：<code>ParamType</code> 是一个指针或者引用，但不是右值引用</h3>

<p>这是最简单的一种情况，在这种情况下，类型推导的工作如下：</p>

<ol>
<li>如果 <code>expr</code> 是一个引用类型，忽略引用部分。</li>
<li>然后模式匹配 <code>expr</code> 的类型，根据 <code>ParamType</code> 的类型来决定 <code>T</code> 的类型。</li>
</ol>


<p>举个例子，如果我们的模板是下面这样，</p>

<p><code>
template &lt;typename T&gt;
void f(T&amp; param);    // param is a reference
</code></p>

<p>然后我们有如下的变量声明，</p>

<p><code>
int x = 27;           // x is an int
const int cx = x;     // cx is a const int
const int&amp; rx = x;    // rx is a reference to x as a const int
</code></p>

<p><code>param</code> 和 <code>T</code> 的类型推导结果如下，</p>

<p>```
f(x);     // T is int, param&rsquo;s type is int&amp;</p>

<p>f(cx);    // T is const int, param&rsquo;s type is const int&amp;</p>

<p>f(rx);    // T is const int, param&rsquo;s type is const int&amp;
```</p>

<p>在第二个以及第三个调用中，注意由于 <code>cx</code> 和 <code>rx</code> 是 <code>const</code> 值，所以 <code>T</code> 被推导为 <code>const int</code> 类型，这对调用者来说是至关重要的。当调用者传入一个 <code>const</code> 对象给一个引用参数时，参数仍然是不可更改的。比如，参数是一个 <code>const</code> 引用。这也是为什么传入一个 <code>const</code> 对象给一个接受 <code>T&amp;</code> 类型的模板参数是安全的：<code>const</code> 约束直接变为了 <code>T</code> 类型的一部分。</p>

<p>在第三个调用中，注意虽然 <code>rx</code> 的类型是引用，<code>T</code> 仍然被推导为非引用。这是由于类型推导过程中 <code>rx</code> 的引用修饰被忽略掉了。</p>

<p>上面的例子都是左值引用参数，但其实右值引用的类型推导和上面是完全一样的。当然，只有右值类型的参数才能传递给右值引用，但他对类型推导完全没有影响。</p>

<p>如果我们将 <code>f</code> 的参数类型由 <code>T&amp;</code> 更改为 <code>const T&amp;</code>，情况会有一些变化，但非常好理解。<code>cx</code> 和 <code>rx</code> 的 <code>const</code> 修饰仍然有用。但由于现在假定 <code>param</code> 的类型是一个 <code>const</code> 引用，现在不再需要将 <code>const</code> 推断为类型 <code>T</code> 的一部分了：</p>

<p>```
template <typename T>
void f(const T&amp; param);    // param is now ref-to-const</p>

<p>int x = 27;                // as before
const int cx = x;          // as before
const int&amp; rx = x;         // as before</p>

<p>f(x);                      // T is int, param&rsquo;s type is const int&amp;</p>

<p>f(cx);                     // T is int, param&rsquo;s type is const int&amp;</p>

<p>f(rx);                     // T is int, param&rsquo;s type is const int&amp;
```</p>

<p>和上面一样，<code>rx</code> 的引用修饰在类型推导时会被忽略。</p>

<p>如果 <code>param</code> 是一个指针（或者 <code>const</code> 指针），类型推导基本是一样的。</p>

<p>```
template <typename T>
void f(T* param);          // param is now a pointer</p>

<p>int x = 27;                // as before
const int *px = &x;        // px is a ptr to x as a const int</p>

<p>f(&amp;x);                     // T is int, param&rsquo;s type is int*</p>

<p>f(px);                     // T is const int, param&rsquo;s type is const int*
```</p>

<p>到目前位置，你可能已经哈欠不断了，因为对于指针和引用的类型推导，规则这么简单，所有的结果都是显而易见的，就和你想象的完全一样。</p>

<h3>情况2：<code>ParamType</code> 是全局引用</h3>

<p>当模版参数是全局引用时，类型推导就没有那么明显了。声明的形式有点像右值引用（全局引用的类型声明形式是 <code>T&amp;&amp;</code>），但是当传入的参数是左值类型时行为是不一样的。具体细节在 Item 24 中讲述，现在我们来看一个简单的版本：</p>

<ul>
<li>如果 <code>expr</code> 是一个左值，那么 <code>T</code> 和 <code>ParamType</code> 都会推导为左值引用。有两个不寻常的地方。第一，这是仅有的模板类型推导会将类型 <code>T</code> 推导为引用类型的情形。第二，尽管 <code>ParamType</code> 的类型声明使用了右值引用的符号，但却推导为了左值引用。</li>
<li>如果 <code>expr</code> 是一个右值，会使用“正常的”（情况1）规则。</li>
</ul>


<p>例子：</p>

<p>```
tempalte <typename T>
void f(T&amp;&amp; param);        // param is now a universal reference</p>

<p>int x = 27;               // as before
const int cx = x;         // as before
const int&amp; rx = x;        // as before</p>

<p>f(x);                     // x is lvalue, so T is int&amp;, param&rsquo;s type is also int&amp;</p>

<p>f(cx);                    // cx is lvalue, so T is const int&amp;, param&rsquo;s type is also const int&amp;</p>

<p>f(rx);                    // rx is lvalue, so T is const int&amp;, param&rsquo;s type is also const int&amp;</p>

<p>f(27);                    // 27 is rvalue, so T is int, param&rsquo;s type is therefore int&amp;&amp;
```</p>

<p>在 Item 24 中会详细解释为什么在上面的情形中类型推导是这样的。在这里我们的重点是，左值参数和右值参数对于全局引用来说，类型推导的规则是不一样的。这很特别的，当使用全局引用时，类型推导会区别对待左值参数和右值参数，这是在其他类型中不会发生的。</p>

<h3>情况3：<code>ParamType</code> 即不是引用也不是指针</h3>

<p>当 <code>ParamType</code> 既不是引用也不是指针时，我们来按值传递，</p>

<p><code>
template &lt;typename T&gt;
void f(T param);          // param is now passed by value
</code></p>

<p>这意味着 <code>param</code> 会做一个拷贝 —— 产生一个全新的对象。<code>param</code> 的类型推导遵循如下规则：</p>

<ol>
<li>像上面一样，如果 <code>expr</code> 的类型是一个引用，那么引用类型会被忽略。</li>
<li>如果忽略了 <code>expr</code> 的引用修饰之后，<code>expr</code> 是一个 <code>const</code>，那么将 <code>const</code> 也忽略。如果有 <code>volatile</code> 修饰，也同样忽略。（<code>volatile</code> 修饰并不常用，通常只是在实现设备驱动时会用到。更多细节，参见 Item 40）。</li>
</ol>


<p>```
int x = 27;              // as before
const int cx = x;        // as before
const int&amp; rx = x;       // as before</p>

<p>f(x);                    // T&rsquo;s and param&rsquo;s types are both int
f(cx);                   // T&rsquo;s and param&rsquo;s types are again both int
f(rx);                   // T&rsquo;s and param&rsquo;s types are still both int
```</p>

<p>注意，即使 <code>cx</code> 和 <code>rx</code> 都是 <code>const</code> 类型，<code>param</code> 的类型也不是 <code>const</code>。这是有道理的。<code>param</code> 是一个与 <code>cx</code> 和 <code>rx</code> 无关的对象 —— 是一份拷贝。因此， <code>cx</code> 和 <code>rx</code> 的 <code>const</code> 属性，不会影响 <code>param</code>。这就是为什么在类型推导过程中 <code>expr</code> 的 <code>const</code>（以及 volatile）修饰会被忽略的原因：<code>expr</code> 不可更改并不意味着它的拷贝不可以。</p>

<p>意识到 <code>const</code>（以及<code>volatile</code>）修饰仅仅在传值参数中会被忽略，是非常重要的。像前面看到的，对于 <code>const</code> 引用，或者 指向 <code>const</code> 对象的指针参数，<code>expr</code> 的 <code>const</code> 修饰是保留到类型推导中的。但是考虑以下情况，<code>expr</code> 是一个指向 <code>const</code> 对象的 <code>const</code> 指针，且 <code>expr</code> 是值传递给 <code>param</code> 的：</p>

<p>```
template <typename T>
void f(T param);                              // param is still passed by value</p>

<p>const char* const ptr = &ldquo;Fun with pointers&rdquo;;  // ptr is const pointer to const object</p>

<p>f(ptr);                                       // pass arg of type const char * const
```</p>

<p>在这里，右边（第二个）的 <code>const</code> 表示 <code>ptr</code> 不可更改。左边（第一个）表示 <code>ptr</code> 指向的常量字符串不可更改。当 <code>ptr</code> 传递给 <code>f</code> 时，<code>ptr</code> 值传递会产生一个拷贝，根据类型推导规则，<code>ptr</code> 的 <code>const</code> 修饰会被忽略掉，最终 <code>param</code> 类型为 <code>const char*</code>，即指向常量字符串的指针。<code>ptr</code> 所指向的内容的 <code>cosnt</code> 修饰被保留，而 <code>ptr</code> 本身的 <code>const</code> 修饰在值传递时被忽略。</p>

<h4>数组参数</h4>

<p>几乎所有主流的模板类型推导都包含它，但是还是有一些值得注意的地方。数组类型与指针类型是不同的，尽管他们有时可以转换。在很多时候数组是可以退化成指针的。下面的代码可以编译通过：</p>

<p>```
const char name[] = &ldquo;J. P. Briggs&rdquo;;   // name&rsquo;s type is const char[13]</p>

<p>const char* ptrToName = name;         // array decays to pointer
```</p>

<p>在这里，<code>ptrToName</code> 作为一个 <code>const char*</code> 类型，使用了 <code>const char[13]</code> 类型的 <code>name</code> 来初始化。但是这两个类型是不同的，由于数组到指针的退化规则才使得代码能够编译通过。</p>

<p>但当我们将一个数组类型传递给一个值传递的模版参数时，会发生什么呢？</p>

<p>```
template <typename T>
void f(T param);               // template with by-value paramter</p>

<p>f(name);                       // what types are deduced for T and param ?
```</p>

<p>我们使用没有模板的情况先来观察，对，没错，下面的语法是合法的，</p>

<p><code>
void myFunc(int param[]);
</code></p>

<p>但是数组参数的声明会被退化成指针，这意味着它和下面的声明是完全一致的：</p>

<p><code>
void myFunc(int* param);     // same function as above
</code></p>

<p>上面的退化是从 C 语言中继承而来的，他给我们造成了数组类型与指针类型是一样的这种幻觉。</p>

<p>由于数组参数的声明会被当作指针来看待，那么当模版参数是数组并且按值传递时，参数会被推导为指针类型。这意味着模板函数 <code>f</code> 的模板参数 <code>T</code> 会被推导为 <code>const char *</code>:</p>

<p><code>
f(name);        // name is array, but T deduced as const char*
</code></p>

<p>但是现在问题出现了，尽管参数不能是一个真正的数组类型，但是我们可以声明一个数组的引用。因此当我们更改模板函数 <code>f</code> 使他接受引用参数时，</p>

<p><code>
template &lt;typename T&gt;
void f(T&amp; param);        // template with by-reference parameter
</code></p>

<p>然后我们传入有一个数组，</p>

<p><code>
f(name);                 // pass array of f
</code></p>

<p>类型推导会将 <code>T</code> 推导为数组类型，这个类型包括了数组的长度，在这个例子中，<code>T</code> 的类型被推导成为 <code>const char[13]</code>，函数 <code>f</code> 的参数类型为 <code>const char(&amp;)[13]</code>。</p>

<p>有趣的是，它提供了一种推导数组元素个数的方式：</p>

<p>```
// return size of an array as a compile-time constant. (The array parameter has no name,
// because we care only about the number of elements it contains.)</p>

<p>template <typename T>                                // info
constexpr std::size_t arraySize(T(&amp;)[N]) noexcept    // below on
{                                                    // constexpr</p>

<pre><code>return N;                                        // and
</code></pre>

<p>}                                                    // noexcept
```</p>

<p>与 Item 15 中解释的一样，声明一个 <code>constexpr</code> 函数，那么它的返回值在编译期就确定了。这就让用一个已知的数组去声明一个同样大小的数组成为可能：</p>

<p>```
int keyVals[] = { 1, 3, 5, 7, 9, 11, 22, 35 };    // keyVals has 7 elements</p>

<p>int mappedVals[arraySize(keyVals)];               // so does mappedVals
<code>``
当然，作为一个现代的 C++ 程序员，你会很自然的习惯于用</code>std::array` 来代替内建的数组类型，</p>

<p><code>
std::array&lt;int, arraySize(keyVals)&gt; mappedVals;   // mappedVals' size is 7
</code></p>

<p><code>arraySize</code> 声明时带着 <code>noexcept</code>，这帮助编译器生成更好的代码。详细内容，参见 Item 14。</p>

<h4>函数参数</h4>

<p>在 C++ 中，不是只有数组才会退化成指针。函数类型可以退化成函数指针，上面我们讨论的关于数组的类型推导规则也适用于函数，只是退化成函数指针而已。</p>

<p>```
void someFunc(int, double);    // someFunc is a function;</p>

<pre><code>                           // type is void(int, double)
</code></pre>

<p>template<typename T>
void f1(T param);              // in f1, param passed by value</p>

<p>template<typename T>
void f2(T&amp; param);             // in f2, param passed by ref</p>

<p>f1(someFunc);                  // param deduced as ptr-to-func;</p>

<pre><code>                           // type is void (*)(int, double)
</code></pre>

<p>f2(someFunc);                  // param deduced as ref-to-func;</p>

<pre><code>                           // type is void (&amp;)(int, double)
</code></pre>

<p>```</p>

<p>在日常的使用中，这几乎没有什么区别，但是如果你已经知道了数组会退化成指针，那么你也会很自然的知道函数到指针的退化。</p>

<p>这就是模板类型推导的规则。大部分情况下它非常简单。左值在传递给全局引用时的推导有些稍微不同，但是数组和函数类型的退化更让人迷惑。有时候你会想抓住编译器问，“告诉我你在推导什么类型！” 这个时候，你需要 Item 4 中的内容，它会告诉你如何查看正在推导的类型。</p>

<h2>需要记住的</h2>

<ul>
<li>在模板类型推导时，引用类型的参数会被当作非引用，即引用限定会被忽略。</li>
<li>当推导类型是全局引用时，左值会被特殊对待。</li>
<li>当推导值传递参数时，<code>const</code>, <code>volatile</code> 会被忽略。</li>
<li>在类型推导时，数组以及函数名会退化为指针，除非它们被用来初始化引用变量。</li>
</ul>

]]></content>
  </entry>
  
</feed>
