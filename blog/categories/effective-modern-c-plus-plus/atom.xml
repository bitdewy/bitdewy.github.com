<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effective Modern C++ | Bitdewy]]></title>
  <link href="http://bitdewy.github.com/blog/categories/effective-modern-c-plus-plus/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2014-12-17T00:34:32+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译] Item 6: Use the explicitly typed initializer idiom when auto deduces undesired types.]]></title>
    <link href="http://bitdewy.github.com/blog/2014/11/23/emcpp-item-6/"/>
    <updated>2014-11-23T21:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/11/23/emcpp-item-6</id>
    <content type="html"><![CDATA[<p>Item 5 介绍了如何使用 <code>auto</code> 声明来获得好处，但是有时候 <code>auto</code> 类型推导的行为可能和你预期的不太一样。举个例子，假设我们有下面这样的一个函数：</p>

<p><code>cpp
std::vector&lt;bool&gt; features(const Widget&amp; w);
</code></p>

<p>第 5 位表示 <code>Widget</code> 是否有高优先级，我们的代码可能看起来像下面这样：</p>

<p>``` cpp
Widget w;
// &hellip;
bool highPriority = features(w)[5];  // is w high priority?
// &hellip;
processWidget(w, highPriority);      // process w in accord</p>

<pre><code>                                 // with its priority
</code></pre>

<p>```</p>

<p>上面的代码没有问题。可以很好的工作。但是如果我们把 <code>highPriority</code> 的明确类型声明改为 <code>auto</code>,</p>

<p><code>cpp
auto highPriority = features(w)[5]  // is w high priority ?
</code></p>

<p>情况就不一样了。尽管编译完全没有问题，但是行为却变得完全不可预测：</p>

<p><code>cpp
processWidget(w, highPriority);      // undefined behavior!
</code>
就像注释中写的那样，调用 <code>processWidget</code> 会产生未定义行为。但是这是为什么？答案会让大家很惊讶。使用 <code>auto</code> 之后，<code>highPriority</code> 不再是 bool 类型了。</p>

<h2>需要记住的</h2>

<p>&ndash;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 5: Prefer auto to explicit type declarations.]]></title>
    <link href="http://bitdewy.github.com/blog/2014/11/12/emcpp-item-5/"/>
    <updated>2014-11-12T15:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/11/12/emcpp-item-5</id>
    <content type="html"><![CDATA[<p>看下面的声明，很和谐</p>

<p><code>cpp
int x;
</code></p>

<p>等等，擦. 忘记初始化了，所以它的值是不确定的。也许，它可能会被初始化成 0。但是很遗憾这是不确定的。</p>

<p>再看看，解引用一个迭代器来初始化局部变量的例子：</p>

<p>``` cpp
template <typename It>  // algorithm to dwim (&ldquo;do what I mean&rdquo;)
void dwim(It b, It e)   // for all elements in range from
{                       // b to e</p>

<pre><code>while (b != e) {
    typename std::iterator_traits&lt;It&gt;::value_type currValue = *b;
    // ...
}
</code></pre>

<p>}
```</p>

<p>呃，用 <code>typename std::iterator_traits&lt;It&gt;::value_type</code> 来表示迭代器所指向的值？这样真的没问题嚒？</p>

<p>再来，如果我们想要一个闭包类型的局部变量。哦，好吧。只有编译器才知道这个闭包是什么类型，我们根本无法写出这个类型。</p>

<p>擦，擦，擦。C++ 写起来还真是头疼。没错，不过那都是过去了。有了 C++11 之后，这些问题都不存在了，我们有了 <code>auto</code>。<code>auto</code> 类型会根据初始化自动推导，所以它们必须被初始化。这意味着在现代 C++ 中你可以和那些变量未初始化的问题挥手说拜拜了：</p>

<p><code>cpp
int x1;        // potentially uninitialized
auto x2;       // error! initializer required
auto x3 = 0;   // fine, x's valye is well-defined
</code></p>

<p>迭代器解引用初始化局部变量也可以这么来写了:</p>

<p>``` cpp
template <typename It>  // as before
void dwim(It b, It e)
{</p>

<pre><code>while (b != e) {
    auto currValue = *b;
    // ...
}
</code></pre>

<p>}
```</p>

<!-- more -->


<p>由于 <code>auto</code> 类型推导（Item 2），它也可以表示那些只有编译器才知道的类型了：</p>

<p>``` cpp
auto derefUPLess =                         // comparison func.
  [](const std::unique_ptr<Widget>&amp; p1,    // for Widgets</p>

<pre><code> const std::unique_ptr&lt;Widget&gt;&amp; p2)    // pointed to by
</code></pre>

<p>  { return <em>p1 &lt; </em>p2; };                   // std::unique_ptrs
```</p>

<p>很酷吧。C++14 更牛逼了，lambda 可以用 auto 类型的参数：</p>

<p>``` cpp
auto derefUPLess =          // C++14 comparison
  [](const auto&amp; p1,        // function for</p>

<pre><code> const auto&amp; p2)        // values pointed
</code></pre>

<p>  { return <em>p1 &lt; </em>p2; };    // to by anything pointer-like
```</p>

<p>尽管很酷，但你也许会想我们不需要使用 auto 来声明一个闭包，我们有 <code>std::function</code>。是的，可以，但是这也许会和你想的不太一样。现在你可能会想 <code>std::function</code> 对象到底是什么？接下来我们把这个问题讨论清楚。</p>

<p><code>std::function</code> 是 C++11 标准库中的模板类，是函数指针的升级版。函数指针只能指向函数，而 <code>std::function</code> 对象可以表示任何可调用的对象，即任何可以像函数一样调用的对象。就像你必须给函数指针声明一个明确类型一样（类型签名必须与想要调用的函数类型一致），你必须明确 <code>std::function</code> 对象所涉及到的类型。也就是 <code>std::function</code> 的模板参数。举个例子，你想要声明一个 <code>std::function</code> 对象 <code>func</code> 它可以调用如下签名的函数：</p>

<p>``` cpp
bool(const std::unique_ptr<Widget>&amp;,    // C++11 signature for</p>

<pre><code> const std::unique_ptr&lt;Widget&gt;&amp;)    // std::unique_ptr&lt;Widget&gt;
                                    // comparison function
</code></pre>

<p>```</p>

<p>你需要这么写：</p>

<p><code>cpp
std::function&lt;bool(const std::unique_ptr&lt;Widget&gt;&amp;, const std::unique_ptr&lt;Widget&gt;&amp;)&gt; func;
</code></p>

<p>由于 lambda 表达式生成可一个可调用的对象，那么闭包可以存在一个 <code>std::function</code> 对象中。也就是说在 C++11 中， 不使用 auto 我们可以像下面这样：</p>

<p>``` cpp
std::function&lt;bool(const std::unique_ptr<Widget>&amp;, const std::unique_ptr<Widget>&amp;)> derefUPLess</p>

<pre><code>= [](const std::unique_ptr&lt;Widget&gt;&amp; p1, const std::unique_ptr&lt;Widget&gt;&amp; p2) {
    return *p1 &lt; *p2;
};
</code></pre>

<p>```</p>

<p>但一定要明白，即使我们显示的给出了参数类型，但 <code>std::function</code> 与 <code>auto</code> 也不完全一样。用 <code>auto</code> 类型来接受一个闭包，它的类型与实际类型是一致的，内存的占用也是完全一样的。而用 <code>std::function</code> 来接受一个闭包，那么对于给定的签名，内存占用是固定的。而这个大小可能不足以存储该闭包，这个时候 <code>std::function</code> 的构造函数会在堆上分配足够的内存来存储这个闭包。也就是说，通常情况下 <code>std::function</code> 对象会比 <code>auto</code> 对象使用更多的内存。同时会阻止函数内连，让函数调用多一个间接层，通过 <code>std::function</code> 来调用一个闭包集合总是要比 auto 声明的闭包要慢。换句话说，<code>std::function</code> 通常都会比 <code>auto</code> 更大，更慢，而且还可能抛出 <code>out-of-memory</code> 异常。另外，像上面的例子，<code>auto</code> 会比完整类型更简洁。总之，当需要持有一个闭包时，<code>auto</code> 是比 <code>std::function</code> 更好的选择。（另外还有一个类似的东西是 <code>std::bind</code>，同样的也是选择使用 <code>auto</code> 而不是 <code>std::function</code>，不过，在 Item 34 中，我会尽力说服你用 lambda 表达式来代替 <code>std::bind</code>）。</p>

<p><code>auto</code> 除了能避免未初始化变量，显式声明，直接保存闭包。另一个时可以避免 “短类型”，下面是你曾经可能见到过的代码：</p>

<p><code>cpp
std::vector&lt;int&gt; v;
// ...
usigned sz = v.size();
</code></p>

<p><code>v.size()</code> 的正确类型是 <code>std::vector&lt;int&gt;::size_type</code>，但是很少有程序员意识到它。<code>std::vector&lt;int&gt;::size_type</code> 内部实现的确是无符号类型，因此很多程序员使用 <code>unsigned</code> 写出了上面的代码。这会产生有趣的结果。在 32 位 Windows 上，<code>unsigned</code> 与 <code>std::vector&lt;int&gt;::size_type</code> 类型完全一致，但是在 64 位 Windows 上，<code>unsigned</code> 是 32 位，而 <code>std::vector&lt;int&gt;::size_type</code> 却是 64 位。这意味着那些在 32 位机器上运行正常的代码可能在 64 位机器上产生错误，另外当将你的程序从 32 位移植到 64 位机器上时，谁愿意花时间在这些问题上呢？</p>

<p>如果使用 <code>auto</code> 就可以不必理会这个问题了：</p>

<p><code>cpp
auto sz = v.size() // sz's type is std::vector&lt;int&gt;::size_type
</code></p>

<p>还不确定 <code>auto</code> 够不够好嚒？考虑下面的代码：</p>

<p>``` cpp
std::unorderd_map&lt;std::string, int> m;
// &hellip;
for (const std::pair&lt;std::string, int>&amp; p : m) {</p>

<pre><code>// ...    do something with p
</code></pre>

<p>}
```</p>

<p>看起来很完美？但是这是有问题的，你看发现了吗？</p>

<p>要意识到 <code>std::unorderd_map</code> 的 key 类型是 const，因此散列表（<code>std::unordered_map</code>） 的元素类型 不是 <code>std::pair&lt;std::string, int&gt;</code> 而是 <code>std::pair&lt;const std::string, int&gt;</code>。但是这与上面代码中 <code>p</code> 的类型不符。因此，编译器会将 <code>std::pair&lt;const std::string, int&gt;</code> 对象转换为 <code>std::pair&lt;std::string, int&gt;</code> 对象。这会拷贝 m 的每个元素，然后将临时对象绑定到 p。在每次循环迭代的最后临时对象会释放。如果你写了上面的代码，你一定会被上面的行为惊到，因为你的意图仅仅是将 p 引用到 m 的每个元素上而已。</p>

<p>像这样的误用，我们也可以用 <code>auto</code> 解决：</p>

<p>``` cpp
for (const auto&amp; p : m) {</p>

<pre><code>// ...  as before
</code></pre>

<p>}
```</p>

<p>这不仅是高效的，而且写起来也更方便。还不仅如此，如果你想要取 p 的地址，你会取到 m 中的元素的指针。在没有使用 <code>auto</code> 的代码中，你取到的是临时对象的指针 —— 它会在当此循环结束时销毁。</p>

<p>最后两个例子 —— 使用 <code>unsinged</code> 代替 <code>std::vector&lt;int&gt;::size_type</code> 以及 <code>std::pair&lt;std::string, int&gt;</code> 代替 <code>std::pair&lt;const std::string, int&gt;</code> —— 展示了明确类型会导致的那些你不想要的隐式转换。如果你使用 <code>auto</code> 就不用担心声明的类型与表达式实际类型不一致的问题了。</p>

<p>还有很多使用 <code>auto</code> 类型的理由。虽然 <code>auto</code> 是不完美的。<code>auto</code> 类型是根据初始化的表达式类型自动推导的，而有时候自动退到出的类型不是我们期待的类型。这种情况我们在 Item 2 与 6 中讨论。在这里，我们把注意力转移到另外一个问题上，你可能会有用 <code>auto</code> 代替传统的类型声明的问题：源代码可读性问题。</p>

<p>首先，做一次深呼吸，放松一下。<code>auto</code> 只是一种选择，而不是强制的任务。如果在你有专业的判断，使用显式类型的声会更清晰和更容易维护或以某种其他方式更好地通过，你可以自由地继续使用它们。C++ 没有采用什么新的东西，而只是运用早已被大家所熟知的类型推断而已。其他静态语言 (比如 C#, D, Scala, Visual Basic) 或多或少的都包含这种特性，更不用说静态类型的函数式语言(比如 ML, Haskell, OCaml, F# 等)了。这也归功于那些几乎从不明确类型的动态语言 Perl， Python，Ruby 的成功。软件开发社区在使用类型推断方面有着丰富的经验，它显示了这种技术与创建和维护大型、 工业强度的代码是有没有矛盾的。</p>

<p>一些开发者可能会由于无法在阅读代码时第一时间知道对象类型而感到不安。不过，IDE 通常都有办法展示出对象的类型来缓解这个问题（Item 4 中我们有提到这个问题），并且在通常情况下一个抽象的类型就可以与一个明确类型一样提供给我们足够的信息。比如，知道一个对象是容器或者计数器或者一个智能指针，而不知道它们的具体类型。如果我们精心挑选了有意义的变量名，那么这些抽象类型的信息就很容易知道了。</p>

<p>事实就是写明确类型往往会引入一些小错误，无论是类型的正确性，还是效率方面。此外，auto 类型在你更改了初始化表达式的时候会自动更改，这意味着你重构代码时一些代码的重构由 auto 代为处理了。举个例子，现在有一个函数的返回值是 <code>int</code> 类型，但不久之后，你发现 <code>long</code> 是个更好的选择，那么哪些用 <code>auto</code> 来接收函数返回值的地方在你下一次编译的时候会自动更新。如果那些代码是明确用 <code>int</code> 类型接收的话，你就需要找到所有那些调用的地方，一个个的更改它们。</p>

<h2>需要记住的</h2>

<ul>
<li><code>auto</code> 变量必须被初始化，它可以有效避免类型不匹配造成的移植性问题与性能问题，可以方便重构，通常也会比明确类型打更少的字。</li>
<li><code>auto</code> 类型的陷阱在 Item 2 与 Item 6 中。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 4: Know how to view deduced types]]></title>
    <link href="http://bitdewy.github.com/blog/2014/11/04/emcpp-item-4/"/>
    <updated>2014-11-04T14:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/11/04/emcpp-item-4</id>
    <content type="html"><![CDATA[<p>如何选择查看类型推导结果的工具依赖于你想在开发的那个阶段查看这个类型信息。下面来介绍三种可能的情况，编辑代码时，编译过程中，以及运行时。</p>

<h3>IDE 编辑器</h3>

<p>当你将鼠标移动到某处代码时，IDE 编辑器通常都会显示出类型（比如，变量，参数，函数的类型等），例如下面的代码：</p>

<p><code>cpp
const int theAnswer = 42;
auto x = theAnswer;
auto y = &amp;theAnswer;
</code></p>

<p>IDE 编辑器应该显示变量 <code>x</code> 的类型是 <code>int</code>，变量 <code>y</code> 的类型是 <code>const int*</code>。</p>

<p>要让上面的情况可以工作，你的代码必须是可编译的，因为编辑器之所以能够提示出变量的类型，是因为已经有足够的信息供它内部的编译器（或者至少是编译器前端）来做类型推导的工作。如果信息不足够供编译器做类型推导的话，那么变量类型是不会提示出来的。</p>

<p>对于像 <code>int</code> 一样的简单类型，IDE 生成的信息通常都是正确的。但是对于更复杂的情况，就像后面我们将看到的一样，IDE 生成的信息也许就不是那么有帮助了。</p>

<h3>编译器诊断</h3>

<p>让编译器提示类型推导的类型的一个有效的办法是，用这个类型构造一个编译失败的错误。编译错误的信息会告诉你这个类型。</p>

<p>考虑之前的例子，我们想看一看 <code>x</code> 和 <code>y</code> 的类型。首先我们声明一个未定义的模板类，它看起来应该是下面这样；</p>

<p><code>cpp
template &lt;typename T&gt;    // declaration only for TD;
class TD;                // TD == "Type Displayer"
</code></p>

<p>企图实例化这个模板会产生错误，因为这个模板类我们根本就没有定义。接下来，想要看 <code>x</code> 和 <code>y</code> 的类型，我们只需要用它们的类型实例化 TD 就可以了；</p>

<p>``` cpp
TD&lt;decltype(x)> xType;    // elicit errors containing
TD&lt;decltype(x)> yType;    // x&rsquo;s and y&rsquo;s types;</p>

<pre><code>                      // see Item 3 for info on decltype
</code></pre>

<p>```</p>

<!-- more -->


<p>这里我们使用 变量名+Type 来命名，方便我们从错误信息中找到它。对于上面的代码某些编译器的错误提示是下面这样的：</p>

<p><code>
error: aggregate 'TD&lt;int&gt; xType' has incomplete type and cannot be defined
error: aggregate 'TD&lt;const int *&gt; yType' has incomplete type and cannot be defined
</code></p>

<p>另外一些编译器提示从形式上来看稍微有些不同：</p>

<p><code>
error: 'xType' uses undefined class 'TD&lt;int&gt;'
error: 'yType' uses undefined class 'TD&lt;const int *&gt;'
</code></p>

<p>虽然形式稍微有些不同，但是测试过的所有编译器都能给出有用的信息。</p>

<h3>运行时输出</h3>

<p><code>printf</code> 虽然只能在运行时期打印出类型信息（我并不是想推荐你使用 <code>printf</code> 哦~），但是我们可以格式化我们想要输出的内容。现在的问题如何产生适合显示的类型信息字符串。你会想，“不用担心，<code>typeid</code> 和 <code>std::type_info::name</code> 会把我们从这个问题中解救出来”。对于我们要看 <code>x</code> 和 <code>y</code> 的类型信息的需求，你也许会说我们可以写如下的代码：</p>

<p><code>cpp
std::cout &lt;&lt; typeid(x).name() &lt;&lt; '\n';    // display types for
std::cout &lt;&lt; typeid(y).name() &lt;&lt; '\n';    // x and y
</code></p>

<p>上面的代码对 <code>x</code> 和 <code>y</code> 使用 <code>typeid</code> 返回一个 <code>std::type_info</code> 对象，然后调用它的 <code>name()</code> 方法，它会返回一个 C 风格的字符串（比如：const char*）来表示类型信息。</p>

<p>调用 <code>std::type_info::name</code> 不能保证一定返回有用的信息。但是编译器的实现会尽量保证信息是有用的。但是这个 <code>有用</code> 的范围就比较模糊了。比如 GNU 和 Clang 编译器的结果是 <code>x</code> 的类型为 &ldquo;i"，<code>y</code> 的类型为 "PKi"。一旦你熟悉了它之后，这些信息都是有用的，"i&rdquo; 表示的是 <code>int</code>，"PK" 表示的是 &ldquo;pointer to const"。（而且这两个编译器都提供一个工具 c++filt，可以来解码这些经过 mangled 的类型。）微软的编译器给出的输出看起来更清楚一些：<code>x</code> 是 "int"，而 <code>y</code> 是 "int const *"。</p>

<p>对于 <code>x</code> 和 <code>y</code> 的类型我们都得到了正确的结果，你可能会认为识别类型推导的具体类型的问题已经解决了，但是别高兴的太早，我们来看一个更复杂的例子：</p>

<p>```cpp
template <typename T>
void f(const T&amp; param);  // template function to be called</p>

<p>std::vector<Widget> createVec();  // factory function</p>

<p>const auto vw = createVec();    // init vw w/factory return</p>

<p>if (!vw.empty()) {</p>

<pre><code>f(&amp;vw[0]);        // call f
// ...
</code></pre>

<p>}
```</p>

<p>上面的代码，调用了一个用户定义类型 <code>Widget</code>，一个标准库容器 <code>std::vector</code>，以及一个 <code>auto</code> 变量 <code>vm</code>，这是一个你想要查看类型信息时更具代表性的一个例子。知道模板参数 <code>T</code> 以及 <code>param</code> 的类型是非常有用的。</p>

<p>使用 <code>typeid</code> 是一个很直白的方法，只需要在函数体中增加一点点代码即可；</p>

<p>``` cpp
template <typename T>
void f(const T&amp; param)
{</p>

<pre><code>using std::cout;
cout &lt;&lt; "T =     " &lt;&lt; typeid(T).name() &lt;&lt; '\n';      // show T
cout &lt;&lt; "param = " &lt;&lt; typeid(param).name() &lt;&lt; '\n';  // show param's type
// ...
</code></pre>

<p>}
```</p>

<p>在 GNU 和 Clang 编译器上跑一下我们得到如下输出：</p>

<p><code>
T =     PK6Widget
param = PK6Widget
</code></p>

<p>对于这个两个编译器，我们已经知道 &ldquo;PK&rdquo;  的含义是 &ldquo;pointer to const"，那么唯一的疑问就是这个神奇的数字 6了。其实很简单，这个 6 就是类名 <code>Widget</code> 的字符个数。所以，编译器告诉我们的就是 <code>T</code> 与 <code>param</code> 的类型都是 <code>const Widget*</code>。</p>

<p>微软的编译器输出如下：</p>

<p><code>
T =     class Widget const *
param = class Widget const *
</code></p>

<p>三家编译器给出了相同的结果，貌似答案是正确的。不过再仔细看看。在模板函数 <code>f</code> 中，<code>param</code> 的声明是 <code>const T&amp;</code>。这就很奇怪了，<code>T</code> 和 <code>param</code> 怎么可能是一样的类型呢。如果 <code>T</code> 是 <code>int</code> 类型，那么 <code>param</code> 的类型应该是 <code>const int&amp;</code> —— 完全不一样的类型。</p>

<p>很遗憾，<code>std::type_info::name</code> 是不可靠的，上面的例子中，三家的编译器给出的 <code>param</code> 的类型都是错的。不过，他们必须，也只能是错的，因为标准中规定了 <code>std::type_info::name</code> 的类型信息要遵循模板函数的传值参数的推导规则。就像 Item 1 中描述的那样，这意味着引用，<code>const</code> 以及 <code>volatile</code> 都会别忽略。这就是为什么 <code>param</code> 的类型 —— <code>const Widget * const &amp;</code> —— 却输出为 <code>const Widget *</code>。首先，引用被忽略掉了，同时指针本身的 <code>const</code> 修饰也被忽略掉了。</p>

<p>同样很遗憾，IDE 的编辑器的提示信息同样是不可靠的 —— 或者说是至少不可用的。比如 <code>T</code> 类型的提示信息在某个 IED 下是下面这样的（我绝对没有做过更改~）：</p>

<p><code>cpp
const std::_Simple_types&lt;std::_Wrap_alloc&lt;std::_Vec_base_types&lt;Widget, std::allocator&lt;Widget&gt; &gt;::_Alloc&gt;::value_type&gt;::value_type *
</code></p>

<p>同样的 <code>param</code> 的类型是这样的：</p>

<p><code>cpp
const std::_Simple_types&lt;...&gt;::value_type * const &amp;
</code></p>

<p>这个比 <code>T</code> 的类型看起来更短一些，不过中间的 <code>...</code> 可能会迷惑你一阵，直到你意识到这是编辑器在提示你 &ldquo;中间省略的内容与 <code>T</code> 类型一致&rdquo; 为止。运气好的话，你的开发环境可以帮助你来识别类型。</p>

<p>不过如果你更倾向于使用库而不是凭运气的话，你需要知道 <code>std::type_info::name</code> 和 IDE 都是靠不住的，而 Boost TypeIndex 库 (Boost.TypeIndex) 是一个选择。这不是标准库的一部分，也不是 IDE 提供的功能，更不是类似 <code>TD</code> 的模板。Boost 库 (<a href="http://boost.org">boost.org</a>) 是一个跨平台，开源的，并且有一个宽松的许可协议的 C++ 库。</p>

<p>下面我们来看看如何使用 Boost.TypeIndex 来解决我们上面的问题：</p>

<p>```cpp</p>

<h1>include &lt;boost/type_index.hpp></h1>

<p>template <typename T>
void f(const T&amp; param)
{</p>

<pre><code>using std::cout;
using boost::tyepindex::type_id_with_cvr;
// show T
cout &lt;&lt; "T =     " &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; '\n';
// show param's type
cout &lt;&lt; "param = " &lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name() &lt;&lt; '\n';
</code></pre>

<p>}
```</p>

<p><code>boost::tyepindex::type_id_with_cvr</code> 接受一个类型参数，并且不会去掉 const，volatile 以及引用修饰 (命名中的 <code>with_cvr</code> 也能说明这一点)。然后构造出了一个 <code>boost::tyepindex::type_index</code> 对象，成员函数 <code>pretty_name</code> 会返回一个可读性很高的 <code>std::string</code>，它的值就是我们所期待的类型信息。</p>

<p>对于这个版本的模板函数 <code>f</code> 的实现，我们再来看看之前的代码：</p>

<p>``` cpp
std::vector<Widget> createVec();  // factory function</p>

<p>const auto vw = createVec();    // init vw w/factory return</p>

<p>if (!vw.empty()) {</p>

<pre><code>f(&amp;vw[0]);        // call f
// ...
</code></pre>

<p>}
```</p>

<p>使用 Boost.TypeIndex 时，GNU 和 Clang 编译器输出的信息如下：</p>

<p><code>
T =     Widget const*
param = Widget const* const&amp;
</code></p>

<p>微软的编译器输出的信息几乎完全一致，如下：</p>

<p><code>
T =     class Widget const*
param = class Widget const* const&amp;
</code></p>

<p>这下看起来比较完美了，不过要记住，IDE 的编辑器、编译器提示信息以及像 Boost.TypeIndex 这样的库，虽然是有用的，但它们仅仅是帮助你识别类型推导结果的工具。不能代替你理解 Item 1-3 中所讲的类型推导规则。</p>

<h2>需要记住的</h2>

<ul>
<li>类型推导的结果通常可以通过 IDE 编辑器，编译器提示信息，以及 Boost.TypeIndex 库来查看。</li>
<li>一些工具产生的结果可能是没用甚至是不准确的，因此理解 C++ 的类型推导规则仍然是很必要的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 3: Understand decltype]]></title>
    <link href="http://bitdewy.github.com/blog/2014/10/21/emcpp-item-3/"/>
    <updated>2014-10-21T14:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/10/21/emcpp-item-3</id>
    <content type="html"><![CDATA[<p><code>decltype</code> 是一个奇怪的发明。给一个名字或者表达式，<code>decltype</code> 可以告诉你这个名字或者表达式的类型。通常的情况下，他告诉你的都是你预期的。但是偶尔也会有些出人意料。</p>

<p>我们从最典型的情况开始 —— 那些不会让你惊奇的情况。与模板类型推导和 <code>auto</code> 类型推导不同，<code>decltype</code> 通常只是鹦鹉学舌般的返回你传入的名字或表达式的类型：</p>

<p>``` cpp
const int i = 0;    // decltype(i) is const int</p>

<p>bool f(const Widget&amp; w);    // decltype(w) is const Widget&amp;</p>

<pre><code>                        // decltype(f) is bool(const Widget&amp;)
</code></pre>

<p>struct Point {</p>

<pre><code>int x, y;               // decltype(Point::x) is int
</code></pre>

<p>};                          // decltype(Point::y) is int</p>

<p>Widget w;                   // decltype(w) is Widget</p>

<p>if (f(w)) {                 // decltype(f(w)) is bool</p>

<pre><code>// ...
</code></pre>

<p>}</p>

<p>template<typename T>        // simplified version of std::vector
class vector {
public:</p>

<pre><code>// ...
T&amp; operator[](std::size_t index);
// ...
</code></pre>

<p>};</p>

<p>vector<int> v;              // decltype(v) is vector<int></p>

<p>if (v[0] == 0) {            // decltype(v[0]) is int&amp;</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<p>是不是完全没有惊喜？</p>

<!-- more -->


<p>在 C++11 中，<code>decltype</code> 的作用也许就是声明一个返回值类型依赖于模板参数的模板函数。举个例子，假设我们准备写一个以容器 (接受下标操作的) 和索引 <code>index</code> 为参数的函数，验证用户之后返回。返回值的类型与容器下标操作的类型相同。</p>

<p><code>T</code> 类型容器的 <code>operator[]</code> 返回值类型通常是 <code>T&amp;</code>。对于 <code>std::deque</code> 来说，是这个样，对于 <code>std::vector</code> 来说，大部分情况下也是的，不过对于 <code>std::vector&lt;bool&gt;</code> 来说，情况就不一样了，它的返回值不是 <code>bool&amp;</code>。这就是我们要在 Item 6 中讨论的问题。在这里，最重要的是，我们要知道容器的 <code>operator[]</code> 的返回值依赖于容器。</p>

<p><code>decltype</code> 可以让这个问题变得简单，下面的代码展示如何利用 <code>decltype</code> 来计算返回值。它还可以进一步的精简，我们稍后再说：</p>

<p>``` cpp
template <typename Container, typename Index>
auto authAndAccess(Container&amp; c, Index i) &ndash;> decltype(auto)  // works, but requires refinement
{</p>

<pre><code>authenticateUser();
return c[i];
</code></pre>

<p>}
```</p>

<p>函数名前面的 <code>auto</code> 在类型推导中什么用处都没有。取而代之的是 C++11 的尾随返回值类型 (trailing return type)。函数返回值的类型在函数参数列表之后声明 (在 &ndash;> 符号之后)。尾随返回值类型的好处是，函数的参数可以用于声明返回值类型。在 <code>authAndAccess</code> 中，我们的返回值类型声明用到了参数 <code>c</code> 与 <code>i</code>。如果我们将返回值类型置于函数名前，那么我们就无法使用 <code>c</code> 和 <code>i</code>，因为这时它们还没有声明。</p>

<p>上面的声明中，<code>autoAndAccess</code> 的返回值与我们预期的完全一致，就是容器 <code>Container</code> 的 <code>operator[]</code> 的返回值类型。</p>

<p>C++11 支持单句 <code>lambda</code> 的返回值类型推导，而 C++14 进行了扩展，支持所有 <code>lambda</code> 和函数，包括那些多条语句的。这意味着在上面的例子中，使用 C++14 我们可以省略掉尾随返回值类型，仅仅保留最前面的 <code>auto</code> 即可。在这里，<code>auto</code> 是类型推导的占位符。编译器会根据函数的具体实现来推导函数的返回值类型。</p>

<p>``` cpp
template<typename Container, typename Index><br/>
auto authAndAccess(Container&amp; c, Index i)    // C++14, not require
{</p>

<pre><code>authenticateUser();
return c[i];            // return type deduced from c[i]
</code></pre>

<p>}
```</p>

<p>但是，在这里返回值类型推导使用的是哪个类型推导规则？模板？ <code>auto</code> ? 还是 <code>decltype</code> ?</p>

<p>也许你会有些惊讶，函数的 <code>auto</code> 返回值类型遵循的是模板类型推导规则。看起来 <code>auto</code> 类型推导规则，在这里是一个更好的选择，不过 <code>auto</code> 类型推导与模板类型推导机会是完全一致的。唯一的区别就是模板类型推导无法推导大括号初始化。</p>

<p>在这里，<code>authAndAccess</code> 的返回值类型推导使用模板类型推导是有问题的，不过 <code>auto</code> 类型推导也是一样存在问题。这里的问题是，我们需要推导的表达式是一个引用。</p>

<p>回想一下之前的讨论，<code>operator[]</code> 对于大多数容器类型 <code>T</code> 来说，返回值类型都是 <code>T&amp;</code>，我们在 Item 1 中已经讨论过了，在模板类型推导时，表达式的引用会被忽略。考虑下这对我们上面的代码意味着什么：</p>

<p><code>cpp
std::queue&lt;int&gt; d;
// ...
authAndAccess(d, 5) = 10;  // authenticate user, return d[5], then assign 10 to it; this won't compile!
</code></p>

<p>上面的代码中，<code>d[5]</code> 返回类型是 <code>int&amp;</code>，但是 <code>auto</code> 返回值类型推导会将引用忽略掉，变成了 <code>int</code> 类型。而 <code>int</code> 类型作为一个函数的返回值，是一个右值，而上面的代码中企图将 <code>10</code> 赋值给一个右值。这在 C++ 中是禁止的，因此会编译失败。</p>

<p>这个问题是由于我们使用了会忽略引用的模板类型推导。在这里，我们需要的实际上是 <code>decltype</code> 类型推导。它能够保证返回值类型与 <code>c[i]</code> 的类型完全一致。</p>

<p>C++ 将引入新的类型推导规则，<code>decltype</code> 类型推导，在 C++14 中通过标识符 <code>decltype(auto)</code> 来实现。这看起来有些奇怪，但是很好的表达了意图：<code>auto</code> 是要推导的类型，<code>decltype</code> 表明需要遵循 <code>decltype</code> 类型推导规则。现在我们可以把之前的代码改成下面这样了：</p>

<p>``` cpp
template<typename Container, typename Index><br/>
decltype(auto) authAndAccess(Container&amp; c, Index i)    // C++14, works, but still requires refinement
{</p>

<pre><code>authenticateUser();
return c[i];
</code></pre>

<p>}
```</p>

<p>现在 <code>authAndAccess</code> 的返回值与 <code>c[i]</code> 的类型完全一致了，一般情况下当 <code>c[i]</code> 返回 <code>T&amp;</code> 类型时，<code>authAndAccess</code> 也会返回 <code>T&amp;</code>，而当 <code>c[i]</code> 需要返回一个 object 类型时，<code>authAndAccess</code> 也会返回 object 类型。</p>

<p><code>decltype(auto)</code> 的使用，不仅限于函数返回值类型，当你需要使用 <code>decltype</code> 类型推导规则时，它可以用于声明变量：</p>

<p>``` cpp
Widget w;
const Widget&amp; cw = w;
auto myWiget1 = cw;    // auto type deduction:</p>

<pre><code>                   // myWidget1's type is Widget
</code></pre>

<p>decltype(auto) myWidget2 = cw;  // decltype type deduction:</p>

<pre><code>                            // myWidget2's type is const Widget&amp;
</code></pre>

<p>```</p>

<p>但肯定还有两个问题困扰着你，一个就是上面的代码中提到的优化，我们到现在还没有谈到，现在就让我们来看这个问题。</p>

<p>回头看看我们的 C++14 版本的 <code>authAndAccess</code> 函数声明；</p>

<p><code>cpp
template&lt;typename Container, typename Index&gt;  
decltype(auto) authAndAccess(Container&amp; c, Index i);
</code></p>

<p>容器参数的类型是左值引用，这样可以让容器返回元素供调用者修改。但是这意味着这个函数无法接受右值的容器作为参数了，因为右值是无法绑定到左值引用的。</p>

<p>不可否认，传一个右值给 <code>authAndAccess</code> 的场景非常少见。一个右值的容器作为一个临时对象会在函数 <code>authAndAccess</code> 结束时销毁，这意味着容器元素的引用（ <code>authAndAccess</code> 函数的返回值）会失效。但是给 <code>authAndAccess</code> 传入一个临时对象还是有意义的。调用者有时会需要一个容器元素的拷贝的，比如下面的代码：</p>

<p>``` cpp
std::deque&lt;std::string> makeStringDeque();  // factory function</p>

<p>// make copy of 5th element of deque returned
// from makeStringDeque
auto s = authAndAccess(makeStringDeque(), 5);
```</p>

<p>支持上面的用法，意味着我们要将原本的函数修改为同时支持左值和右值。重载是可以解决这个问题，但是这样一来我们就需要维护两个函数了。有一种办法可以避免同时维护两个函数，我们可以让函数 <code>authAndAccess</code> 同时支持左值以及右值参数，Item 24 中，我们会详细的介绍全局引用。修改后的 <code>authAndAccess</code> 函数声明如下和：</p>

<p><code>cpp
template &lt;typename Container, typename Index&gt;          // c is now a
decltype(auto) authAndAccess(Container&amp;&amp; c, Index i);  // universal reference
</code></p>

<p>在上面的模板中，我们不知道 <code>Container</code> 的类型，同时我们也忽略了 index 对象的类型。对一个未知类型使用值传递会因为不必要的拷贝而造成性能问题，也会有对象切割问题（Item 41），还会被同事吐槽，不过在这里我们只考虑标准库容器的情况（比如，<code>std::string</code>, <code>std::vector</code> 以及 <code>std::deque</code> 的 <code>operator[]</code>），在这里仍然坚持使用值传递。</p>

<p>不过我们还需要更新一下模板函数的实现，根据 Item 25，我们使用 <code>std::forward</code> 把全局引用包起来，</p>

<p>``` cpp
template <typename Container, typename Index>
decltype(auto) authAndAccess(Container&amp;&amp; c, Index i)  // final C++14 version
{</p>

<pre><code>authenticateUser();
return std::forward&lt;Container&gt;(c)[i];
</code></pre>

<p>}
```</p>

<p>上面的代码完全符合我们的需求，不过需要支持 C++14 的编译器。如果你现在还没有支持 C++14 的编译器的话，那就需要一个 C++11 的版本。和 C++14 的版本非常相似，唯一的不同点是我们需要手动的指定返回值类型，</p>

<p>``` cpp
template <typename Container, typename Index>    // final C++11 version
auto authAndAccess(Container&amp;&amp; c, Index i) &ndash;> decltype(std::forward<Container>&copy;[i])
{</p>

<pre><code>authenticateUser();
return std::forward&lt;Container&gt;(c)[i];
</code></pre>

<p>}
```</p>

<p>另一个问题 —— 除非你是一个库的作者，不然的话，这种情况基本不可能遇到。</p>

<p>要完全明白 <code>decltype</code> 的行为，你必须了解少数的特殊情况。大多数不值得在本书中讨论，不过我们现在来看一看它们是如何使用的。</p>

<p>对一个变量名使用 <code>decltype</code>，会得到与变量名一致的类型。变量名是一个左值，但是不会影响 <code>decltype</code> 的行为。但对于左值表达式来说，情况就变的复杂了，它会使 <code>decltype</code> 返回左值引用。也就是说，如果一个左值表达式不仅仅是一个变量名，那么对于类型 <code>T</code> 的左值表达式使用 <code>decltype</code>， 它会得到一个 <code>T&amp;</code> 类型。这很少会产生冲突，因为大部分的左值表达式都内含左值引用的限定符。例如返回左值的函数通常返回的都是左值引用。</p>

<p>但是这还是会产生一些不期望的问题，例如，</p>

<p><code>cpp
int x = 0;
</code></p>

<p><code>x</code> 是变量名，<code>decltype(x)</code> 的类型是 <code>int</code>。但是，使用括号将 <code>x</code> 包起来，情况就不一样了。<code>x</code> 是一个左值， <code>(x)</code> 是一个左值表达式，<code>decltype((x))</code> 的类型是 <code>int&amp;</code>。一个括号改变了 <code>decltype</code> 的类型。</p>

<p>在 C++11 中，这不是大问题，但在 C++14 中，由于支持了 <code>decltype(auto)</code>，这个微不足道的变化会变的影响含漱的返回值类型推导。</p>

<p>``` cpp
decltype(auto) f1()
{</p>

<pre><code>int x = 0;
// ...
return x;    // decltype(x) is int, so f1 returns int
</code></pre>

<p>}</p>

<p>decltype(auto) f2()
{</p>

<pre><code>int x = 0;
// ...
return (x);    // decltype((x)) is int&amp;, so f2 returns int&amp;
</code></pre>

<p>}
```</p>

<p>注意，<code>f2</code> 不仅仅只是与 <code>f1</code> 的返回值类型不同，它还返回了一个局部变量的引用。这使得你的代码不知不觉的就产生了未定义行为。</p>

<p>这就是说当你使用 <code>decltype(auto)</code> 时，必须要非常小心。一些非常小的细节就可能会影响 <code>decltype(auto)</code> 的类型推导结果。确定类型推导的结果是否符合你的预期，你需要用到 Item 4 中介绍的技术手段。</p>

<p>与此同时，不要忘记从更高的角度来审视这个问题。<code>decltype</code>（不论是否与 <code>auto</code> 在一起）偶尔会产生让你惊讶的结果，但是它不是一般情况。<code>decltype</code> 通常都会符合你的预期。这对于变量名来说是非常正确的。这种情况下，<code>decltype</code> 就像它们看起来的那样：它推导的结果就是变量声明的类型。</p>

<h2>需要记住的</h2>

<ul>
<li><code>decltype</code> 几乎总是与表达式的类型完全一致。</li>
<li>对于类型为 <code>T</code> 的左值表达式（除了变量名），<code>decltype</code> 的类型为 <code>T&amp;</code>。</li>
<li>C++14 支持 <code>decltype(auto)</code>，与 <code>auto</code> 类似，在初始化的时候推导变量的类型，但是使用 <code>decltype</code> 类型推导规则。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 2: Understand auto type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2/"/>
    <updated>2014-09-18T23:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2</id>
    <content type="html"><![CDATA[<p>如果你已经阅读了 Item 1 模板类型推导，那么你应该已经掌握了 <code>auto</code> 的类型推导，出了下面要讲到的一个不同之外，其他都和 Item 1 完全一致，但是你肯定还有疑问，为什么模板类型推导涉及到了模板，函数以及参数，而 <code>auto</code> 却不涉及这些。</p>

<p>没错，但是这也没什么关系。其实模板类型推导与 <code>auto</code> 类型推导有直接的映射关系。有很直观的转换关系。</p>

<p>在 Item 1 中，我们使用下面的模板函数用来描述模板类型推导，</p>

<p><code>cpp
template &lt;typename T&gt;
void f(ParamType param);
</code></p>

<p>调用如下：</p>

<p><code>cpp
f (expr);    // call f with some expression
</code></p>

<p>在调用函数 <code>f</code> 时，编译器使用表达式 <code>expr</code> 来推导类型 <code>T</code> 和 <code>ParamType</code>。</p>

<p>当使用 <code>auto</code> 来声明变量时，<code>auto</code> 代替了上面 <code>T</code> 的位置，同时变量的类型就是 <code>ParamType</code> 的类型。看下面的例子会更直观，</p>

<p><code>cpp
auto x = 27;
</code></p>

<p>在这里，变量 <code>x</code> 的类型标识符就是一个简单的 <code>auto</code>，在</p>

<p><code>cpp
const auto cx = x;
</code></p>

<p>中，类型标识符是 <code>const auto</code>，在</p>

<p><code>cpp
const auto&amp; rx = x;
</code></p>

<p>中，类型标识符是 <code>const auto&amp;</code>。推导上面 <code>x</code>, <code>cx</code> 以及 <code>rx</code> 的类型，编译器所做的事情就像是有一个模板函数一样，</p>

<p>``` cpp
template <typename T>
void func_for_x(T param);           // conceptual template for deducing x&rsquo;s type</p>

<p>func_for_x(27);                     // conceptual call: param&rsquo;s deduced type is x&rsquo;s type</p>

<p>template <typename T>
void func_for_cx(const T param);    // conceptual template for deducing cx&rsquo;s type</p>

<p>func_for_cx(x);                     // conceptual call: param&rsquo;s deduced type is cx&rsquo;s type</p>

<p>template <typename T>
void func_for_rx(const T&amp; param);   // conceptual template for deducing rx&rsquo;s type</p>

<p>func_for_rx(x);                     // conceptual call: param&rsquo;s deduced type is rx&rsquo;s type
```</p>

<!-- more -->


<p>就像刚才说的一样，<code>auto</code> 的类型推导只有一点（一会儿会讲到）不一样之外，其他与模板类型推导完全一致。</p>

<p>Item 1 中根据 <code>ParamType</code> 的类型，把类型推导分了三种情况来处理，在 <code>auto</code> 类型推导时，<code>auto</code> 替代了 <code>ParamType</code>  也同样分为三种情况，</p>

<ul>
<li>情况1：类型标识符是一个指针或者引用，但不是右值引用</li>
<li>情况2：类型标识符是一个全局引用</li>
<li>情况3：类型标识符既不是指针也不是引用</li>
</ul>


<p>我们已经见过了情况1 与情况3 的例子了，</p>

<p>``` cpp
auto x = 27;           // case 3 (x is neither ptr nor reference)</p>

<p>const auto cx = x;     // case 3 (cx isn&rsquo;t neither)</p>

<p>const auto&amp; rx = x;    // case 1 (rx is a non-universal ref.)</p>

<p>```</p>

<p>情况2 就像你预期的那样，</p>

<p>``` cpp
auto&amp;&amp; uref1 = x;     // x is int lvalue, so uref1&rsquo;s type is int&amp;</p>

<p>auto&amp;&amp; uref2 = cx;    // cx is const int and lvalue, so uref2&rsquo;s type is const int&amp;</p>

<p>auto&amp;&amp; uref3 = 27;    // 27 is int and rvalue, so uref3&rsquo;s type is int&amp;&amp;
```</p>

<p>Item 1 中我们讨论了非引用的数组和函数是如何退化成指针的。在 <code>auto</code> 类型推导中也是一样的，</p>

<p>``` cpp
const char name[] = &ldquo;R. N. Briggs&rdquo;;    // name&rsquo;s type is const char[13]</p>

<p>auto arr1 = name;                      // arr1&rsquo;s type is const char *</p>

<p>auto&amp; arr2 = name;                     // arr2&rsquo;s type is const char (&amp;)[13]</p>

<p>void someFunc(int, double);            // someFunc is function, type is void(int, double)</p>

<p>auto func1 = someFunc;                 // func1&rsquo;s type is void(*)(int, double)</p>

<p>auto&amp; func2 = someFunc;                // func2&rsquo;s type is void(&amp;)(int, double)
```</p>

<p>就像你看到这样，<code>auto</code> 类型推导就像模板类型推导一样。</p>

<p>仅有一种情况，他们是不一样的。我们从一个简单的例子开始，在 C++98 中，我们用 27 来初始化一个 int 变量，我们可以有下面两种写法，</p>

<p><code>cpp
int x1 = 27;
int x2(27);
</code></p>

<p>C++11 统一初始化，增加了下面的写法，</p>

<p><code>cpp
int x3 = { 27 };
int x4{ 27 };
</code></p>

<p>总而言之，4中不同的写法的结果都是一样的，初始化了一个值为 27 的整型。</p>

<p>但是，就像 Item 5 中解释的一样，使用 <code>auto</code> 来声明类型是可以获得好处的，所有我们可以将上面的 <code>int</code> 全部替换为 <code>auto</code>：</p>

<p><code>cpp
auto x1 = 27;
auto x2(27);
auto x3 = { 27 };
auto x4{ 27 };
</code></p>

<p>这 4 种写法都能够正常编译，但是却表达了不同的含义。前两种写法定义了一个值为 27 的整型。但后两种写法实际上定义了一个只有一个元素 27 的 <code>std::initializer_list&lt;int&gt;</code>！</p>

<p><code>cpp
auto x1 = 27;        // type is int, value is 27
auto x2(27);         // ditto
auto x3 = { 27 };    // type is std::initializier_list&lt;int&gt;, value is { 27 }
auto x4{ 27 };       // ditto
</code></p>

<p>这是 <code>auto</code> 类型推导的一个特殊规则。当使用大括号初始化一个 <code>auto</code> 变量时，类型会被推导为 <code>std::initializer_list</code>，如果类型推导不成功（比如，大括号中的某个元素类型与其他的不一致），那么将会编译失败：</p>

<p><code>cpp
auto x5 = { 1, 2, 3.0 };    // error! can't deduce T for std::initializer_list&lt;int&gt;
</code></p>

<p>就像上面注释中写的一样，类型推导在这种情况下会失败，但是要明白这里有两个类型推导，这是很重要的。第一个是 <code>auto</code>，<code>x5</code> 使用了大括号来初始化，那么 <code>auto</code> 会被推导为 <code>std::initializer_list</code> 类型，但同时 <code>std::initializer_list</code> 是一个模板类型，模板参数 <code>T</code> 同样需要推导，类型推导失败产生于第二步：模板类型推导。在上面的例子中，就是由于大括号中的元素类型不一致而导致的模板类型推导失败。</p>

<p><code>auto</code> 类型推导与模板类型推导的唯一不同在于大括号初始化。当使用大括号初始化时，<code>auto</code> 会推到为 <code>std::initializer_list</code> 类型，但对于模板类型推导来说，这会产生一个错误，</p>

<p>``` cpp
auto x = { 11, 23, 9 };  // x&rsquo;s type is std::initializer_list<int></p>

<p>template<typename T>
void f(T param);         // template with parameter declaration equivalent to x&rsquo;s</p>

<p>f({ 11, 23, 9});         // error! can&rsquo;t deduce type for T
```</p>

<p>不过，如果你明确指定了 <code>param</code> 的类型为 <code>std::initializer_list&lt;T&gt;</code> 那么模板类型推导会推导出 <code>T</code> 的类型，</p>

<p>``` cpp
template<typename T>
void f(std::initializer_list<T> initList);</p>

<p>f({ 11, 23, 9 });    // T deduce as int, and initList&rsquo;s type is std::initializer_list<int>
```</p>

<p>因此，<code>auto</code> 类型推导与模板类型推导唯一的不同在于，对于大括号初始化，<code>auto</code> 类型推导会将它推导为 <code>std::initializer_list</code>，而模板类型推导不会。</p>

<p>也许你会想知道为什么会有这样的区别。我也曾想过，但是没有找到一个很好的解释。不过规则就是规则，你只需要记住，当使用大括号初始化 <code>auto</code> 类型时，它会被自动推到为 <code>std::initializer_list</code> 类型。如果你想要使用新的统一初始化，那么记住这一点是非常重要的。一个典型的 C++11 错误就是当你想要一个其他类型时却意外的声明了一个 <code>std::initializer_list</code> 类型。这也是为什么有些开发者仅仅在必要的时候才使用大括号初始化的一个原因。（我们会在 Item 7 中详细讨论）</p>

<p>对 C++11 来说，这就是全部了。但是对于 C++14，还有些其他内容。C++14 允许使用 <code>auto</code> 来表示需要被推导的函数返回值类型（详见 Item 3），C++14 的 lambda 中也允许 <code>auto</code> 用作参数类型。但是这些 <code>auto</code> 遵循的是模板类型推导，而不是 <code>auto</code> 类型推导。因此，一个返回值类型声明为 <code>auto</code> 返回一个大括号初始化时，会导致编译失败，</p>

<p>``` cpp
auto createInitList()
{</p>

<pre><code>return { 1, 2, 3 };    // error: can't deduce type for { 1, 2, 3 }
</code></pre>

<p>}
```</p>

<p>lambda:</p>

<p>``` cpp
std::vector<int> v;
// &hellip;
auto resetV = <a href="const%20auto&amp;%20newValue">&amp;v</a> { v = newValue; };    // C++14
// &hellip;</p>

<p>resetV({ 1, 2, 3 });    // error! can&rsquo;t deduce type for { 1, 2, 3 }
```</p>

<h2>需要记住的</h2>

<ul>
<li><code>auto</code> 类型推导通常和模板类型推导是一致的，但是 <code>auto</code> 类型推导会将大括号初始化推到为 <code>std::initializer_list</code>，而模板类型推导不会</li>
<li><code>auto</code> 在函数返回值以及 lambda 参数类型推导时，遵循模板类型推导，而不是 <code>auto</code> 类型推导。</li>
</ul>

]]></content>
  </entry>
  
</feed>
