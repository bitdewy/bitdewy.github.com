<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effective Modern C++ | Bitdewy]]></title>
  <link href="http://bitdewy.github.com/blog/categories/effective-modern-c-plus-plus/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2014-11-02T22:01:50+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译] Item 3: Understand decltype]]></title>
    <link href="http://bitdewy.github.com/blog/2014/10/21/emcpp-item-3/"/>
    <updated>2014-10-21T14:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/10/21/emcpp-item-3</id>
    <content type="html"><![CDATA[<p><code>decltype</code> 是一个奇怪的发明。给一个名字或者表达式，<code>decltype</code> 可以告诉你这个名字或者表达式的类型。通常的情况下，他告诉你的都是你预期的。但是偶尔也会有些出人意料。</p>

<p>我们从最典型的情况开始 —— 那些不会让你惊奇的情况。与模板类型推导和 <code>auto</code> 类型推导不同，<code>decltype</code> 通常只是鹦鹉学舌般的返回你传入的名字或表达式的类型：</p>

<p>```
const int i = 0;    // decltype(i) is const int</p>

<p>bool f(const Widget&amp; w);    // decltype(w) is const Widget&amp;</p>

<pre><code>                        // decltype(f) is bool(const Widget&amp;)
</code></pre>

<p>struct Point {</p>

<pre><code>int x, y;               // decltype(Point::x) is int
</code></pre>

<p>};                          // decltype(Point::y) is int</p>

<p>Widget w;                   // decltype(w) is Widget</p>

<p>if (f(w)) {                 // decltype(f(w)) is bool</p>

<pre><code>// ...
</code></pre>

<p>}</p>

<p>template<typename T>        // simplified version of std::vector
class vector {
public:</p>

<pre><code>// ...
T&amp; operator[](std::size_t index);
// ...
</code></pre>

<p>};</p>

<p>vector<int> v;              // decltype(v) is vector<int></p>

<p>if (v[0] == 0) {            // decltype(v[0]) is int&amp;</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<p>是不是完全没有惊喜？</p>

<!-- more -->


<p>在 C++11 中，<code>decltype</code> 的作用也许就是声明一个返回值类型依赖于模板参数的模板函数。举个例子，假设我们准备写一个以容器 (接受下标操作的) 和索引 <code>index</code> 为参数的函数，验证用户之后返回。返回值的类型与容器下标操作的类型相同。</p>

<p><code>T</code> 类型容器的 <code>operator[]</code> 返回值类型通常是 <code>T&amp;</code>。对于 <code>std::deque</code> 来说，是这个样，对于 <code>std::vector</code> 来说，大部分情况下也是的，不过对于 <code>std::vector&lt;bool&gt;</code> 来说，情况就不一样了，它的返回值不是 <code>bool&amp;</code>。这就是我们要在 Item 6 中讨论的问题。在这里，最重要的是，我们要知道容器的 <code>operator[]</code> 的返回值依赖于容器。</p>

<p><code>decltype</code> 可以让这个问题变得简单，下面的代码展示如何利用 <code>decltype</code> 来计算返回值。它还可以进一步的精简，我们稍后再说：</p>

<p>```
template <typename Container, typename Index>
auto authAndAccess(Container&amp; c, Index i) &ndash;> decltype(auto)  // works, but requires refinement
{</p>

<pre><code>authenticateUser();
return c[i];
</code></pre>

<p>}
```</p>

<p>函数名前面的 <code>auto</code> 在类型推导中什么用处都没有。取而代之的是 C++11 的尾随返回值类型 (trailing return type)。函数返回值的类型在函数参数列表之后声明 (在 &ndash;> 符号之后)。尾随返回值类型的好处是，函数的参数可以用于声明返回值类型。在 <code>authAndAccess</code> 中，我们的返回值类型声明用到了参数 <code>c</code> 与 <code>i</code>。如果我们将返回值类型置于函数名前，那么我们就无法使用 <code>c</code> 和 <code>i</code>，因为这时它们还没有声明。</p>

<p>上面的声明中，<code>autoAndAccess</code> 的返回值与我们预期的完全一致，就是容器 <code>Container</code> 的 <code>operator[]</code> 的返回值类型。</p>

<p>C++11 支持单句 <code>lambda</code> 的返回值类型推导，而 C++14 进行了扩展，支持所有 <code>lambda</code> 和函数，包括那些多条语句的。这意味着在上面的例子中，使用 C++14 我们可以省略掉尾随返回值类型，仅仅保留最前面的 <code>auto</code> 即可。在这里，<code>auto</code> 是类型推导的占位符。编译器会根据函数的具体实现来推导函数的返回值类型。</p>

<p>```
template<typename Container, typename Index><br/>
auto authAndAccess(Container&amp; c, Index i)    // C++14, not require
{</p>

<pre><code>authenticateUser();
return c[i];            // return type deduced from c[i]
</code></pre>

<p>}
<code>``
但是，在这里返回值类型推导使用的是哪个类型推导规则？模板？</code>auto<code>? 还是</code>decltype` ?</p>

<p>也许你会有些惊讶，函数的 <code>auto</code> 返回值类型遵循的是模板类型推导规则。看起来 <code>auto</code> 类型推导规则，在这里是一个更好的选择，不过 <code>auto</code> 类型推导与模板类型推导机会是完全一致的。唯一的区别就是模板类型推导无法推导大括号初始化。</p>

<p>在这里，<code>authAndAccess</code> 的返回值类型推导使用模板类型推导是有问题的，不过 <code>auto</code> 类型推导也是一样存在问题。这里的问题是，我们需要推导的表达式是一个引用。</p>

<p>回想一下之前的讨论，<code>operator[]</code> 对于大多数容器类型 <code>T</code> 来说，返回值类型都是 <code>T&amp;</code>，我们在 Item 1 中已经讨论过了，在模板类型推导时，表达式的引用会被忽略。考虑下这对我们上面的代码意味着什么：</p>

<p><code>
std::queue&lt;int&gt; d;
// ...
authAndAccess(d, 5) = 10;  // authenticate user, return d[5], then assign 10 to it; this won't compile!
</code>
上面的代码中，<code>d[5]</code> 返回类型是 <code>int&amp;</code>，但是 <code>auto</code> 返回值类型推导会将引用忽略掉，变成了 <code>int</code> 类型。而 <code>int</code> 类型作为一个函数的返回值，是一个右值，而上面的代码中企图将 <code>10</code> 赋值给一个右值。这在 C++ 中是禁止的，因此会编译失败。</p>

<p>这个问题是由于我们使用了会忽略引用的模板类型推导。在这里，我们需要的实际上是 <code>decltype</code> 类型推导。它能够保证返回值类型与 <code>c[i]</code> 的类型完全一致。</p>

<p>C++ 将引入新的类型推导规则，<code>decltype</code> 类型推导，在 C++14 中通过标识符 <code>decltype(auto)</code> 来实现。这看起来有些奇怪，但是很好的表达了意图：<code>auto</code> 是要推导的类型，<code>decltype</code> 表明需要遵循 <code>decltype</code> 类型推导规则。现在我们可以把之前的代码改成下面这样了：</p>

<p>```
template<typename Container, typename Index><br/>
decltype(auto) authAndAccess(Container&amp; c, Index i)    // C++14, works, but still requires refinement
{</p>

<pre><code>authenticateUser();
return c[i];
</code></pre>

<p>}
<code>``
现在</code>authAndAccess<code>的返回值与</code>c[i]<code>的类型完全一致了，一般情况下当</code>c[i]<code>返回</code>T&amp;<code>类型时，</code>authAndAccess<code>也会返回</code>T&amp;<code>，而当</code>c[i]<code>需要返回一个 object 类型时，</code>authAndAccess` 也会返回 object 类型。</p>

<p><code>decltype(auto)</code> 的使用，不仅限于函数返回值类型，当你需要使用 <code>decltype</code> 类型推导规则时，它可以用于声明变量：</p>

<p>```
Widget w;
const Widget&amp; cw = w;
auto myWiget1 = cw;    // auto type deduction:</p>

<pre><code>                   // myWidget1's type is Widget
</code></pre>

<p>decltype(auto) myWidget2 = cw;  // decltype type deduction:</p>

<pre><code>                            // myWidget2's type is const Widget&amp;
</code></pre>

<p>```</p>

<p>但肯定还有两个问题困扰着你，一个就是上面的代码中提到的优化，我们到现在还没有谈到，现在就让我们来看这个问题。</p>

<p>回头看看我们的 C++14 版本的 <code>authAndAccess</code> 函数声明；</p>

<p><code>
template&lt;typename Container, typename Index&gt;  
decltype(auto) authAndAccess(Container&amp; c, Index i);
</code>
容器参数的类型是左值引用，这样可以让容器返回元素供调用者修改。但是这意味着这个函数无法接受右值的容器作为参数了，因为右值是无法绑定到左值引用的。</p>

<p>不可否认，传一个右值给 <code>authAndAccess</code> 的场景非常少见。一个右值的容器作为一个临时对象会在函数 <code>authAndAccess</code> 结束时销毁，这意味着容器元素的引用（ <code>authAndAccess</code> 函数的返回值）会失效。但是给 <code>authAndAccess</code> 传入一个临时对象还是有意义的。调用者有时会需要一个容器元素的拷贝的，比如下面的代码：</p>

<p>```
std::deque&lt;std::string> makeStringDeque();  // factory function</p>

<p>// make copy of 5th element of deque returned
// from makeStringDeque
auto s = authAndAccess(makeStringDeque(), 5);
```</p>

<p>支持上面的用法，意味着我们要将原本的函数修改为同时支持左值和右值。重载是可以解决这个问题，但是这样一来我们就需要维护两个函数了。有一种办法可以避免同时维护两个函数，我们可以让函数 <code>authAndAccess</code> 同时支持左值以及右值参数，Item 24 中，我们会详细的介绍全局引用。修改后的 <code>authAndAccess</code> 函数声明如下和：</p>

<p><code>
template &lt;typename Container, typename Index&gt;          // c is now a
decltype(auto) authAndAccess(Container&amp;&amp; c, Index i);  // universal reference
</code></p>

<p>在上面的模板中，我们不知道 <code>Container</code> 的类型，同时我们也忽略了 index 对象的类型。对一个未知类型使用值传递会因为不必要的拷贝而造成性能问题，也会有对象切割问题（Item 41），还会被同事吐槽，不过在这里我们只考虑标准库容器的情况（比如，<code>std::string</code>, <code>std::vector</code> 以及 <code>std::deque</code> 的 <code>operator[]</code>），在这里仍然坚持使用值传递。</p>

<p>不过我们还需要更新一下模板函数的实现，根据 Item 25，我们使用 <code>std::forward</code> 把全局引用包起来，</p>

<p>```
template <typename Container, typename Index>
decltype(auto) authAndAccess(Container&amp;&amp; c, Index i)  // final C++14 version
{</p>

<pre><code>authenticateUser();
return std::forward&lt;Container&gt;(c)[i];
</code></pre>

<p>}
```</p>

<p>上面的代码完全符合我们的需求，不过需要支持 C++14 的编译器。如果你现在还没有支持 C++14 的编译器的话，那就需要一个 C++11 的版本。和 C++14 的版本非常相似，唯一的不同点是我们需要手动的指定返回值类型，</p>

<p>```
template <typename Container, typename Index>    // final C++11 version
auto authAndAccess(Container&amp;&amp; c, Index i) &ndash;> decltype(std::forward<Container>&copy;[i])
{</p>

<pre><code>authenticateUser();
return std::forward&lt;Container&gt;(c)[i];
</code></pre>

<p>}
```</p>

<p>另一个问题 —— 除非你是一个库的作者，不然的话，这种情况基本不可能遇到。</p>

<p>要完全明白 <code>decltype</code> 的行为，你必须了解少数的特殊情况。大多数不值得在本书中讨论，不过我们现在来看一看它们是如何使用的。</p>

<p>对一个变量名使用 <code>decltype</code>，会得到与变量名一致的类型。变量名是一个左值，但是不会影响 <code>decltype</code> 的行为。但对于左值表达式来说，情况就变的复杂了，它会使 <code>decltype</code> 返回左值引用。也就是说，如果一个左值表达式不仅仅是一个变量名，那么对于类型 <code>T</code> 的左值表达式使用 <code>decltype</code>， 它会得到一个 <code>T&amp;</code> 类型。这很少会产生冲突，因为大部分的左值表达式都内含左值引用的限定符。例如返回左值的函数通常返回的都是左值引用。</p>

<p>但是这还是会产生一些不期望的问题，例如，</p>

<p><code>
int x = 0;
</code></p>

<p><code>x</code> 是变量名，<code>decltype(x)</code> 的类型是 <code>int</code>。但是，使用括号将 <code>x</code> 包起来，情况就不一样了。<code>x</code> 是一个左值， <code>(x)</code> 是一个左值表达式，<code>decltype((x))</code> 的类型是 <code>int&amp;</code>。一个括号改变了 <code>decltype</code> 的类型。</p>

<p>在 C++11 中，这不是大问题，但在 C++14 中，由于支持了 <code>decltype(auto)</code>，这个微不足道的变化会变的影响含漱的返回值类型推导。</p>

<p>```
decltype(auto) f1()
{</p>

<pre><code>int x = 0;
// ...
return x;    // decltype(x) is int, so f1 returns int
</code></pre>

<p>}</p>

<p>decltype(auto) f2()
{</p>

<pre><code>int x = 0;
// ...
return (x);    // decltype((x)) is int&amp;, so f2 returns int&amp;
</code></pre>

<p>}
```</p>

<p>注意，<code>f2</code> 不仅仅只是与 <code>f1</code> 的返回值类型不同，它还返回了一个局部变量的引用。这使得你的代码不知不觉的就产生了未定义行为。</p>

<p>这就是说当你使用 <code>decltype(auto)</code> 时，必须要非常小心。一些非常小的细节就可能会影响 <code>decltype(auto)</code> 的类型推导结果。确定类型推导的结果是否符合你的预期，你需要用到 Item 4 中介绍的技术手段。</p>

<p>与此同时，不要忘记从更高的角度来审视这个问题。<code>decltype</code>（不论是否与 <code>auto</code> 在一起）偶尔会产生让你惊讶的结果，但是它不是一般情况。<code>decltype</code> 通常都会符合你的预期。这对于变量名来说是非常正确的。这种情况下，<code>decltype</code> 就像它们看起来的那样：它推导的结果就是变量声明的类型。</p>

<h2>需要记住的</h2>

<ul>
<li><code>decltype</code> 几乎总是与表达式的类型完全一致。</li>
<li>对于类型为 <code>T</code> 的左值表达式（除了变量名），<code>decltype</code> 的类型为 <code>T&amp;</code>。</li>
<li>C++14 支持 <code>decltype(auto)</code>，与 <code>auto</code> 类似，在初始化的时候推导变量的类型，但是使用 <code>decltype</code> 类型推导规则。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 2: Understand auto type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2/"/>
    <updated>2014-09-18T23:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2</id>
    <content type="html"><![CDATA[<p>如果你已经阅读了 Item 1 模板类型推导，那么你应该已经掌握了 <code>auto</code> 的类型推导，出了下面要讲到的一个不同之外，其他都和 Item 1 完全一致，但是你肯定还有疑问，为什么模板类型推导涉及到了模板，函数以及参数，而 <code>auto</code> 却不涉及这些。</p>

<p>没错，但是这也没什么关系。其实模板类型推导与 <code>auto</code> 类型推导有直接的映射关系。有很直观的转换关系。</p>

<p>在 Item 1 中，我们使用下面的模板函数用来描述模板类型推导，</p>

<p><code>
template &lt;typename T&gt;
void f(ParamType param);
</code></p>

<p>调用如下：</p>

<p><code>
f (expr);    // call f with some expression
</code></p>

<p>在调用函数 <code>f</code> 时，编译器使用表达式 <code>expr</code> 来推导类型 <code>T</code> 和 <code>ParamType</code>。</p>

<p>当使用 <code>auto</code> 来声明变量时，<code>auto</code> 代替了上面 <code>T</code> 的位置，同时变量的类型就是 <code>ParamType</code> 的类型。看下面的例子会更直观，</p>

<p><code>
auto x = 27;
</code></p>

<p>在这里，变量 <code>x</code> 的类型标识符就是一个简单的 <code>auto</code>，在</p>

<p><code>
const auto cx = x;
</code></p>

<p>中，类型标识符是 <code>const auto</code>，在</p>

<p><code>
const auto&amp; rx = x;
</code></p>

<p>中，类型标识符是 <code>const auto&amp;</code>。推导上面 <code>x</code>, <code>cx</code> 以及 <code>rx</code> 的类型，编译器所做的事情就像是有一个模板函数一样，</p>

<p>```
template <typename T>
void func_for_x(T param);           // conceptual template for deducing x&rsquo;s type</p>

<p>func_for_x(27);                     // conceptual call: param&rsquo;s deduced type is x&rsquo;s type</p>

<p>template <typename T>
void func_for_cx(const T param);    // conceptual template for deducing cx&rsquo;s type</p>

<p>func_for_cx(x);                     // conceptual call: param&rsquo;s deduced type is cx&rsquo;s type</p>

<p>template <typename T>
void func_for_rx(const T&amp; param);   // conceptual template for deducing rx&rsquo;s type</p>

<p>func_for_rx(x);                     // conceptual call: param&rsquo;s deduced type is rx&rsquo;s type
```</p>

<!-- more -->


<p>就像刚才说的一样，<code>auto</code> 的类型推导只有一点（一会儿会讲到）不一样之外，其他与模板类型推导完全一致。</p>

<p>Item 1 中根据 <code>ParamType</code> 的类型，把类型推导分了三种情况来处理，在 <code>auto</code> 类型推导时，<code>auto</code> 替代了 <code>ParamType</code>  也同样分为三种情况，</p>

<ul>
<li>情况1：类型标识符是一个指针或者引用，但不是右值引用</li>
<li>情况2：类型标识符是一个全局引用</li>
<li>情况3：类型标识符既不是指针也不是引用</li>
</ul>


<p>我们已经见过了情况1 与情况3 的例子了，</p>

<p>```
auto x = 27;           // case 3 (x is neither ptr nor reference)</p>

<p>const auto cx = x;     // case 3 (cx isn&rsquo;t neither)</p>

<p>const auto&amp; rx = x;    // case 1 (rx is a non-universal ref.)</p>

<p>```</p>

<p>情况2 就像你预期的那样，</p>

<p>```
auto&amp;&amp; uref1 = x;     // x is int lvalue, so uref1&rsquo;s type is int&amp;</p>

<p>auto&amp;&amp; uref2 = cx;    // cx is const int and lvalue, so uref2&rsquo;s type is const int&amp;</p>

<p>auto&amp;&amp; uref3 = 27;    // 27 is int and rvalue, so uref3&rsquo;s type is int&amp;&amp;
```</p>

<p>Item 1 中我们讨论了非引用的数组和函数是如何退化成指针的。在 <code>auto</code> 类型推导中也是一样的，</p>

<p>```
const char name[] = &ldquo;R. N. Briggs&rdquo;;    // name&rsquo;s type is const char[13]</p>

<p>auto arr1 = name;                      // arr1&rsquo;s type is const char *</p>

<p>auto&amp; arr2 = name;                     // arr2&rsquo;s type is const char (&amp;)[13]</p>

<p>void someFunc(int, double);            // someFunc is function, type is void(int, double)</p>

<p>auto func1 = someFunc;                 // func1&rsquo;s type is void(*)(int, double)</p>

<p>auto&amp; func2 = someFunc;                // func2&rsquo;s type is void(&amp;)(int, double)
```</p>

<p>就像你看到这样，<code>auto</code> 类型推导就像模板类型推导一样。</p>

<p>仅有一种情况，他们是不一样的。我们从一个简单的例子开始，在 C++98 中，我们用 27 来初始化一个 int 变量，我们可以有下面两种写法，</p>

<p><code>
int x1 = 27;
int x2(27);
</code></p>

<p>C++11 统一初始化，增加了下面的写法，</p>

<p><code>
int x3 = { 27 };
int x4{ 27 };
</code></p>

<p>总而言之，4中不同的写法的结果都是一样的，初始化了一个值为 27 的整型。</p>

<p>但是，就像 Item 5 中解释的一样，使用 <code>auto</code> 来声明类型是可以获得好处的，所有我们可以将上面的 <code>int</code> 全部替换为 <code>auto</code>：</p>

<p><code>
auto x1 = 27;
auto x2(27);
auto x3 = { 27 };
auto x4{ 27 };
</code></p>

<p>这 4 种写法都能够正常编译，但是却表达了不同的含义。前两种写法定义了一个值为 27 的整型。但后两种写法实际上定义了一个只有一个元素 27 的 <code>std::initializer_list&lt;int&gt;</code>！</p>

<p><code>
auto x1 = 27;        // type is int, value is 27
auto x2(27);         // ditto
auto x3 = { 27 };    // type is std::initializier_list&lt;int&gt;, value is { 27 }
auto x4{ 27 };       // ditto
</code></p>

<p>这是 <code>auto</code> 类型推导的一个特殊规则。当使用大括号初始化一个 <code>auto</code> 变量时，类型会被推导为 <code>std::initializer_list</code>，如果类型推导不成功（比如，大括号中的某个元素类型与其他的不一致），那么将会编译失败：</p>

<p><code>
auto x5 = { 1, 2, 3.0 };    // error! can't deduce T for std::initializer_list&lt;int&gt;
</code></p>

<p>就像上面注释中写的一样，类型推导在这种情况下会失败，但是要明白这里有两个类型推导，这是很重要的。第一个是 <code>auto</code>，<code>x5</code> 使用了大括号来初始化，那么 <code>auto</code> 会被推导为 <code>std::initializer_list</code> 类型，但同时 <code>std::initializer_list</code> 是一个模板类型，模板参数 <code>T</code> 同样需要推导，类型推导失败产生于第二步：模板类型推导。在上面的例子中，就是由于大括号中的元素类型不一致而导致的模板类型推导失败。</p>

<p><code>auto</code> 类型推导与模板类型推导的唯一不同在于大括号初始化。当使用大括号初始化时，<code>auto</code> 会推到为 <code>std::initializer_list</code> 类型，但对于模板类型推导来说，这会产生一个错误，</p>

<p>```
auto x = { 11, 23, 9 };  // x&rsquo;s type is std::initializer_list<int></p>

<p>template<typename T>
void f(T param);         // template with parameter declaration equivalent to x&rsquo;s</p>

<p>f({ 11, 23, 9});         // error! can&rsquo;t deduce type for T
```</p>

<p>不过，如果你明确指定了 <code>param</code> 的类型为 <code>std::initializer_list&lt;T&gt;</code> 那么模板类型推导会推导出 <code>T</code> 的类型，</p>

<p>```
template<typename T>
void f(std::initializer_list<T> initList);</p>

<p>f({ 11, 23, 9 });    // T deduce as int, and initList&rsquo;s type is std::initializer_list<int>
```</p>

<p>因此，<code>auto</code> 类型推导与模板类型推导唯一的不同在于，对于大括号初始化，<code>auto</code> 类型推导会将它推导为 <code>std::initializer_list</code>，而模板类型推导不会。</p>

<p>也许你会想知道为什么会有这样的区别。我也曾想过，但是没有找到一个很好的解释。不过规则就是规则，你只需要记住，当使用大括号初始化 <code>auto</code> 类型时，它会被自动推到为 <code>std::initializer_list</code> 类型。如果你想要使用新的统一初始化，那么记住这一点是非常重要的。一个典型的 C++11 错误就是当你想要一个其他类型时却意外的声明了一个 <code>std::initializer_list</code> 类型。这也是为什么有些开发者仅仅在必要的时候才使用大括号初始化的一个原因。（我们会在 Item 7 中详细讨论）</p>

<p>对 C++11 来说，这就是全部了。但是对于 C++14，还有些其他内容。C++14 允许使用 <code>auto</code> 来表示需要被推导的函数返回值类型（详见 Item 3），C++14 的 lambda 中也允许 <code>auto</code> 用作参数类型。但是这些 <code>auto</code> 遵循的是模板类型推导，而不是 <code>auto</code> 类型推导。因此，一个返回值类型声明为 <code>auto</code> 返回一个大括号初始化时，会导致编译失败，</p>

<p>```
auto createInitList()
{</p>

<pre><code>return { 1, 2, 3 };    // error: can't deduce type for { 1, 2, 3 }
</code></pre>

<p>}
```</p>

<p>lambda:</p>

<p>```
std::vector<int> v;
// &hellip;
auto resetV = <a href="const%20auto&amp;%20newValue">&amp;v</a> { v = newValue; };    // C++14
// &hellip;</p>

<p>resetV({ 1, 2, 3 });    // error! can&rsquo;t deduce type for { 1, 2, 3 }
```</p>

<h2>需要记住的</h2>

<ul>
<li><code>auto</code> 类型推导通常和模板类型推导是一致的，但是 <code>auto</code> 类型推导会将大括号初始化推到为 <code>std::initializer_list</code>，而模板类型推导不会</li>
<li><code>auto</code> 在函数返回值以及 lambda 参数类型推导时，遵循模板类型推导，而不是 <code>auto</code> 类型推导。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 1: Understand template type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/08/23/emcpp-item-1/"/>
    <updated>2014-08-23T00:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/08/23/emcpp-item-1</id>
    <content type="html"><![CDATA[<p>在使用一个复杂的系统时，我们可以不用知道具体的细节。从这个方面来说，C++ 的模板类型推导是很成功的。数以百万的程序员都使用过模板，即使他们可能很难描述清楚这些类型是如何推导的。</p>

<p>如果你是其中的一员，我有一个好消息，也有一个坏消息。好消息是，模板类型推导是最引人注目的 C++11 新特性 <code>auto</code> 的基础。如果你很清楚 C++98 中的模板类型推导，那么你会很容易明白 C++11 中的 <code>auto</code>。坏消息是，当使用 <code>auto</code> 时，有些类型推导会变得没有那么直观。因此完全掌握类型推导的规则是非常有必要的。Item 1 会介绍你必须知道的类型推导规则。</p>

<p>我们从一小段伪代码开始：</p>

<p><code>
template &lt;typename T&gt;
void f(ParamType param);
</code>
调用如下：
<code>
f (expr);    // call f with some expression
</code>
在编译期间，编译器使用表达式 <code>expr</code> 来推导两个类型：一个是 <code>T</code> 另一个是 <code>ParamType</code>。这两个类型通常是不一样的，因为 <code>ParamType</code> 通常是含有修饰的，比如 <code>const</code> 或者引用。举个例子，如果模板的声明如下：
<code>
template &lt;typename T&gt;
void f (const T&amp; param);    // ParamType is const T&amp;
</code>
然后调用如下：
<code>
int x = 0;
f(x);    // call f with an int
</code>
类型 <code>T</code> 会被推导为 <code>int</code>，而 <code>ParamType</code> 被推导为 <code>const int&amp;</code>。</p>

<p>将类型 <code>T</code> 推导为传入的参数类型是很自然的，即 <code>T</code> 的类型就是 <code>expr</code> 的类型。在上面的例子中，<code>x</code> 是 <code>int</code> 类型，<code>T</code> 被推导为 <code>int</code> 类型。但是有时候却不是这样的。类型推导不仅仅依赖于表达式 <code>expr</code> 的类型，同时还依赖于 <code>ParamType</code> 的形式。有下面三种情况：</p>

<ul>
<li>ParamType 是一个指针或者引用类型，但是不是全局引用。（全局引用将会在 Item 24 中讲述。现在你只需要知道他不同于引用，也不同于右值引用即可）。</li>
<li>ParamType 是一个全局引用。</li>
<li>ParamType 即不是指针也不是引用</li>
</ul>


<!-- more -->


<p>因此我们需要考虑上面描述的三种场景来一一讲述。每个都基于下面的伪代码，</p>

<p>```
template <typename T>
void f(ParamType param);</p>

<p>f(expr);    // deduce T and ParamType from expr
```</p>

<h3>情况1：<code>ParamType</code> 是一个指针或者引用，但不是右值引用</h3>

<p>这是最简单的一种情况，在这种情况下，类型推导的工作如下：</p>

<ol>
<li>如果 <code>expr</code> 是一个引用类型，忽略引用部分。</li>
<li>然后模式匹配 <code>expr</code> 的类型，根据 <code>ParamType</code> 的类型来决定 <code>T</code> 的类型。</li>
</ol>


<p>举个例子，如果我们的模板是下面这样，</p>

<p><code>
template &lt;typename T&gt;
void f(T&amp; param);    // param is a reference
</code></p>

<p>然后我们有如下的变量声明，</p>

<p><code>
int x = 27;           // x is an int
const int cx = x;     // cx is a const int
const int&amp; rx = x;    // rx is a reference to x as a const int
</code></p>

<p><code>param</code> 和 <code>T</code> 的类型推导结果如下，</p>

<p>```
f(x);     // T is int, param&rsquo;s type is int&amp;</p>

<p>f(cx);    // T is const int, param&rsquo;s type is const int&amp;</p>

<p>f(rx);    // T is const int, param&rsquo;s type is const int&amp;
```</p>

<p>在第二个以及第三个调用中，注意由于 <code>cx</code> 和 <code>rx</code> 是 <code>const</code> 值，所以 <code>T</code> 被推导为 <code>const int</code> 类型，这对调用者来说是至关重要的。当调用者传入一个 <code>const</code> 对象给一个引用参数时，参数仍然是不可更改的。比如，参数是一个 <code>const</code> 引用。这也是为什么传入一个 <code>const</code> 对象给一个接受 <code>T&amp;</code> 类型的模板参数是安全的：<code>const</code> 约束直接变为了 <code>T</code> 类型的一部分。</p>

<p>在第三个调用中，注意虽然 <code>rx</code> 的类型是引用，<code>T</code> 仍然被推导为非引用。这是由于类型推导过程中 <code>rx</code> 的引用修饰被忽略掉了。</p>

<p>上面的例子都是左值引用参数，但其实右值引用的类型推导和上面是完全一样的。当然，只有右值类型的参数才能传递给右值引用，但他对类型推导完全没有影响。</p>

<p>如果我们将 <code>f</code> 的参数类型由 <code>T&amp;</code> 更改为 <code>const T&amp;</code>，情况会有一些变化，但非常好理解。<code>cx</code> 和 <code>rx</code> 的 <code>const</code> 修饰仍然有用。但由于现在假定 <code>param</code> 的类型是一个 <code>const</code> 引用，现在不再需要将 <code>const</code> 推断为类型 <code>T</code> 的一部分了：</p>

<p>```
template <typename T>
void f(const T&amp; param);    // param is now ref-to-const</p>

<p>int x = 27;                // as before
const int cx = x;          // as before
const int&amp; rx = x;         // as before</p>

<p>f(x);                      // T is int, param&rsquo;s type is const int&amp;</p>

<p>f(cx);                     // T is int, param&rsquo;s type is const int&amp;</p>

<p>f(rx);                     // T is int, param&rsquo;s type is const int&amp;
```</p>

<p>和上面一样，<code>rx</code> 的引用修饰在类型推导时会被忽略。</p>

<p>如果 <code>param</code> 是一个指针（或者 <code>const</code> 指针），类型推导基本是一样的。</p>

<p>```
template <typename T>
void f(T* param);          // param is now a pointer</p>

<p>int x = 27;                // as before
const int *px = &x;        // px is a ptr to x as a const int</p>

<p>f(&amp;x);                     // T is int, param&rsquo;s type is int*</p>

<p>f(px);                     // T is const int, param&rsquo;s type is const int*
```</p>

<p>到目前位置，你可能已经哈欠不断了，因为对于指针和引用的类型推导，规则这么简单，所有的结果都是显而易见的，就和你想象的完全一样。</p>

<h3>情况2：<code>ParamType</code> 是全局引用</h3>

<p>当模版参数是全局引用时，类型推导就没有那么明显了。声明的形式有点像右值引用（全局引用的类型声明形式是 <code>T&amp;&amp;</code>），但是当传入的参数是左值类型时行为是不一样的。具体细节在 Item 24 中讲述，现在我们来看一个简单的版本：</p>

<ul>
<li>如果 <code>expr</code> 是一个左值，那么 <code>T</code> 和 <code>ParamType</code> 都会推导为左值引用。有两个不寻常的地方。第一，这是仅有的模板类型推导会将类型 <code>T</code> 推导为引用类型的情形。第二，尽管 <code>ParamType</code> 的类型声明使用了右值引用的符号，但却推导为了左值引用。</li>
<li>如果 <code>expr</code> 是一个右值，会使用“正常的”（情况1）规则。</li>
</ul>


<p>例子：</p>

<p>```
tempalte <typename T>
void f(T&amp;&amp; param);        // param is now a universal reference</p>

<p>int x = 27;               // as before
const int cx = x;         // as before
const int&amp; rx = x;        // as before</p>

<p>f(x);                     // x is lvalue, so T is int&amp;, param&rsquo;s type is also int&amp;</p>

<p>f(cx);                    // cx is lvalue, so T is const int&amp;, param&rsquo;s type is also const int&amp;</p>

<p>f(rx);                    // rx is lvalue, so T is const int&amp;, param&rsquo;s type is also const int&amp;</p>

<p>f(27);                    // 27 is rvalue, so T is int, param&rsquo;s type is therefore int&amp;&amp;
```</p>

<p>在 Item 24 中会详细解释为什么在上面的情形中类型推导是这样的。在这里我们的重点是，左值参数和右值参数对于全局引用来说，类型推导的规则是不一样的。这很特别的，当使用全局引用时，类型推导会区别对待左值参数和右值参数，这是在其他类型中不会发生的。</p>

<h3>情况3：<code>ParamType</code> 即不是引用也不是指针</h3>

<p>当 <code>ParamType</code> 既不是引用也不是指针时，我们来按值传递，</p>

<p><code>
template &lt;typename T&gt;
void f(T param);          // param is now passed by value
</code></p>

<p>这意味着 <code>param</code> 会做一个拷贝 —— 产生一个全新的对象。<code>param</code> 的类型推导遵循如下规则：</p>

<ol>
<li>像上面一样，如果 <code>expr</code> 的类型是一个引用，那么引用类型会被忽略。</li>
<li>如果忽略了 <code>expr</code> 的引用修饰之后，<code>expr</code> 是一个 <code>const</code>，那么将 <code>const</code> 也忽略。如果有 <code>volatile</code> 修饰，也同样忽略。（<code>volatile</code> 修饰并不常用，通常只是在实现设备驱动时会用到。更多细节，参见 Item 40）。</li>
</ol>


<p>```
int x = 27;              // as before
const int cx = x;        // as before
const int&amp; rx = x;       // as before</p>

<p>f(x);                    // T&rsquo;s and param&rsquo;s types are both int
f(cx);                   // T&rsquo;s and param&rsquo;s types are again both int
f(rx);                   // T&rsquo;s and param&rsquo;s types are still both int
```</p>

<p>注意，即使 <code>cx</code> 和 <code>rx</code> 都是 <code>const</code> 类型，<code>param</code> 的类型也不是 <code>const</code>。这是有道理的。<code>param</code> 是一个与 <code>cx</code> 和 <code>rx</code> 无关的对象 —— 是一份拷贝。因此， <code>cx</code> 和 <code>rx</code> 的 <code>const</code> 属性，不会影响 <code>param</code>。这就是为什么在类型推导过程中 <code>expr</code> 的 <code>const</code>（以及 volatile）修饰会被忽略的原因：<code>expr</code> 不可更改并不意味着它的拷贝不可以。</p>

<p>意识到 <code>const</code>（以及<code>volatile</code>）修饰仅仅在传值参数中会被忽略，是非常重要的。像前面看到的，对于 <code>const</code> 引用，或者 指向 <code>const</code> 对象的指针参数，<code>expr</code> 的 <code>const</code> 修饰是保留到类型推导中的。但是考虑以下情况，<code>expr</code> 是一个指向 <code>const</code> 对象的 <code>const</code> 指针，且 <code>expr</code> 是值传递给 <code>param</code> 的：</p>

<p>```
template <typename T>
void f(T param);                              // param is still passed by value</p>

<p>const char* const ptr = &ldquo;Fun with pointers&rdquo;;  // ptr is const pointer to const object</p>

<p>f(ptr);                                       // pass arg of type const char * const
```</p>

<p>在这里，右边（第二个）的 <code>const</code> 表示 <code>ptr</code> 不可更改。左边（第一个）表示 <code>ptr</code> 指向的常量字符串不可更改。当 <code>ptr</code> 传递给 <code>f</code> 时，<code>ptr</code> 值传递会产生一个拷贝，根据类型推导规则，<code>ptr</code> 的 <code>const</code> 修饰会被忽略掉，最终 <code>param</code> 类型为 <code>const char*</code>，即指向常量字符串的指针。<code>ptr</code> 所指向的内容的 <code>cosnt</code> 修饰被保留，而 <code>ptr</code> 本身的 <code>const</code> 修饰在值传递时被忽略。</p>

<h4>数组参数</h4>

<p>几乎所有主流的模板类型推导都包含它，但是还是有一些值得注意的地方。数组类型与指针类型是不同的，尽管他们有时可以转换。在很多时候数组是可以退化成指针的。下面的代码可以编译通过：</p>

<p>```
const char name[] = &ldquo;J. P. Briggs&rdquo;;   // name&rsquo;s type is const char[13]</p>

<p>const char* ptrToName = name;         // array decays to pointer
```</p>

<p>在这里，<code>ptrToName</code> 作为一个 <code>const char*</code> 类型，使用了 <code>const char[13]</code> 类型的 <code>name</code> 来初始化。但是这两个类型是不同的，由于数组到指针的退化规则才使得代码能够编译通过。</p>

<p>但当我们将一个数组类型传递给一个值传递的模版参数时，会发生什么呢？</p>

<p>```
template <typename T>
void f(T param);               // template with by-value paramter</p>

<p>f(name);                       // what types are deduced for T and param ?
```</p>

<p>我们使用没有模板的情况先来观察，对，没错，下面的语法是合法的，</p>

<p><code>
void myFunc(int param[]);
</code></p>

<p>但是数组参数的声明会被退化成指针，这意味着它和下面的声明是完全一致的：</p>

<p><code>
void myFunc(int* param);     // same function as above
</code></p>

<p>上面的退化是从 C 语言中继承而来的，他给我们造成了数组类型与指针类型是一样的这种幻觉。</p>

<p>由于数组参数的声明会被当作指针来看待，那么当模版参数是数组并且按值传递时，参数会被推导为指针类型。这意味着模板函数 <code>f</code> 的模板参数 <code>T</code> 会被推导为 <code>const char *</code>:</p>

<p><code>
f(name);        // name is array, but T deduced as const char*
</code></p>

<p>但是现在问题出现了，尽管参数不能是一个真正的数组类型，但是我们可以声明一个数组的引用。因此当我们更改模板函数 <code>f</code> 使他接受引用参数时，</p>

<p><code>
template &lt;typename T&gt;
void f(T&amp; param);        // template with by-reference parameter
</code></p>

<p>然后我们传入有一个数组，</p>

<p><code>
f(name);                 // pass array of f
</code></p>

<p>类型推导会将 <code>T</code> 推导为数组类型，这个类型包括了数组的长度，在这个例子中，<code>T</code> 的类型被推导成为 <code>const char[13]</code>，函数 <code>f</code> 的参数类型为 <code>const char(&amp;)[13]</code>。</p>

<p>有趣的是，它提供了一种推导数组元素个数的方式：</p>

<p>```
// return size of an array as a compile-time constant. (The array parameter has no name,
// because we care only about the number of elements it contains.)</p>

<p>template <typename T>                                // info
constexpr std::size_t arraySize(T(&amp;)[N]) noexcept    // below on
{                                                    // constexpr</p>

<pre><code>return N;                                        // and
</code></pre>

<p>}                                                    // noexcept
```</p>

<p>与 Item 15 中解释的一样，声明一个 <code>constexpr</code> 函数，那么它的返回值在编译期就确定了。这就让用一个已知的数组去声明一个同样大小的数组成为可能：</p>

<p>```
int keyVals[] = { 1, 3, 5, 7, 9, 11, 22, 35 };    // keyVals has 7 elements</p>

<p>int mappedVals[arraySize(keyVals)];               // so does mappedVals
<code>``
当然，作为一个现代的 C++ 程序员，你会很自然的习惯于用</code>std::array` 来代替内建的数组类型，</p>

<p><code>
std::array&lt;int, arraySize(keyVals)&gt; mappedVals;   // mappedVals' size is 7
</code></p>

<p><code>arraySize</code> 声明时带着 <code>noexcept</code>，这帮助编译器生成更好的代码。详细内容，参见 Item 14。</p>

<h4>函数参数</h4>

<p>在 C++ 中，不是只有数组才会退化成指针。函数类型可以退化成函数指针，上面我们讨论的关于数组的类型推导规则也适用于函数，只是退化成函数指针而已。</p>

<p>```
void someFunc(int, double);    // someFunc is a function;</p>

<pre><code>                           // type is void(int, double)
</code></pre>

<p>template<typename T>
void f1(T param);              // in f1, param passed by value</p>

<p>template<typename T>
void f2(T&amp; param);             // in f2, param passed by ref</p>

<p>f1(someFunc);                  // param deduced as ptr-to-func;</p>

<pre><code>                           // type is void (*)(int, double)
</code></pre>

<p>f2(someFunc);                  // param deduced as ref-to-func;</p>

<pre><code>                           // type is void (&amp;)(int, double)
</code></pre>

<p>```</p>

<p>在日常的使用中，这几乎没有什么区别，但是如果你已经知道了数组会退化成指针，那么你也会很自然的知道函数到指针的退化。</p>

<p>这就是模板类型推导的规则。大部分情况下它非常简单。左值在传递给全局引用时的推导有些稍微不同，但是数组和函数类型的退化更让人迷惑。有时候你会想抓住编译器问，“告诉我你在推导什么类型！” 这个时候，你需要 Item 4 中的内容，它会告诉你如何查看正在推导的类型。</p>

<h2>需要记住的</h2>

<ul>
<li>在模板类型推导时，引用类型的参数会被当作非引用，即引用限定会被忽略。</li>
<li>当推导类型是全局引用时，左值会被特殊对待。</li>
<li>当推导值传递参数时，<code>const</code>, <code>volatile</code> 会被忽略。</li>
<li>在类型推导时，数组以及函数名会退化为指针，除非它们被用来初始化引用变量。</li>
</ul>

]]></content>
  </entry>
  
</feed>
