<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Bitdewy]]></title>
  <link href="http://bitdewy.github.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2013-11-11T13:17:36+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[返回值类型推导]]></title>
    <link href="http://bitdewy.github.com/blog/2013/11/11/return-type-resolver/"/>
    <updated>2013-11-11T10:21:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/11/11/return-type-resolver</id>
    <content type="html"><![CDATA[<p>模版函数的参数类型可以自动推导, 它可以让我们在调用函数的时候不必写丑陋的<code>&lt;&gt;</code>, 但如果是返回值类型需要自动推导, 似乎就没有那么容易了. 虽然语言本身不支持返回值的类型自动推导, 但我们可以尝试其他的办法来完成这项任务.</p>

<h2>目的</h2>

<p>在使用函数返回值初始化变量或给变量赋值时模版函数能够自动推导出类型.</p>

<h2>例子</h2>

<p>在某些情况下, 明确被初始化的变量类型是有用的. 考虑下面的例子, 我们使用随机数来初始化 STL 容器. 但是我们不知道用户会选择哪个具体的容器类型. 它可能是 <code>std::list</code>, <code>std::vector</code> 或者其他的行为像 STL 容器的自定义类型. 最直接的方法如下所示:</p>

<p>```cpp</p>

<h1>include <list></h1>

<h1>include <vector></h1>

<h1>include <random></h1>

<p>template <class Container>
Container GetRandomN(size_t n) {
  Container c;
  for(size_t i = 0; i &lt; n; ++i) {</p>

<pre><code>c.insert(c.end(), rand());
</code></pre>

<p>  }
  return c;
}</p>

<p>int main () {
  std::list<int> l = GetRandomN&lt;std::list<int> >(10);
  std::vector<long> v = GetRandomN&lt;std::vector<long> >(100);
  return 0;
}
```</p>

<!-- more -->


<p>我们可以注意到, 代码中必须显示的指定返回值的类型, 很显然我们必须写两次返回值类型, 类型声明写一次, 函数调用又写了一次. 返回值类型推导可以帮助我们解决这个问题, 当然 C++11 中的 auto 类型也可以解决.</p>

<h2>解决方案 &amp; 示例代码</h2>

<p>```cpp</p>

<h1>include <list></h1>

<h1>include <set></h1>

<h1>include <vector></h1>

<h1>include <random></h1>

<p>class GetRandomN {
 public:
  GetRandomN(int n = 1) : count(n) {}</p>

<p>  template <class Container>
  operator Container() {</p>

<pre><code>Container c;
for (size_t i = 0; i &lt; count; ++i) {
  c.insert(c.end(), rand()); // push_back is not supported by all standard containers.
}
return c;
</code></pre>

<p>  }
 private:
  size_t count;
};</p>

<p>int main() {
  std::set<int> random_s = GetRandomN(10);
  std::vector<int> random_v = GetRandomN(10);
  std::list<int> random_l = GetRandomN(10);
  return 0;
}
```</p>

<p>类 GetRandomN 有一个构造函数, 以及一个模版的类型隐式转换函数. 初始化的时候, 会产生一个 GetRandomN 类的临时对象, 当赋值给 STL 容器类型时, 编译器会去尝试将对象隐式转换. 而隐式转换的途径就是取寻找隐式转换函数, 这样就完成了返回值自动推导. 有了返回值类型自动推导, 我们就不必手写返回值类型参数了. 唔… 再注意一点, 为了支持 <code>std::set</code> 我们将原始的 <code>push_back</code> 函数改为了 <code>insert</code>.</p>

<p><em>注: 在 C++11 引入 <code>nullptr</code> 之前, 手工实现一个 <code>nullptr</code> 的惯用法就使用了返回值类型推导.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11中的原子操作 (atomic operation)]]></title>
    <link href="http://bitdewy.github.com/blog/2013/09/02/atomic-operation/"/>
    <updated>2013-09-02T23:34:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/09/02/atomic-operation</id>
    <content type="html"><![CDATA[<p>所谓的原子操作, 取的就是 “原子是最小的, 不可分割的最小个体” 的意义, 它表示在多个线程访问同一个全局资源的时候, 能够确保所有其他的线程都不在同一时间内访问相同的资源. 也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问. 这有点类似互斥对象对共享资源的访问的保护, 但是原子操作更加接近底层, 因而效率更高.</p>

<p>在以往的 C++ 标准中并没有对原子操作进行规定, 我们往往是使用汇编语言, 或者是借助第三方的线程库, 例如 intel 的 pthread 来实现. 在新标准 C++11, 引入了原子操作的概念, 并通过这个新的头文件提供了多种原子操作数据类型, 例如, atomic_bool, atomic_int 等等, 如果我们在多个线程中对这些类型的共享资源进行操作, 编译器将保证这些操作都是原子性的, 也就是说, 确保任意时刻只有一个线程对这个资源进行访问, 编译器将保证, 多个线程访问这个共享资源的正确性. 从而避免了锁的使用, 提高了效率.</p>

<p>我们还是来看一个实际的例子. 假若我们要设计一个广告点击统计程序, 在服务器程序中, 使用多个线程模拟多个用户对广告的点击:</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include <thread></h1>

<h1>include &lt;time.h></h1>

<p>// 全局的结果数据
long total = 0;
// 点击函数
void click()
{
  for(int i = 0; i &lt; 10000; ++i) {</p>

<pre><code>// 对全局数据进行无锁访问
total += 1;
</code></pre>

<p>  }
}</p>

<p>int main(int argc, char* argv[])
{
  // 计时开始
  clock_t start = clock();
  // 创建100个线程模拟点击统计
  std::thread threads[100];
  for(int i = 0; i &lt; 100; ++i) {</p>

<pre><code>std::thread t(&amp;click);
threads[i].swap(t);
</code></pre>

<p>  }
  for(int i=0; i&lt;100; ++i) {</p>

<pre><code>threads[i].join();
</code></pre>

<p>  }
  // 计时结束
  clock_t finish = clock();
  // 输出结果
  std::cout &lt;&lt; &ldquo;result:&rdquo; &lt;&lt; total &lt;&lt; std::endl;
  std::cout &lt;&lt; &ldquo;duration:&rdquo; &lt;&lt; finish -start &lt;&lt; &ldquo;ms&rdquo; &lt;&lt; std::endl;
  return 0;
}
```</p>

<!-- more -->


<p>执行结果如下:</p>

<blockquote><p>result: 955700</p>

<p>duration: 49ms</p></blockquote>

<p>从执行的结果来看, 这样的方法虽然非常快, 但是结果不正确.</p>

<p>很自然地, 我们会想到使用互斥对象来对全局共享资源的访问进行保护, 于是有了下面的实现:</p>

<p>```cpp
///
std::mutex m;
// 点击函数
void click()
{
  for(int i = 0; i &lt; 10000; ++i) {</p>

<pre><code>// 对全局数据进行无锁访问
std::unique_lock&lt;std::mutex&gt; lk(m);
total += 1;
</code></pre>

<p>  }
}
///
```</p>

<p>运行结果如下:</p>

<blockquote><p>result: 1000000</p>

<p>duration: 32350ms</p></blockquote>

<p>互斥对象的使用, 保证了同一时刻只有唯一的一个线程对这个共享进行访问, 从执行的结果来看, 互斥对象保证了结果的正确性, 但是也有非常大的性能损失, 从刚才的 49ms 变成了现在的 32350ms. 这 TMD 差距也太大了.(感觉有些异常，差距没理由这么大的, 可能是线程太多, CPU 光忙着线程切换了 = =!)</p>

<p>如果是在 C++11 之前, 我们的解决方案也就到此为止了. 但是, C++ 对性能的追求是永无止境的, 他总是想尽一切办法榨干 CPU 的性能. 在 C++11 中, 实现了原子操作的数据类型 (atomic_bool, atomic_int, atomic_long 等等), 对于这些原子数据类型的共享资源的访问, 无需借助 mutex 等锁机制, 也能够实现对共享资源的正确访问.</p>

<p>将原本的 long 类型改为 std::atomic_long 类型即可</p>

<p>```cpp
//long total = 0;</p>

<p>std::atomic_long total;
```</p>

<p>运行结果如下:</p>

<blockquote><p>result: 1000000</p>

<p>duration: 117ms</p></blockquote>

<p>结果正确, 时间上仅仅是不采用任何保护机制时的 3 倍左右, 和使用 mutex 做同步的版本不知差了几个数量级了.</p>

<p>原子操作的实现跟普通数据类型类似, 但是它能够在保证结果正确的前提下, 提供比 mutex 等锁机制更好的性能, 如果我们要访问的共享资源可以用原子数据类型表示, 那么在多线程程序中使用这种新的等价数据类型, 是一个不错的选择.</p>

<p>但值得注意的是, <code>std::atomic</code> 只能作用于基本类型以及 POD 类型上.</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/atomic/atomic">CppReference.com &ndash; atomic</a></li>
<li><a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2">C++ and Beyond 2012: Herb Sutter &ndash; atomic&lt;> Weapons</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型选择]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/30/type-selection/"/>
    <updated>2013-07-30T18:26:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/30/type-selection</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>在编译期间, 根据一些条件, 决定类型.</p>

<h2>动机</h2>

<p>在编译期根据一些信息来做出决议是元编程的一个强大工具. 其中一种就是在编译期决定类型, 比如根据一些列的条件最后决定具体的类型.</p>

<p>例如, 考虑一个 Queue 的实现, 这个模板类有一个静态数组, 模板参数作为这个 Queue 类型的最大容量. Queue 类同时需要存储当前元素的个数, 从 0 开始. 可能的优化方案是用不同的类型, 来存储 size 值. 比如当 Queue 的最大容量小于 256 时, 存储容量的类型是 unsigned char, 当容量小于 65536 时, 存储容量的类型是 unsigned short, 更大的容量时使用 unsigned int 类型. 类型选择可以在这个时候发挥作用.</p>

<h2>解决方案以及代码示例</h2>

<p>一个简单的解决方案是使用 IF 模板. IF 模板有三个模板参数, 第一个参数是编译期的 bool 表达式. 如果表达式为 true 那么第二个模板参数类型将被选中, 否则会选中第三个模板参数. IF 模板由下面的一个模板和一个模板偏特化构成.</p>

<p><code>cpp
template &lt;bool, class L, class R&gt;
struct IF  // primary template
{
  typedef R type;
};
template &lt;class L, class R&gt;
struct IF&lt;true, L, R&gt; // partial specialization
{
  typedef L type;
};
IF&lt;false, int, long&gt;::type i; // is equivalent to long i;
IF&lt;true,  int, long&gt;::type i; // is equivalent to int i;
</code></p>

<!-- more -->


<p>下面就是使用类型选择实现的 Queue 类:</p>

<p>```cpp
template <class T, unsigned int CAPACITY>
class Queue
{
  T array[CAPACITY];
  typename IF&lt;(CAPACITY &lt;= 256),</p>

<pre><code>  unsigned char,
  typename IF&lt;(CAPACITY &lt;= 65536),
              unsigned short,
              unsigned int
             &gt;::type
&gt;::type size;
</code></pre>

<p>  // &hellip;
};
```</p>

<p>模板类 Queue 声明了一个类型为 T 的数组, 数据成员 size 的类型由两个 IF 模板的结果来决定. 注意, 这些比较不是在运行时而是在编译期.</p>

<h2>已知的应用</h2>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_54_0/libs/mpl/doc/index.html">Boost.MPL Library</a></li>
</ul>


<h2>参考</h2>

<ul>
<li>《Modern C++ design》(2.6 型别选择 (type selection)) Andrei Alexandrescu</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 condition variable 实现生产者 消费者模型]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/22/resolve-producer-consumer-problem-with-cond/"/>
    <updated>2013-07-22T00:05:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/22/resolve-producer-consumer-problem-with-cond</id>
    <content type="html"><![CDATA[<h2>什么是生产者-消费者问题?</h2>

<p>生产者消费者问题 (英语: Producer-consumer problem), 也称有限缓冲问题 (英语: Bounded-buffer problem), 是一个多线程同步问题的经典案例. 该问题描述了两个共享固定大小缓冲区的线程 —— 即所谓的 “生产者” 和 “消费者” —— 在实际运行时会发生的问题. 生产者的主要作用是生成一定量的数据放到缓冲区中, 然后重复此过程. 与此同时, 消费者也在缓冲区消耗这些数据. 该问题的关键就是要保证生产者不会在缓冲区满时加入数据, 消费者也不会在缓冲区中空时消耗数据.</p>

<p>要解决该问题, 就必须让生产者在缓冲区满时休眠 (要么干脆就放弃数据), 等到下次消费者消耗缓冲区中的数据的时候, 生产者才能被唤醒, 开始往缓冲区添加数据. 同样, 也可以让消费者在缓冲区空时进入休眠, 等到生产者往缓冲区添加数据之后, 再唤醒消费者. 通常采用进程间通信的方法解决该问题, 常用的方法有信号量等. 如果解决方法不够完善, 则容易出现死锁的情况. 出现死锁时, 两个线程都会陷入休眠, 等待对方唤醒自己. 该问题也能被推广到多个生产者和消费者的情形.</p>

<!-- more -->


<h2>使用 condition variable 实现生产者-消费者模型</h2>

<p>```cpp</p>

<h1>include &lt;condition_variable></h1>

<h1>include <future></h1>

<h1>include <iostream></h1>

<h1>include <mutex></h1>

<h1>include <sstream></h1>

<h1>include <vector></h1>

<p>std::mutex buffer_mutex;
std::condition_variable buffer_not_empty;
std::condition_variable buffer_not_full;</p>

<p>std::vector<int> buffer;</p>

<p>const std::size_t kBufferMaxSize = 20;</p>

<p>void print(std::ostream&amp;&amp; s)
{
  std::cout &lt;&lt; s.rdbuf(); std::cout.flush(); s.clear();
}</p>

<p>void send(int i)
{
  std::unique_lock&lt;std::mutex> lk(buffer_mutex);
  buffer_not_full.wait(lk, [&amp;]{ return buffer.size() &lt; kBufferMaxSize; });
  buffer.push_back(i);
  print(std::stringstream() &lt;&lt; &ldquo;produce: &rdquo; &lt;&lt; i &lt;&lt; &ldquo;\n&rdquo;);
  buffer_not_empty.notify_all();
}</p>

<p>void receive()
{
  std::unique_lock&lt;std::mutex> lk(buffer_mutex);
  buffer_not_empty.wait(lk, [&amp;]{ return !buffer.empty(); });
  int i = buffer.back();
  buffer.pop_back();
  print(std::stringstream() &lt;&lt; &ldquo;consume: &rdquo; &lt;&lt; i &lt;&lt; &ldquo;\n&rdquo;);
  buffer_not_full.notify_all();
}</p>

<p>int main(int argc, char* argv[])
{
  auto future_producer = std::async(std::launch::async, []{</p>

<pre><code>for (int i = 0;; ++i) {
  send(i);
}
</code></pre>

<p>  });
  auto future_consumer = std::async(std::launch::async, []{</p>

<pre><code>while (true) {
  receive();
}
</code></pre>

<p>  });
  future_producer.wait();
  future_consumer.wait();
  return 0;
}
```</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">wikipedia: Producer–consumer problem</a></li>
<li><a href="http://en.cppreference.com/w/cpp/thread/condition_variable">cppreference.com: std::condition_variable</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 完美转发]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/08/cpp11-perfect-forward/"/>
    <updated>2013-07-08T22:09:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/08/cpp11-perfect-forward</id>
    <content type="html"><![CDATA[<h2>动机</h2>

<p>在泛型编码中经常出现的一个问题是: 如何将一组参数原封不动的转发给另一个函数? 这里的原封不动指的是: 保持参数的左值 (右值), const (non-const) 属性不变.</p>

<h2>C++03 中参数转发存在的问题</h2>

<p>下面来看一个例子, 对于表达式 <code>E(a, b, …, c)</code> 我们希望它与 <code>f(a, b, …, c)</code> 完全等价. 在 C++03 中这是不可能的. 下面是几种设计方案, 但所有的都会在某些条件下失效.</p>

<p>最简单的, 使用引用参数:</p>

<p>```cpp
template <typename A, typename B, typename C>
void f(A&amp; a, B&amp; b, C&amp; c) {</p>

<pre><code>E(a, b, c);
</code></pre>

<p>}
```</p>

<p>很遗憾, 函数 f 无法处理临时变量, 例如 <code>f(1, 2, 3)</code>; 会编译失败. 这三个参数都无法绑定到引用.</p>

<p>再来看看 const 引用:</p>

<p>```cpp
template <typename A, typename B, typename C>
void f(const A&amp; a, const B&amp; b, const C&amp; c) {</p>

<pre><code>E(a, b, c);
</code></pre>

<p>}
```</p>

<!-- more -->


<p>这解决了上面的问题, 但是又引入了新的问题, 现在我们无法让 E 接收 non-const 参数了, 下面的代码也会产生一个编译失败.</p>

<p><code>cpp
int i = 1, j = 2, k = 3;
void E(int&amp;, int&amp;, int&amp;);
f(i, j, k); // oops! E cannot modify these
</code></p>

<p>嗯, 再来个尝试, 解决上面的问题, 我们接收 const 引用, 然后使用 const_cast 来去掉 const 属性.</p>

<p>```cpp
template <typename A, typename B, typename C>
void f(const A&amp; a, const B&amp; b, const C&amp; c) {</p>

<pre><code>E(const_cast&lt;A&amp;&gt;(a), const_cast&lt;B&amp;&gt;(b), const_cast&lt;C&amp;&gt;(c));
</code></pre>

<p>}
```</p>

<p>最后来终极解决方案吧, 利用重载, 根据重载决议, 我们可以使用 const 引用和 non-const 引用来进行参数重载, 对于上面的例子, 我们的实现如下:</p>

<p>```cpp
template <typename A, typename B, typename C>
void f(A&amp; a, B&amp; b, C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(const A&amp; a, B&amp; b, C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(A&amp; a, const B&amp; b, C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(A&amp; a, B&amp; b, const C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(const A&amp; a, const B&amp; b, C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(const A&amp; a, B&amp; b, const C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(A&amp; a, const B&amp; b, const C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(const A&amp; a, const B&amp; b, const C&amp; c);
```</p>

<p>n 个参数的函数, 就需要 2<sup>n</sup> 个重载版本, 这太恐怖了, 我们非常需要自动完成这些工作. 这个问题在 C++11 中的到了完美的解决.</p>

<h2>完美转发</h2>

<p>C++11 新标准给了我们修复这个问题的机会 (这里有一个破坏性的解决方案, 虽然解决了完美转发的问题, 但是破坏了现有的类型推导规则<a href="http://stackoverflow.com/questions/3591832/perfect-forwarding-in-c03/3591909#3591909">《Perfect Forwarding in C++03》</a>).</p>

<p>C++11 中引入了新的概念, 右值引用. 我们可以在不破坏现有代码的情况下, 定义右值引用的推导规则, 来解决完美转发的问题.</p>

<p>看下面的表格, (TR 表示 T 引用类型)</p>

<p>```cpp
TR   R</p>

<p>T&amp;   &amp;  &ndash;> T&amp;  // lvalue reference to cv TR &ndash;> lvalue reference to T
T&amp;   &amp;&amp; &ndash;> T&amp;  // rvalue reference to cv TR &ndash;> TR (lvalue reference to T)
T&amp;&amp;  &amp;  &ndash;> T&amp;  // lvalue reference to cv TR &ndash;> lvalue reference to T
T&amp;&amp;  &amp;&amp; &ndash;> T&amp;&amp; // rvalue reference to cv TR &ndash;> TR (rvalue reference to T)
```</p>

<p>然后, 模板参数推导时, 如果参数是左值, 那么就推导为左值引用. 否则使用正常的类型推导. 这里又引入了一个新的概念, “全局引用” (universal references), 具体细节详见: <a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11">C++ and Beyond 2012: Scott Meyers &ndash; Universal References in C++11</a></p>

<p>为什么这样就能解决问题? 因为我们保持了参数的类型: 如果参数是一个左值, 我们得到的是左值引用的参数, 否则我们得到的是右值引用类型的参数, 看下面的代码:</p>

<p>```cpp
template <typename T>void deduce(T&amp;&amp; x);</p>

<p>int i;
deduce(i); // deduce&lt;int&amp;>(int&amp; &amp;&amp;) &ndash;> deduce&lt;int&amp;>(int&amp;)
deduce(1); // deduce<int>(int&amp;&amp;)
```</p>

<p>最后就是要做“转发”了. 需要注意的是, 在函数内参数类型是一个左值类型.</p>

<p>```cpp
void foo(int&amp;);</p>

<p>template <typename T>
void deduce(T&amp;&amp; x){</p>

<pre><code>foo(x); // fine, foo can refer to x
</code></pre>

<p>}</p>

<p>deduce(1); // okay, foo operates on x which has a value of 1
```</p>

<p>这还不足够. foo 需要拿到和 deduce 一样的参数类型, 解决方案如下.</p>

<p><code>cpp
static_cast&lt;T&amp;&amp;&gt;(x);
</code></p>

<p>上面这行代码做了什么呢? 我们在 deduce 函数中, 且我们接收了一个左值类型的参数, 这意味着 T 是 A&amp; 类型, 经过静态类型转换 A&amp; &amp;&amp; 仍然是 A&amp; 类型. 因此, 加入 x 以及是一个 A&amp; 类型, 那么我们什么也没有做, 它仍然是一个左值引用类型.</p>

<p>当我们接收的是一个右值, T 就是 A 类型, 因此我们转换后的类型为 A&amp;&amp;. 转换后的类型是一个右值表达式, 这样就不会再作为左值参数了. 我们保持住了参数的类型. 将上面的组合到一起, 我们就得到了“完美转发”:</p>

<p>```cpp
template <typename A>
void f(A&amp;&amp; a) {</p>

<pre><code>E(static_cast&lt;A&amp;&amp;&gt;(a));
</code></pre>

<p>}
```</p>

<p>当 f 接收到一个左值, 那么 E 也接收一个左值, 当 f 接收的是一个右值, 那么 E 接受到的也是一个右值, 完美了.</p>

<p>当然, 上面的代码是有一点丑陋. <code>static_cast&lt;T&amp;&amp;&gt;</code> 古怪而且不容易记住. 标准库中提供了一个工具函数, 叫做 forward, 它所做的事情与类型转换完全一致.</p>

<p><code>cpp
std::forward&lt;A&gt;(a);
// is the same as
static_cast&lt;A&amp;&amp;&gt;(a);
</code></p>

<h2>参考</h2>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">C++标准提案(N1385)：The Forwarding Problem: Arguments</a></li>
<li><a href="http://blog.csdn.net/pongba/article/details/1697636">《C++0x漫谈》系列之：右值引用(或“move语意与完美转发”)(下)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
