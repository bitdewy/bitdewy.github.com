<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Bitdewy]]></title>
  <link href="http://bitdewy.github.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2014-01-13T02:03:48+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[why make_shared ?]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/12/why-make-shared/"/>
    <updated>2014-01-12T21:01:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/12/why-make-shared</id>
    <content type="html"><![CDATA[<p>C++11 中引入了智能指针, 同时还有一个模板函数 <code>std::make_shared</code> 可以返回一个指定类型的 <code>std::shared_ptr</code>, 那与 <code>std::shared_ptr</code> 的构造函数相比它能给我们带来什么好处呢 ?</p>

<h2>优点</h2>

<h3>效率更高</h3>

<p><code>shared_ptr</code> 需要维护引用计数的信息,</p>

<ul>
<li>强引用, 用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放).</li>
<li>弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话).</li>
</ul>


<p>如果你通过使用原始的 new 表达式分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块:</p>

<p><code>cpp
auto p = new widget();
shared_ptr sp1{ p }, sp2{ sp1 };
</code>
<img src="http://y6bhba.bay.livefilestore.com/y1pDu8kORu85CKSKHFVBvapxrccVoMAjc8W0d6mScWwunuhqV8n25QZKgZhM6MPtFGV1c6dPgjil7g/sharedptr1.png" alt="" /></p>

<p>如果选择使用 <code>make_shared</code> 的话, 情况就会变成下面这样:</p>

<!-- more -->


<p><code>cpp
auto sp1 = make_shared(), sp2{ sp1 };
</code></p>

<p><img src="http://y6yska.bay.livefilestore.com/y1p-Y0XAkcMZMrSdxkTa85nShcDkVKvqhMTFVGSDc0jURLybPXTGHPdWv9CZGgcGmvZwQQvd6Y1Qdg/sharedptr2.png" alt="" /></p>

<p>内存分配的动作, 可以一次性完成. 这减少了内存分配的次数, 而内存分配是代价很高的操作.</p>

<p>关于两种方式的性能测试可以看这里 <a href="http://tech-foo.blogspot.hk/2012/04/experimenting-with-c-stdmakeshared.html">Experimenting with C++ std::make_shared</a></p>

<h3>异常安全</h3>

<p>看看下面的代码:
```cpp
void F(const std::shared_ptr<Lhs>&amp; lhs, const std::shared_ptr<Rhs>&amp; rhs) { /<em> &hellip; </em>/ }</p>

<p>F(std::shared_ptr<Lhs>(new Lhs(&ldquo;foo&rdquo;)),
  std::shared_ptr<Rhs>(new Rhs(&ldquo;bar&rdquo;)));
```</p>

<p>C++ 是不保证参数求值顺序, 以及内部表达式的求值顺序的, 所以可能的执行顺序如下:</p>

<ol>
<li>new Lhs(&ldquo;foo&rdquo;))</li>
<li>new Rhs(&ldquo;bar&rdquo;))</li>
<li>std::shared_ptr<Lhs></li>
<li>std::shared_ptr<Rhs></li>
</ol>


<p>好了, 现在我们假设在第 2 步的时候, 抛出了一个异常 (比如 out of memory, 总之, Rhs 的构造函数异常了), 那么第一步申请的 Lhs 对象内存泄露了. 这个问题的核心在于, shared_ptr 没有立即获得裸指针.</p>

<p>我们可以用如下方式来修复这个问题.</p>

<p><code>cpp
auto lhs = std::shared_ptr&lt;Lhs&gt;(new Lhs("foo"));
auto rhs = std::shared_ptr&lt;Rhs&gt;(new Rhs("bar"));
F(lhs, rhs);
</code></p>

<p>当然, 推荐的做法是使用 <code>std::make_shared</code> 来代替:</p>

<p><code>cpp
F(std::make_shared&lt;Lhs&gt;("foo"), std::make_shared&lt;Rhs&gt;("bar"));
</code></p>

<h2>缺点</h2>

<h3>构造函数是保护或私有时,无法使用 make_shared</h3>

<p><code>make_shared</code> 虽好, 但也存在一些问题, 比如, 当我想要创建的对象没有公有的构造函数时, <code>make_shared</code> 就无法使用了, 当然我们可以使用一些小技巧来解决这个问题, 比如这里 <a href="http://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const?rq=1">How do I call ::std::make_shared on a class with only protected or private constructors?</a></p>

<h3>对象的内存可能无法及时回收</h3>

<p><code>make_shared</code> 只分配一次内存, 这看起来很好. 减少了内存分配的开销. 问题来了, <code>weak_ptr</code> 会保持控制块(强引用, 以及弱引用的信息)的生命周期, 而因此连带着保持了对象分配的内存, 只有最后一个 <code>weak_ptr</code> 离开作用域时, 内存才会被释放. 原本强引用减为 0 时就可以释放的内存, 现在变为了强引用, 若引用都减为 0 时才能释放, 意外的延迟了内存释放的时间. 这对于内存要求高的场景来说, 是一个需要注意的问题. 关于这个问题可以看这里 <a href="http://lanzkron.wordpress.com/2012/04/22/make_shared-almost-a-silver-bullet/">make_shared, almost a silver bullet</a></p>

<h2>参考</h2>

<ul>
<li><a href="http://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/">GotW #89 Solution: Smart Pointers</a></li>
<li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">cppreference.com &ndash; std::make_shared</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当 Windows API 遇上 RAII]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/06/windows-api-raii/"/>
    <updated>2014-01-06T00:18:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/06/windows-api-raii</id>
    <content type="html"><![CDATA[<h2>什么是 RAII (Resource Acquisition Is Initialization) ?</h2>

<p>RAII (Resource Acquisition Is Initialization), 也称为"资源获取就是初始化", 是 C++ 语言的一种管理资源, 避免泄漏的惯用法. C++ 标准保证任何情况下, 已构造的对象最终会销毁, 即它的析构函数最终会被调用. 简单的说, RAII 的做法是使用一个对象, 在其构造时获取资源, 在对象生命期控制对资源的访问使之始终保持有效, 最后在对象析构的时候释放资源.</p>

<p>RAII 是保证代码异常安全的重要基础设施. RAII 的使用场景有很多, 如: C++11 中的智能指针, scope lock, scope exit 等等. (早在2000年，<a href="http://erdani.com/">Andrei Alexandrescu</a> 就在DDJ杂志上发表了一篇文章，提出了这个叫做 <a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758">ScopeGuard</a> 的设施)</p>

<h2>当 Windows API 遇上 RAII</h2>

<p>Windows API 大多是 C 语言风格的函数和句柄, 或者是 COM 风格的接口, 这些用起来都不太方便, 需要进行一定的封装. 至于为什么要封装就不用多说了, 如果你想要异常安全, 想要不必在每个分支中都写清理代码的话, 你一定知道利用 RAII 封装的意义.</p>

<p>ATL 中有对 COM 接口的封装, 智能指针 <code>CComPtr</code>, <code>CComQIPtr</code> 解决了一遍遍的手工 <code>Release</code> 以及 <code>QueryInterface</code>. 但对于普通的 C 语言风格的函数和句柄呢? 难道还要一遍遍的 <code>CloseHandle</code> , <code>ReleaseDC</code>, <code>GlobalUnlock</code> 麽? 弱爆了.</p>

<p>借助 <code>ScopeGuard</code> 和 lambda 表达式(⊙_⊙)？ 可以是可以, 但是并不是所有的资源获取都会成功, 那么每次都要产生一个具名的 <code>ScopeGuard</code>, 在申请失败的时候调用 <code>Dismiss</code>, 取消清理的动作嘛? 像这样:</p>

<p>```cpp
Acquire Resource1
ScopeGuard release1([&amp;] { /<em> Release Resource1 </em>/ })
if (!Resource1) {</p>

<pre><code>release1.Dismiss();
// throw exception or return or...
</code></pre>

<p>}</p>

<p>Acquire Resource2
ScopeGuard release2([&amp;] { /<em> Release Resource2 </em>/ })
if (!Resource2) {</p>

<pre><code>release2.Dismiss();
// throw exception or return or...
</code></pre>

<p>}
```</p>

<!-- more -->


<p>这样如果连续申请多个资源 <code>ScopeGuard</code> 对象命名都会成为问题. 又或者是先判断资源是否申请成功, 然后再使用匿名的 <code>ScopeGuard</code> 来保证正确释放资源? 像这样:</p>

<p>```cpp
Acquire Resource1
if (!Resource1) {</p>

<pre><code>// throw exception or return or...
</code></pre>

<p>}
ON_SCOPE_EXIT([&amp;] { /<em> Release Resource1 </em>/ })</p>

<p>Acquire Resource2
if (!Resource2) {</p>

<pre><code>// throw exception or return or...
</code></pre>

<p>}
ON_SCOPE_EXIT([&amp;] { /<em> Release Resource2 </em>/ })</p>

<p>```</p>

<p>这样好是好, 可是割裂了申请与释放的代码, 而且每申请一个资源就要至少写上 3 行或以上结构类似代码(可以考虑宏了) ?</p>

<p>当然, 我们是有追求的, 我们还需要更厉害的设施. 也许 <code>unique_ptr</code> 可以给我提供一些思路. 我们需要一个基本的类型, 也许是 <code>HANDLE</code>, 也许是 <code>HINTERNET</code> 等等, 同时我们还需要一个清理函数. 再加上一个资源是否可用的接口即可. 为了避免过多的模板参数, 我们把清理函数以及不可用资源封装到 <code>Traits</code> 类中, 下面是一个例子, 可以很好的完成我们的需求. 另外仿照 <code>unique_ptr</code> 加了一些 move 语义, 转移构造等东西. 下面的代码只实现了 <code>HANDLE</code> 的特化版本, 相信 <code>HINTERNET</code> 的版本, 大家写起来应该也是毫无压力了. 只需要写 <code>Traits</code> 类即可.</p>

<p>```cpp
template <typename T, typename Traits>
class unique_handle {
  struct bool_struct { int member; };
  using bool_type = int bool_struct::*;</p>

<p>public:
  explicit unique_handle(T value = Traits::invalid())</p>

<pre><code>: value_(value) {}
</code></pre>

<p>  unique_handle(unique_handle&amp;&amp; other)</p>

<pre><code>: value_(other.release()) {}
</code></pre>

<p>  unique_handle&amp; operator=(unique_handle&amp;&amp; other) {</p>

<pre><code>reset(other.release());
return *this;
</code></pre>

<p>  }
  ~unique_handle() { close(); }
  T get() { return value_; }
  bool reset(T value = Traits::invalid()) {</p>

<pre><code>if (value_ != value) {
  close();
  value_ = value;
}
return *this;
</code></pre>

<p>  }
  T release() {</p>

<pre><code>auto value = value_;
value_ = Traits::invalid();
return value;
</code></pre>

<p>  }
  operator bool_type() {</p>

<pre><code>return Traits::invalid() != value_ ? &amp;bool_struct::member : nullptr;
</code></pre>

<p>  }
private:
  unique_handle(const unique_handle&amp;);
  unique_handle&amp; operator=(const unique_handle&amp;);
  bool operator==(const unique_handle&amp;);
  bool operator!=(const unique_handle&amp;);
  void close() {</p>

<pre><code>if (*this) {
  Traits::close(value_);
}
</code></pre>

<p>  }
  T value_;
};</p>

<p>struct handle_traits {
  static HANDLE invalid() {</p>

<pre><code>return nullptr;
</code></pre>

<p>  }
  static void close(HANDLE handle) {</p>

<pre><code>CloseHandle(handle);
</code></pre>

<p>  }
};</p>

<p>typedef unique_handle&lt;HANDLE, handle_traits> handle;
```</p>

<p>使用起来应该是这样的:</p>

<p>```cpp
unique_handle&lt;SOCKET, socket_traits> socket;
unique_handle&lt;HANDLE, handle_traits> event;</p>

<p>if (socket &amp;&amp; event) {} // Are both valid?
if (!event) {} // Is event invalid?
int i = socket; // Compiler error!
if (socket == event) {} // Compiler error!
```</p>

<p><code>int i = socket;</code> 这一句很有意思, 我们为了让它能够编译失败, 费了不少功夫. 内部类 <code>bool_struct</code> 就是完全为它而准备. 这也是为什么我们不直接提供 <code>operator bool</code> 的原因. 私有化 <code>operator==</code> 和 <code>operator!=</code> 是为了禁止两个资源进行比较. 而使用内部类成员指针就是为了提供 <code>operator bool</code> 类似功能的同时, 避免它能够提升为 <code>int</code> 等类型. 当然如果我们直接提供一个 <code>is_valid</code> 成员函数, 而不提供隐身转换, 那么就不会有这么多的问题了.</p>

<p>看起来还差错误处理的内容, 不过都到这个份上了, 错误处理就不是问题了吧. 我们可以写各种 <code>check</code> 函数的重载版本, 当 <code>check</code> 失败时抛出异常. 这样就大功告成了.</p>

<h2>参考</h2>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a></li>
<li><a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/">C++11（及现代C++风格）和快速迭代式开发</a></li>
<li><a href="http://msdn.microsoft.com/en-us/magazine/hh288076.aspx">C++ and the Windows API</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 std::tuple 和它的应用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/12/08/cpp11-tuple/"/>
    <updated>2013-12-08T17:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/12/08/cpp11-tuple</id>
    <content type="html"><![CDATA[<p>模板类 <code>std::tuple</code> 是一个固定大小, 存储元素类型不同的集合. 它是 <code>std::pair</code> 的泛化版本.</p>

<p>一个 tuple 可以显示的声明它每个元素的类型, 也可以用 <code>std::make_tuple</code> 模板函数来实现自动类型推导. 可以用 <code>std::get</code> 指定索引来访问 tuple 中的元素. 如下:</p>

<p>```cpp
std::tuple&lt;string, int> t2(&ldquo;bitdewy&rdquo;, 123);</p>

<p>auto t = std::make_tuple(string(&ldquo;bitdewy&rdquo;), 10, 1.23);  // t will be of type tuple&lt;string, int, double>
std::string s = std::get<0>(t);
int x = std::get<1>(t);
double d = std::get<2>(t);
```</p>

<p>当编译期我们需要一个存放不同类型数据的集合, 但又不想定义一个具名的类时 tuple 是非常有用的. 例如 <code>std::function</code> 和 <code>std::bind</code> 就使用 tuple 来存放参数(我们都知道 <code>std::bind</code> 从第二个参数开始, 就是函数的参数了, 参数个数是不定的, 类型也是不定的, 这太适合用 <code>tuple</code> 来定义以及存储函数参数列表了). 尤其是 C++11 开始支持变长模板参数了, 这样一来 tuple 就变得更方便了.</p>

<h2>std::tie</h2>

<p>很多时候我们都希望函数能够返回两个或者更多个值, <code>std::tie</code> 可以帮助我们解决这个问题. <code>std::tie</code> 会构造一个每个元素都是左值引用的 <code>std::tuple</code>. 所以当一个函数返回一个 <code>std::tuple</code> 时, 我们可以使用 <code>std::tie</code> 构造一个 <code>std::tuple</code> 来接收这些返回值. 同时, 如果我们的类的每个元素都支持比较的话, 我们还可以直接使用它来构造一个 <code>std::tuple</code> 来使用 <code>std::tuple</code> 的比较函数. 如下:</p>

<!-- more -->


<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<h1>include <set></h1>

<h1>include <tuple></h1>

<p>struct S {</p>

<pre><code>int n;
std::string s;
float d;
bool operator&lt;(const S&amp; rhs) const {
    return std::tie(n, s, d) &lt; std::tie(rhs.n, rhs.s, rhs.d);
}
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>std::set&lt;S&gt; set_of_s; // S is LessThanComparable

S value{ 42, "Test", 3.14 };
std::set&lt;S&gt;::iterator iter;
bool inserted;

// unpacks the return value of insert into iter and inserted
std::tie(iter, inserted) = set_of_s.insert(value);

if (inserted) {
    std::cout &lt;&lt; "Value was inserted successfully\n";
}
return 0;
</code></pre>

<p>}
```</p>

<h2>tuple_visitor</h2>

<p>visitor 模式是 GoF 书中描述的 23 种设计模式中最难懂的一个. 这个模式甚至让 <a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">Scott Meyers</a> 都困惑了一阵, 显然这个模式的名字没有取好, 而且例子中继承过来继承过去的绕了很多道弯很容易就让你搞不清楚它到底是在做什么的了.</p>

<p>回顾一下我们熟悉的虚函数, 本质上虚函数的作用是<strong>在不改变行为的基础上可以任意扩展类型</strong>, 也就是说我们可以在不更改原有代码的情况下, 将新的类型插入到我们原有的系统中而不需要更改原有系统的代码.</p>

<p>而 visitor 模式只是从另一个角度进行了解耦, 本质上 visitor 模式的作用是<strong>在不改变类型的基础上可以任意扩展对类型的操作</strong>.</p>

<p>不明白上面两句话的可以看看这两篇<a href="http://www.cnblogs.com/geniusvczh/archive/2013/05/25/3098496.html">如何设计一门语言（五）——面向对象和消息发送</a>, <a href="http://www.cnblogs.com/geniusvczh/p/3416833.html">如何设计一门语言（十二）——设计可扩展的类型</a>文章.</p>

<p>之前介绍过 <a href="http://bitdewy.github.io/blog/2013/07/15/static-visitor/">boost.variant.static_visitor</a>, 没有了一个一个的继承,写起来比原始的 visitor 模式简单很多, 如果写过 parser 生成过 AST 然后对它操作的话, 那么你可能对 visitor 有更深刻的理解, 本质上它就是函数式语言中含有<strong>模式匹配</strong>的递归函数.</p>

<p>模式匹配不是什么新玩意儿, 事实上, 它甚至和函数式编程的关系都不大. 把产生模式匹配归因于函数式编程的唯一的原因是函数式语言早就提供了模式匹配, 然而现在的命令式语言还大多做不到. C++ 中的模板特化实际上就是一种模式匹配(类型模式). 比如 <code>std::enable_if</code> 里面经常要用到的 type traits. 下面是一个最简单的模式匹配的例子:</p>

<p>```cpp
template <int N>
struct Factorial {
  static const int value = N * Factorial<N - 1>::value;
};</p>

<p>// Base case via template specialization:</p>

<p>template &lt;>
struct Factorial<0> {
  static const int value = 1;
};
```</p>

<p>这可能是每一个介绍模板元编程都要使用的一个例子, 它利用模式匹配成功的消灭了分支, 进行了编译期的运算, 当然这是个只能演示而没有什么实际意义的代码. 但是表达了模式匹配的意义,</p>

<p>回到正题, 继续我们的 visitor, 有时候我们有遍历 <code>tuple</code> 中存储元素的需求, 最简单的比如按顺序打印, 也许还有其他的针对每个元素的操作, 理论上这和 visitor 模式是类似的. 简单的实现如下:</p>

<p>```cpp</p>

<h1>include <tuple></h1>

<h1>include <iostream></h1>

<p>template&lt;std::size_t> struct int_{};</p>

<p>template <typename Functor, typename Tuple>
void tuple_visitor_impl(Functor&amp;&amp; functor, const Tuple&amp; t, int_<1>) {
  functor(std::get&lt;std::tuple_size<Tuple>::value &ndash; 1>(t));
}</p>

<p>template <typename Functor, typename Tuple, size_t Pos>
void tuple_visitor_impl(Functor&amp;&amp; functor, const Tuple&amp; t, int<em><Pos>) {
  functor(std::get&lt;std::tuple_size<Tuple>::value &ndash; Pos>(t));
  tuple_visitor_impl(std::forward&lt;Functor&amp;&amp;>(functor), t, int</em><Pos - 1>());
}</p>

<p>template <typename Functor, typename... Args>
void tuple_visitor(Functor&amp;&amp; functor, const std::tuple&lt;Args&hellip;>&amp; t) {
  tuple_visitor_impl(std::forward&lt;Functor&amp;&amp;>(functor), t, int_&lt;sizeof&hellip;(Args)>());
}</p>

<p>struct F {
  template <typename T>
  void operator()(T&amp;&amp; t) { std::cout &lt;&lt; &ldquo;unexpect type: &rdquo; &lt;&lt; typeid(std::forward&lt;T&amp;&amp;>(t)).name() &lt;&lt; std::endl; }
  void operator()(int i) { std::cout &lt;&lt; &ldquo;void F::operator()(int): &rdquo; &lt;&lt; i &lt;&lt; std::endl; }
  void operator()(double d) { std::cout &lt;&lt; &ldquo;void F::operator()(double): &rdquo; &lt;&lt; d &lt;&lt; std::endl; }
  void operator()(const std::string&amp; s) { std::cout &lt;&lt; &ldquo;void F::operator()(const std::string&amp;): &rdquo; &lt;&lt; s &lt;&lt; std::endl; }</p>

<p>};</p>

<p>int main() {
  auto t = std::make_tuple(10, std::string(&ldquo;Test&rdquo;), 3.14);
  F f;
  tuple_visitor(f, t);
  return 0;
}
```</p>

<p>当然 F 中要有针对每个类型的 <code>operator()</code>, 这样才能保证每个类型的 <code>tuple</code> 元素都能得到正确的处理, 当然由于我们有泛型版本的 <code>operator()</code> 所以任何类型都能正确接收, 只是行为不正确而已, 上面的代码中是打印出了数据类型, 更好的做法可能是抛出一个异常. 例子中的 <code>operator()</code> 都是重载, 实际上改为特化会更具通用性, 因为一旦改为特化, 那么 <code>struct F</code> 就可以变成框架内的细节, 可以做一些额外的工作. 当用户想要使用 <code>tuple_visitor</code> 的时候, 只需要针对 <code>tuple</code> 中的元素类型, 特化自己的 <code>F::operator()</code> 就可以了.</p>

<h2>tuple_expander</h2>

<p>还记得最上面介绍 <code>tuple</code> 的时候说的, <code>std::bind</code> 是用 <code>tuple</code> 来存储函数参数的吗? 那么由参数构造一个 <code>tuple</code> 是很显而易见的, 那么如何展开一个 <code>tuple</code> 呢?
这里有一个实现, 可以作为参考. <a href="https://github.com/bitdewy/snippet/blob/master/utility/expander.hpp">snippet/utility/expander.hpp</a></p>

<h2>参考</h2>

<ul>
<li>cppreference.com <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crypto++ 试用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/11/18/cryptopp-aes-rsa/"/>
    <updated>2013-11-18T00:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/11/18/cryptopp-aes-rsa</id>
    <content type="html"><![CDATA[<p>由于某些需求, 需要研究一下加密解密的相关内容, 于是找到了 crypto++, 常见的加密算法, 这里面差不多都有了, 但是想用的话, 还是需要先补一下密码学相关的基础知识.</p>

<h2>对等加密</h2>

<p>对等加密 (Reciprocal cipher) 又称为对称密钥加密 (Symmetric-key algorithm), 对称加密, 私钥加密, 共享密钥加密, 是密码学中的一类加密算法. 该类密码的加密算法是它自己本身的逆反函数, 所以其解密算法等同于加密算法, 也就是说, 要还原对等加密的密文, 套用加密同样的算法即可得到明文. 换句话说, 若参数 (或密钥) 合适的话, 两次连续的对等加密运算后会回复原始文字. 在数学上, 这有时称之为对合. 在实际应用中, 体现为加密和解密使用同一个密钥, 或者知道一方密钥能够轻易计算出另一方密钥.</p>

<p>常见的对称加密算法有 DES, 3DES, AES, Blowfish, IDEA, RC4, RC5, RC6.</p>

<p>在对称钥匙密码学中, 加密和解密使用相同的钥匙, 也许对不同的信息使用不同的钥匙, 但都面临钥匙管理的难题. 由于每对通讯方都必须使用异于他组的钥匙, 当网络成员的数量增加时, 钥匙数量成二次方增加. 更尴尬的难题是: 当安全的通道不存在于双方时, 如何建立一个共有的钥匙以利安全的通讯? 如果有通道可以安全地建立钥匙, 何不使用现有的通道. 这个 &ldquo;鸡生蛋, 蛋生鸡&rdquo; 的矛盾是长年以来密码学无法在真实世界应用的阻碍.</p>

<h2>公开密钥加密</h2>

<p>公开密钥加密 (英语: Public-key cryptography, 也称为非对称(密钥)加密), 该思想最早由雷夫·莫寇 (Ralph C. Merkle) 在 1974 年提出, 之后在 1976 年. 狄菲 (Whitfield Diffie) 与赫尔曼 (Martin Hellman) 两位学者以单向函数与单向暗门函数为基础, 为发讯与收讯的两方创建密钥.</p>

<p>非对称密钥, 是指一对加密密钥与解密密钥, 这两个密钥是数学相关, 用某用户密钥加密后所得的信息, 只能用该用户的解密密钥才能解密. 如果知道了其中一个, 并不能计算出另外一个. 因此如果公开了一对密钥中的一个, 并不会危害到另外一个的秘密性质. 称公开的密钥为公钥; 不公开的密钥为私钥.</p>

<!-- more -->


<p>如果加密密钥是公开的, 这用于客户给私钥所有者上传加密的数据, 这被称作为公开密钥加密 (狭义). 例如, 网络银行的客户发给银行网站的账户操作的加密数据.</p>

<p>如果解密密钥是公开的, 用私钥加密的信息, 可以用公钥对其解密, 用于客户验证持有私钥一方发布的数据或文件是完整准确的, 接收者由此可知这条信息确实来自于拥有私钥的某人, 这被称作数字签名, 公钥的形式就是数字证书. 例如, 从网上下载的安装程序, 一般都带有程序制作者的数字签名, 可以证明该程序的确是该作者 (公司) 发布的而不是第三方伪造的且未被篡改过 (身份认证/验证).</p>

<p>常见的公钥加密算法有: RSA, ElGamal, 背包算法, Rabin (RSA的特例), 迪菲－赫尔曼密钥交换协议中的公钥加密算法, 椭圆曲线加密算法 (英语: Elliptic Curve Cryptography, ECC). 使用最广泛的是 RSA 算法 (由发明者 Rivest, Shmir 和 Adleman 姓氏首字母缩写而来) 是著名的公开金钥加密算法, ElGamal 是另一种常用的非对称加密算法。</p>

<p>与对称密钥加密相比, 优点在于无需共享的通用密钥, 解密的私钥不发往任何用户. 即使公钥在网上被截获, 如果没有与其匹配的私钥, 也无法解密, 所截获的公钥是没有任何用处的.</p>

<p>由于公开密钥加密能加密的数据与密钥长度相关, 所以通常不会直接使用公开密钥加密的方式来加密数据, 在数字签名中, RSA 是用来加密/解密原始数据的散列值的(如 MD5, SHA1). 而在加密数据时, 公开密钥加密是用来加密对等加密的密钥的. 下面来看 crypto++ 中具体的加密算法的应用.</p>

<h2>AES</h2>

<p>AES, 高级加密标准 (Advanced Encryption Standard，AES), 在密码学中又称 Rijndael 加密法, 是美国联邦政府采用的一种区块加密标准. 这个标准用来替代原先的 DES, 已经被多方分析且广为全世界所使用. 经过五年的甄选流程, 高级加密标准由美国国家标准与技术研究院 (NIST) 于 2001 年 11 月 26 日发布于 FIPS PUB 197, 并在 2002 年 5 月 26 日成为有效的标准. 2006 年, 高级加密标准已然成为对称密钥加密中最流行的算法之一.</p>

<p>分组加密 (Block cipher, 又称分块加密), 是一种对称密钥算法. 它将明文分成多个等长的模块 (block), 使用确定的算法和对称密钥对每组分别加密解密.</p>

<p>分组加密就要涉及到块密码的工作模式, AES 有 5 种块密码的工作模式, 分别是: 电子密码本 (ECB), 密码块链接 (CBC), 密文反馈 (CFB), 输出反馈 (OFB), 计数器模式(CTR), 各种优缺点详见<a href="http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">块密码的工作模式</a>.</p>

<p>下面是利用 crypto++ 实现 CBC 模式的 AES 加密/解密测试程序</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include &ldquo;aes.h&rdquo;</h1>

<h1>include &ldquo;modes.h&rdquo;</h1>

<h1>include &ldquo;filters.h&rdquo;</h1>

<h1>include &ldquo;osrng.h&rdquo;</h1>

<h1>include &ldquo;hex.h&rdquo;</h1>

<p>int main(int argc, char* argv[]) {
  using namespace CryptoPP;
  AutoSeededRandomPool r;</p>

<p>  byte key[AES::DEFAULT_KEYLENGTH];
  byte iv[AES::BLOCKSIZE];
  r.GenerateBlock(key, AES::DEFAULT_KEYLENGTH);
  r.GenerateBlock(iv, AES::BLOCKSIZE);</p>

<p>  std::string origin = &ldquo;abcdefghijklmnopqrstuvwxyz&rdquo;;
  std::string ciphertext;</p>

<p>  std::cout &lt;&lt; origin &lt;&lt; &ldquo;\n\n&rdquo;;</p>

<p>  AES::Encryption aes_encryption(key, AES::DEFAULT_KEYLENGTH);
  CBC_Mode_ExternalCipher::Encryption cbc_encryption(aes_encryption, iv);</p>

<p>  StreamTransformationFilter encryptor(cbc_encryption, new StringSink(ciphertext));
  encryptor.Put(reinterpret_cast<const unsigned char*>(origin.c_str()), origin.length());
  encryptor.MessageEnd();</p>

<p>  std::string encoded;
  HexEncoder encoder;</p>

<p>  encoder.Put((byte*)ciphertext.data(), ciphertext.size());
  encoder.MessageEnd();</p>

<p>  word64 encoder_size = encoder.MaxRetrievable();
  if(encoder_size &amp;&amp; encoder_size &lt;= SIZE_MAX) {</p>

<pre><code>  encoded.resize(encoder_size);
  encoder.Get((byte*)encoded.data(), encoded.size());
</code></pre>

<p>  }</p>

<p>  std::cout &lt;&lt; encoded &lt;&lt; &ldquo;\n\n&rdquo;;</p>

<p>  // send encoded to server</p>

<p>  std::string decoded;
  HexDecoder decoder;</p>

<p>  decoder.Put((byte*)encoded.data(), encoded.size());
  decoder.MessageEnd();</p>

<p>  word64 decoder_size = decoder.MaxRetrievable();
  if(decoder_size &amp;&amp; decoder_size &lt;= SIZE_MAX) {</p>

<pre><code>  decoded.resize(decoder_size);
  decoder.Get((byte*)decoded.data(), decoded.size());
</code></pre>

<p>  }</p>

<p>  std::cout &lt;&lt; decoded &lt;&lt; &ldquo;\n\n&rdquo;;</p>

<p>  AES::Decryption aes_decryption(key, AES::DEFAULT_KEYLENGTH);
  CBC_Mode_ExternalCipher::Decryption cbc_decryption(aes_decryption, iv);</p>

<p>  std::string decrypted;
  StreamTransformationFilter decryptor(cbc_decryption, new StringSink(decrypted));
  decryptor.Put(reinterpret_cast<const unsigned char*>(decoded.c_str()), decoded.size());
  decryptor.MessageEnd();</p>

<p>  std::cout &lt;&lt; decrypted &lt;&lt; &ldquo;\n\n&rdquo;;</p>

<p>  return 0;
}
```</p>

<h2>RSA</h2>

<p>RSA 加密算法是一种非对称加密算法. 在公开密钥加密和电子商业中 RSA 被广泛使用. RSA 是 1977 年由罗纳德·李维斯特 (Ron Rivest), 阿迪·萨莫尔 (Adi Shamir) 和伦纳德·阿德曼 (Leonard Adleman) 一起提出的. 当时他们三人都在麻省理工学院工作. RSA 就是他们三人姓氏开头字母拼在一起组成的.</p>

<p>1973 年, 在英国政府通讯总部工作的数学家克利福德·柯克斯 (Clifford Cocks) 在一个内部文件中提出了一个相同的算法, 但他的发现被列入机密, 一直到1997年才被发表.</p>

<p>对极大整数做因数分解的难度决定了 RSA 算法的可靠性. 换言之, 对一极大整数做因数分解愈困难, RSA 算法愈可靠. 尽管如此, 只有一些 RSA 算法的变种被证明为其安全性依赖于因数分解. 假如有人找到一种快速因数分解的算法的话, 那么用 RSA 加密的信息的可靠性就肯定会极度下降. 但找到这样的算法的可能性是非常小的. 今天只有短的 RSA 钥匙才可能被强力方式解破. 到 2008 年为止, 世界上还没有任何可靠的攻击 RSA 算法的方式. 只要其钥匙的长度足够长, 用 RSA 加密的信息实际上是不能被解破的.</p>

<p>下面是利用 crypto++ 实现的 RSA 测试程序</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include &ldquo;hex.h&rdquo;</h1>

<h1>include &ldquo;osrng.h&rdquo;</h1>

<h1>include &ldquo;rsa.h&rdquo;</h1>

<p>int main(int argc, char* argv[]) {
  using namespace CryptoPP;
  AutoSeededRandomPool r;
  InvertibleRSAFunction params;
  params.GenerateRandomWithKeySize(r, 1024);</p>

<p>  std::string origin = &ldquo;abcdefghijklmnopqrstuvwxyz&rdquo;;
  std::string ciphertext;</p>

<p>  std::cout &lt;&lt; origin &lt;&lt; &ldquo;\n\n&rdquo;;</p>

<p>  RSA::PrivateKey private_key(params);
  RSA::PublicKey public_key(params);</p>

<p>  RSAES_OAEP_SHA_Encryptor e(public_key);
  StringSource(origin, true, new CryptoPP::PK_EncryptorFilter(r, e, new CryptoPP::StringSink(ciphertext)));</p>

<p>   std::string encoded;
  HexEncoder encoder;</p>

<p>  encoder.Put((byte*)ciphertext.data(), ciphertext.size());
  encoder.MessageEnd();</p>

<p>  word64 encoder_size = encoder.MaxRetrievable();
  if(encoder_size &amp;&amp; encoder_size &lt;= SIZE_MAX) {</p>

<pre><code>  encoded.resize(encoder_size);
  encoder.Get((byte*)encoded.data(), encoded.size());
</code></pre>

<p>  }</p>

<p>  std::cout &lt;&lt; encoded &lt;&lt; &ldquo;\n\n&rdquo;;</p>

<p>  // send encoded to server</p>

<p>  std::string decoded;
  HexDecoder decoder;</p>

<p>  decoder.Put((byte*)encoded.data(), encoded.size());
  decoder.MessageEnd();</p>

<p>  word64 decoder_size = decoder.MaxRetrievable();
  if(decoder_size &amp;&amp; decoder_size &lt;= SIZE_MAX) {</p>

<pre><code>  decoded.resize(decoder_size);
  decoder.Get((byte*)decoded.data(), decoded.size());
</code></pre>

<p>  }</p>

<p>  std::cout &lt;&lt; decoded &lt;&lt; &ldquo;\n\n&rdquo;;</p>

<p>  std::string decrypted;
  RSAES_OAEP_SHA_Decryptor d(private_key);
  StringSource(decoded, true, new CryptoPP::PK_DecryptorFilter(r, d, new CryptoPP::StringSink(decrypted)));</p>

<p>  std::cout &lt;&lt; decrypted &lt;&lt; &ldquo;\n\n&rdquo;;</p>

<p>  return 0;
}
```</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.cryptopp.com/">Crypto++ HomePage</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a></li>
<li><a href="http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">Block cipher mode of operation</a></li>
<li><a href="http://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">RSA</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理(一)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理(二)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[返回值类型推导]]></title>
    <link href="http://bitdewy.github.com/blog/2013/11/11/return-type-resolver/"/>
    <updated>2013-11-11T10:21:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/11/11/return-type-resolver</id>
    <content type="html"><![CDATA[<p>模版函数的参数类型可以自动推导, 它可以让我们在调用函数的时候不必写丑陋的<code>&lt;&gt;</code>, 但如果是返回值类型需要自动推导, 似乎就没有那么容易了. 虽然语言本身不支持返回值的类型自动推导, 但我们可以尝试其他的办法来完成这项任务.</p>

<h2>目的</h2>

<p>在使用函数返回值初始化变量或给变量赋值时模版函数能够自动推导出类型.</p>

<h2>例子</h2>

<p>在某些情况下, 明确被初始化的变量类型是有用的. 考虑下面的例子, 我们使用随机数来初始化 STL 容器. 但是我们不知道用户会选择哪个具体的容器类型. 它可能是 <code>std::list</code>, <code>std::vector</code> 或者其他的行为像 STL 容器的自定义类型. 最直接的方法如下所示:</p>

<p>```cpp</p>

<h1>include <list></h1>

<h1>include <vector></h1>

<h1>include <random></h1>

<p>template <class Container>
Container GetRandomN(size_t n) {
  Container c;
  for(size_t i = 0; i &lt; n; ++i) {</p>

<pre><code>c.insert(c.end(), rand());
</code></pre>

<p>  }
  return c;
}</p>

<p>int main () {
  std::list<int> l = GetRandomN&lt;std::list<int> >(10);
  std::vector<long> v = GetRandomN&lt;std::vector<long> >(100);
  return 0;
}
```</p>

<!-- more -->


<p>我们可以注意到, 代码中必须显示的指定返回值的类型, 很显然我们必须写两次返回值类型, 类型声明写一次, 函数调用又写了一次. 返回值类型推导可以帮助我们解决这个问题, 当然 C++11 中的 auto 类型也可以解决.</p>

<h2>解决方案 &amp; 示例代码</h2>

<p>```cpp</p>

<h1>include <list></h1>

<h1>include <set></h1>

<h1>include <vector></h1>

<h1>include <random></h1>

<p>class GetRandomN {
 public:
  GetRandomN(int n = 1) : count(n) {}</p>

<p>  template <class Container>
  operator Container() {</p>

<pre><code>Container c;
for (size_t i = 0; i &lt; count; ++i) {
  c.insert(c.end(), rand()); // push_back is not supported by all standard containers.
}
return c;
</code></pre>

<p>  }
 private:
  size_t count;
};</p>

<p>int main() {
  std::set<int> random_s = GetRandomN(10);
  std::vector<int> random_v = GetRandomN(10);
  std::list<int> random_l = GetRandomN(10);
  return 0;
}
```</p>

<p>类 GetRandomN 有一个构造函数, 以及一个模版的类型隐式转换函数. 初始化的时候, 会产生一个 GetRandomN 类的临时对象, 当赋值给 STL 容器类型时, 编译器会去尝试将对象隐式转换. 而隐式转换的途径就是取寻找隐式转换函数, 这样就完成了返回值自动推导. 有了返回值类型自动推导, 我们就不必手写返回值类型参数了. 唔… 再注意一点, 为了支持 <code>std::set</code> 我们将原始的 <code>push_back</code> 函数改为了 <code>insert</code>.</p>

<p><em>注: 在 C++11 引入 <code>nullptr</code> 之前, 手工实现一个 <code>nullptr</code> 的惯用法就使用了返回值类型推导.</em></p>
]]></content>
  </entry>
  
</feed>
