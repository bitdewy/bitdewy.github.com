<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Bitdewy]]></title>
  <link href="http://bitdewy.github.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2013-09-25T23:21:56+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ 泛型编程之 SFINAE]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/25/cpp-template-sfinae/"/>
    <updated>2013-06-25T23:01:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/25/cpp-template-sfinae</id>
    <content type="html"><![CDATA[<h2>什么是 SFINAE?</h2>

<p>(Substitution Failure Is Not An Error) 匹配失败不是错误. 它可以从一组重载函数中剪裁掉不需要的模板实例.</p>

<p>SFINAE 是 C++ 模板的一个特性, 这个特性在 std::enable_if 中使用的非常广泛. 模板参数推导过程中, C++ 编译器会试图实例化一些候选的函数签名, 以确保函数调用时模板的精确匹配, 当找到一个不合适的匹配时(例如无效的参数或范围值), 则会将这个不合适的匹配从重载决议中删除, 而不是产生一个编译错误. 如果有且只有一个函数的话, 才会产生一个编译错误.</p>

<p>考虑下面的简单的乘法计数器</p>

<p>```cpp
long multiply(int i, int j) { return i * j; }</p>

<p>template <class T>
typename T::multiplication_result multiply(T t1, T t2)
{
  return t1 * t2;
}</p>

<p>int main(void)
{
  multiply(4,5);
  return 0;
}
```</p>

<p>在 main 函数中的函数调用 multiply, 会导致编译器对模板参数的实例化, 虽然第一个非模板函数 multiply 明显是一个更佳的匹配. 在实例化的过程中, 会产生一个非法的类型 int::multiplication_result. 根据 SFINAE, 这个非法的实例化会被自动丢弃. 最终, 非模板的 multiply 会被调用. 编译通过.</p>

<!-- more -->


<h2>SFINAE 的应用</h2>

<p>SFINAE 通常被用作编译时期的类型属性检查. 比如下面的 is_pointer 元函数, 它可以在编译期检查参数类型是否是一个指针.</p>

<p>```cpp
template <typename T>
struct is_pointer
{
  template <typename U>
  static char is_ptr(U *);</p>

<p>  template <typename X, typename Y>
  static char is_ptr(Y X::*);</p>

<p>  template <class U>
  static char is_ptr(U (*)());</p>

<p>  static double is_ptr(&hellip;);</p>

<p>  static T t;
  enum { value = sizeof(is_ptr(t)) == sizeof(char) };
};</p>

<p>struct Foo {
  int bar;
};</p>

<p>int main(void)
{
  typedef int * IntPtr;
  typedef int Foo::<em> FooMemberPtr;
  typedef int (</em>FuncPtr)();</p>

<p>  printf(&ldquo;%d\n&rdquo;,is_pointer<IntPtr>::value);         // prints 1
  printf(&ldquo;%d\n&rdquo;,is_pointer<FooMemberPtr>::value);  // prints 1
  printf(&ldquo;%d\n&rdquo;,is_pointer<FuncPtr>::value);        // prints 1
  return 0;
}
```</p>

<p>如果没有 SFINAE 的话, 元函数 is_pointer 是无法正常工作的. 在 is_pointer 中, 有四个模板函数 is_ptr, 其中三个都会返回一个 char, 这是经过精心设计的. 这三个分别接收不同的参数类型, 一个接受指针变量, 一个接受一个成员指针, 以及一个简单的函数指针类型. 最后一个 is_ptr 是接收任意类型的(使用了省略号), 它的返回值类型是 double, 它的大小始终会大于 char 类型.</p>

<p>当传递一个指针类型(例如上面的 IntPtr)给 is_pointer 时, value 的值将会初始化为 true (因为 sizeof 两边是相等的). 第一个 sizeof 表达式调用 is_ptr, 如果它是一个指针类型, 那么只有一个模板的重载版本会匹配. 根据 SFINAE, 编译不会报错，因为至少有一个函数被匹配上了.  如果没有合适的实例化版本, 那么会选择那个省略号的版本. 不过那个版本会返回 double 类型, 会导致 value 值被初始化为 false (因为 sizeof(double) != sizeof(char)).</p>

<p>需要注意的是, is_ptr 只有声明, 没有定义. 因为声明足以引发 SFINAE 规则, 但是这些必须都是模板函数。一个模板类的非模板函数是不会参与 SFINAE 的, 只有模板函数才会遵循 SFINAE 规则.</p>

<p>在标准库中, 有大量的 SFINAE 应用, 比如 type traits. 有了 SFINAE 我们就可以根据自己的需求, 为我们所关心的特定类型, 写相应的函数重载函数版本, 也可以在编译期判断类型是否符合我们的需求.</p>

<h2>参考</h2>

<ul>
<li>Wikipedia：<a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">Substitution failure is not an error</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 多线程, std::future & std::promise]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/14/cpp11-multithread-promise-future/"/>
    <updated>2013-06-14T22:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/14/cpp11-multithread-promise-future</id>
    <content type="html"><![CDATA[<p>C++11 中最让人高兴的新特性中线程库的支持一定榜上有名. C++11 中提供了 future 和 promise 来简化任务线程间的返回值操作; 同时为启动任务线程提供了 <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">packaged_task</a> 以方便操作.</p>

<h2>std::packaged_task</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a> 可以包装任何可调用的对象(函数, lambda 表达式, std::bind, 或其他函数对象), 以便异步调用, 调用结果保存在 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中, 可以通过成员函数 get_future 访问. 需要注意的是, <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a> 是不可拷贝的(move only).</p>

<p>示例代码</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include <cmath></h1>

<h1>include <thread></h1>

<h1>include <future></h1>

<h1>include <functional></h1>

<p>void task_lambda()
{</p>

<pre><code>std::packaged_task&lt;int(int,int)&gt; task([](int a, int b) {
    return std::pow(a, b); 
});
std::future&lt;int&gt; result = task.get_future();
task(2, 9);
std::cout &lt;&lt; "task_lambda:\t" &lt;&lt; result.get() &lt;&lt; '\n';
</code></pre>

<p>}</p>

<p>void task_bind()
{</p>

<pre><code>std::packaged_task&lt;int()&gt; task(std::bind(std::pow, 2, 11));
std::future&lt;int&gt; result = task.get_future();
task();
std::cout &lt;&lt; "task_bind:\t" &lt;&lt; result.get() &lt;&lt; '\n';
</code></pre>

<p>}</p>

<p>void task_thread()
{</p>

<pre><code>std::packaged_task&lt;int(int,int)&gt; task(std::pow);
std::future&lt;int&gt; result = task.get_future();
std::thread task_td(std::move(task), 2, 10);
task_td.join();
std::cout &lt;&lt; "task_thread:\t" &lt;&lt; result.get() &lt;&lt; '\n';
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>task_lambda();
task_bind();
task_thread();
</code></pre>

<p>}
```</p>

<!-- more -->


<p>仅仅有 packaged_task 还远远不够, 我们还需要更强大的 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 和 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a>.</p>

<p>基本思路很简单: 当一个任务需要向父线程(启动它的线程)返回值时, 它把这个值放到 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 中. 之后, 这个返回值会出现在和此 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 关联的 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 中.于是父线程就能读到返回值. 更简单点的方法, 参看 <a href="http://en.cppreference.com/w/cpp/thread/async">async()</a>.</p>

<p>如果我们有一个 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> f, 通过 get() 可以获得它的值:</p>

<p><code>cpp
X v = f.get();  // if necessary wait for the value to get computed
</code></p>

<p>如果它的返回值还没有到达, 调用线程会进行阻塞等待. 要是等啊等啊, 等到花儿也谢了的话, get() 会抛出异常的(从标准库或等待的线程那个线程中抛出).</p>

<p>如果我们不需要等待返回值(非阻塞方式), 可以简单询问一下 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a>, 看返回值是否已经到达:</p>

<p>```cpp
if (f.wait_for(0))  {</p>

<pre><code>// there is a value to get()
// do something
</code></pre>

<p>} else {</p>

<pre><code>// do something else
</code></pre>

<p>}
```</p>

<p>但是 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 最主要的用途是一个简单的获取返回值的方法: get().</p>

<p><a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 的主要用途是提供一个 &ldquo;put"（或"get"，随你）操作, 以和 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 的 get() 对应.</p>

<p><a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 为 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 传递的结果类型有 2 种: 传一个普通值或者抛出一个异常</p>

<p>```cpp
try {</p>

<pre><code>X res; 
// compute a value for res
p.set_value(res);
</code></pre>

<p>} catch (&hellip;) {   // oops: couldn&rsquo;t compute res</p>

<pre><code>p.set_exception(std::current_exception()); 
</code></pre>

<p>}
```</p>

<p>到目前为止还不错, 不过我们如何匹配 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> / <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 对呢? 一个在我的线程, 另一个在别的啥线程中吗? 是这样: 既然 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 和 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 可以被到处移动(不是拷贝), 那么可能性就挺多的. 最普遍的情况是父子线程配对形式, 父线程用 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 获取子线程 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 返回的值. 在这种情况下, 使用 <a href="http://en.cppreference.com/w/cpp/thread/async">async()</a> 是很优雅的方法.</p>

<h2>std::promise</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 提供一个存储设施, 当一个异步任务通过 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 来获取结果时, <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 可以提供.</p>

<h2>std::future</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 提供了一种机制来访问异步操作的结果:
由 <a href="http://en.cppreference.com/w/cpp/thread/async">std::async</a>, <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a>, 或者 <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 创建的异步操作, 可以提供一个 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 对象, 给创建者, 用来访问异步操作的结果.</p>

<p>异步操作的创建者, 可以使用各种不同的操作来查询, 等待, 或者从 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中取到异步操作的结果. 如果异步操作还没有执行完的话, 这些操作有可能会阻塞.
当一个异步操作完成时可以通过更改(例如使用 <code>std::promise::set_value</code>) 共享状态(该状态保存在 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中) 将结果返回给异步操作的创建者.</p>

<p>示例代码</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include <future></h1>

<h1>include <thread></h1>

<p>int main()
{</p>

<pre><code>// future from a packaged_task
std::packaged_task&lt;int()&gt; task([](){ return 7; }); // wrap the function
std::future&lt;int&gt; f1 = task.get_future();  // get a future
std::thread(std::move(task)).detach(); // launch on a thread
// future from an async()
std::future&lt;int&gt; f2 = std::async(std::launch::async, [](){ return 8; });
// future from a promise
std::promise&lt;int&gt; p;
std::future&lt;int&gt; f3 = p.get_future();
std::thread([](std::promise&lt;int&gt;&amp; p){ p.set_value(9); },
             std::ref(p)).detach();
std::cout &lt;&lt; "Waiting..." &lt;&lt; std::flush;
f1.wait();
</code></pre>

<p>   f2.wait();</p>

<pre><code>f3.wait();
std::cout &lt;&lt; "Done!\nResults are: "
          &lt;&lt; f1.get() &lt;&lt; ' ' &lt;&lt; f2.get() &lt;&lt; ' ' &lt;&lt; f3.get() &lt;&lt; '\n';
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/thread">Cppreference：Thread support library</a></li>
<li><a href="http://en.wikipedia.org/wiki/Futures_and_promises">wikipedia: futures and promises</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++14 std::optional<T>]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/04/cpp14-optional/"/>
    <updated>2013-06-04T01:54:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/04/cpp14-optional</id>
    <content type="html"><![CDATA[<p>C++11已经发布将近2年时间, 各编译器也陆续有了较好的支持. C++14 也已经有相当多的提案被接受, 包括 std::optional, 泛型 lambda, make_unique, 动态数组等, 肯定会出现在下一个标准中. 关于新标准中的提案, 以及已经被接受的提案，详细信息可以参考, wikipedia：<a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14</a>, 以及 open-std 中的 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">C++ 标准草案</a>.</p>

<h2>“无意义”的值</h2>

<p>函数并不总能返回有效的返回值, 很多时候函数可能返回"无意义"的值, 这不意味着函数执行失败, 而是表明函数正确执行了, 但结果却不是有用的值.
表示返回值无意义最常用的做法是增加一个"哨兵"的角色, 它位于解空间之外, 比如 <code>NULL, -1, EOF, std::string::npos, vector::end()</code>等. 但这些做法不够通用, 而且很多时候不存在解空间之外的"哨兵".</p>

<h2>std::optional<T></h2>

<p>optional 库使用"容器"语义, 包装了"可能产生无效值"的对象, 实现了"未初始化"的概念. (在新标准未正式发布之前，可以参考 <a href="http://www.boost.org/doc/libs/1_54_0/libs/optional/doc/html/index.html">boost::optional</a> 的实现.)</p>

<p>optional 使用"容器"语义, 为这种"无效值"的情形提供了一个较好的解决方案. 它很像一个仅能存放一个元素的容器, 它实现了"未初始化"的概念: 如果元素未初始化, 那么容器就是空的, 否则, 容器内就是有效的, 已经初始化的值.</p>

<!-- more  -->


<h2>操作函数</h2>

<p>optional 的模板类型参数 T 可以使任何类型， 就如同一个标准容器对元素的要求, 并不需要T具有缺省构造函数, 但必须是可拷贝构造的.
optional 采用了指针语义来访问内部保存的元素, 这使得 optional 未初始化时的行为就像一个空指针. 它重载了 <code>operator*</code> 和 <code>operator-&gt;</code> 以实现与指针相同的操作, <code>get()</code> 和 <code>get_ptr()</code> 可以以函数的操作形式获得元素的引用和指针. 成员函数 <code>get_value_or(default)</code> 是一个特别的访问函数, 可以保证返回一个有效的值, 如果 optional 已初始化, 那么返回内部的元素, 否则返回 default. optional 也可以用隐式类型转换进行 bool 测试(用于条件判断), 就像一个对指针的判断. optional 还全面支持比较运算，包括 <code>==, !=, &lt;, &lt;=, &gt;, &gt;=</code>. (详细接口参考 <a href="http://en.cppreference.com/w/cpp/utility/optional">cppreference: std::optional</a>)</p>

<h2>用法</h2>

<p>optional 的接口简单明了, 把它认为是一个大小为 1 并且行为类似指针的容器就可以了, 或者把它想象成是一个类似 scoped_ptr, shared_ptr 的智能指针(注意, optional 不是智能指针, 用法类似但用途不同).</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<h1>include &ldquo;boost/optional.hpp&rdquo;</h1>

<h1>include &ldquo;boost/lexical_cast.hpp&rdquo;</h1>

<p>// converts int to string if possible
boost::optional<int> str2int(const std::string&amp; str)
{
  boost::optional<int> i;
  try {</p>

<pre><code>i = boost::lexical_cast&lt;int&gt;(str);
</code></pre>

<p>  } catch (boost::bad_lexical_cast&amp;) {</p>

<p>  }
  return i;
}</p>

<p>int get_int_form_user()
{
  std::string s;
  for (;;) {</p>

<pre><code>std::cin &gt;&gt; s;
boost::optional&lt;int&gt; o = str2int(s); // 'o' may or may not contain an int
if (o) {                                 // does optional contain a value?
  return *o;                             // use the value
}
</code></pre>

<p>  }
}</p>

<p>int main()
{
  std::cout &lt;&lt; get_int_form_user();
  return 0;
}
```</p>

<p>如上面的代码所示: 使用 optional, 非法的 int 类型, 就不需要定义一个特别的错误码作为无意义值了.</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/utility/optional">cppreference.com: optional</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">A proposal to add a utility class to represent optional objects (Revision 4)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 关键字 using]]></title>
    <link href="http://bitdewy.github.com/blog/2013/05/21/cpp11-keywords-using/"/>
    <updated>2013-05-21T00:45:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/05/21/cpp11-keywords-using</id>
    <content type="html"><![CDATA[<p><em>这个特性, 10年前就已经有提案了, 直到 C++11 中才正式加入标准. ⊙﹏⊙b汗</em></p>

<h2>使用小技巧来声明函数指针</h2>

<p>在 c++03 中, 函数指针要这么写:</p>

<p><code>cpp
typedef void (*FunctionPtr)();
</code></p>

<p>这个声明读起来相当的费劲, C 语言的初学者会很难理解上面的 typedef 表达的意思.</p>

<p>在 C++11 中, 我们可以使用更易读懂的方式来表达, 利用 using 关键字:</p>

<p><code>cpp
using FunctionPtr = void (*)();
</code></p>

<p>如果你想去除丑陋的 * 号, 还可以利用类型特化这么来写:</p>

<p>```cpp</p>

<h1>include &lt;type_traits></h1>

<p>using FunctionPtr = std::add_pointer&lt;void()>::type;
```</p>

<p>新关键字 using 当然不仅仅是为了这个简单的功能了, 最主要的目的是为了模板别名.</p>

<!-- more -->


<h2>模板别名</h2>

<p>在进入这个主题之前, 应该先弄清楚“模板类”和“类模板”本质上的不同. class template (类模板，是模板)是用来产生 template class (模板类, 是类型)的.
在标准 C++, typedef 可定义模板类一个新的类型名称, 但是不能够使用 typedef 来定义模板的别名. 举例来说:</p>

<p><code>cpp
template&lt; typename first, typename second, int third&gt;
class SomeType;
template&lt; typename second&gt;
typedef SomeType&lt;OtherType, second, 5&gt; TypedefName; // 在C++03是不合法的
</code></p>

<p>这不能够通过编译.
为了定义模板的别名, C++11 增加了以下的语法:</p>

<p><code>cpp
template&lt; typename first, typename second, int third&gt;
class SomeType;
template&lt; typename second&gt;
using TypedefName = SomeType&lt;OtherType, second, 5&gt;;
</code></p>

<p>using 紧跟着的标识, 用来表示后面的模板类型. 标准制定时尝试过使用旧的关键字 typedef 来实现该功能, 但是无法得到一个完整连贯的解决方案, 因此引入了新的关键字. (严格说来 using 并不是一个新的关键字, 在使用 namespace 时, 我们就已经见过它了, 但在 C++11 中它又有了新的语义.）</p>

<p>除了模板别名之外, using 关键字还可以用在一般的类型中, 就想文章一开始的地方一样:</p>

<p><code>cpp
typedef void (*PFD)(double);            // 传统语法
using PFD = void (*)(double);           // 新增与否
</code></p>

<h2>参考</h2>

<ul>
<li>C++ standard  14.6.7 Template aliases;  7.1.3 The typedef specifier</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1489.pdf">Templates aliases for C++</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">Templates Aliases (Revision 3)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] GotW #1 Solution: Variable Initialization – or Is It?]]></title>
    <link href="http://bitdewy.github.com/blog/2013/05/12/gotw1/"/>
    <updated>2013-05-12T02:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/05/12/gotw1</id>
    <content type="html"><![CDATA[<p>原文在这里 <a href="http://herbsutter.com/2013/05/09/gotw-1-solution/">GotW #1 Solution: Variable Initialization – or Is It?</a></p>

<p><em>第一个问题是用来强调理解你写的代码的含义的重要性. 下面是几行简单的代码 &ndash; 大部分都与其他的有一些区别, 即使只是语法略有变化.</em></p>

<h2>JG 问题</h2>

<p>1. 下面的代码有什么不同?</p>

<p>```cpp
widget w;                   // (a)</p>

<p>widget w();                 // (b)
widget w{};                 // &copy;</p>

<p>widget w(x);                // (d)
widget w{x};                // (e)</p>

<p>widget w = x;               // (f)
widget w = {x};             // (g)</p>

<p>auto w = x;                 // (h)
auto w = widget{x};         // (i)
```</p>

<h2>Guru 问题</h2>

<p>2. 下面的每一行代码做了什么?</p>

<p>```cpp
vector<int> v1( 10, 20 );   // (a)</p>

<p>vector<int> v2{ 10, 20 };   // (b)
```</p>

<p>3. 除了上面的情况以外, 使用 <code>{ }</code> 初始化对象还有什么其他的好处?</p>

<p>4. 什么时候使用 <code>( )</code> 以及 <code>{ }</code> 来初始化对象? 为什么?</p>

<!-- more -->


<h2>解决方案</h2>

<p>这几个问题展示了几件事:</p>

<ul>
<li>默认初始化, 显式初始化, 拷贝初始化, 以及初始化列表之间的区别.</li>
<li>初始化时 <code>( )</code> 与 <code>{ }</code> 之间的差异.</li>
<li>在现代 C++ 中要避免的, 看起来像初始化, 但完全和初始化无关的东西</li>
</ul>


<p>不过, 最重要的是: 如果你坚持问题 #4 中的两个简单的指导的话, 就可以忽略这些情况, 规则相当的简单, 而且默认情况下可以获得高效的性能.</p>

<h3>1. 下面的代码有什么不同?</h3>

<p>让我们一条一条的来看.</p>

<p><strong>情况 (a) 是默认初始化</strong></p>

<p><code>cpp
widget w;                   // (a)
</code></p>

<p>这一行代码声明了一个 <code>widget</code> 类型的变量 <code>w</code>, 假定 <code>widget</code> 是一个 <code>class</code> 类型, 它会使用默认构造函数 <code>widget::widget()</code> 来初始化.</p>

<p><strong>情况 (b) 是一个 &ldquo;恼人&rdquo; 的无关转移, 是历史遗留问题</strong></p>

<p><code>cpp
widget w();                 // (b)
</code></p>

<p>这是 C++ 的一个陷阱: 第一眼看上去, 它看上去像另一个调用默认构造函数 <code>widget::widget()</code> 的变量声明. 事实上, 感谢语法二义性, 这是一个函数声明. 一个名为 <code>w</code>, 无参, 返回值是 <code>widget</code> 类型的函数声明. (如果你无法一眼看出的话, 考虑下上面的代码其实与 <code>int f()</code> 没有任何的差别, 而这个函数声明是显而易见的对吧.)</p>

<p>避免你认为 &ldquo;吖, 但是那些 <code>()</code> 是多于的, 这是程序员自己的错误, 因为他们没有直接写 <code>widget w;</code>&rdquo;, 注意, 这个的问题也会出现在你以为你正在使用临时对象初始化变量的时候:</p>

<p><code>cpp
// same problem (gadget and doodad are types)
//
widget w( gadget(), doodad() );  // pitfall: not a variable declaration
</code></p>

<p>Scott Meyers 很多年前就称这个是 &ldquo;C++ 中最恼人的语法解析&rdquo;, 因为标准中解决语法二义性是这么说的: &ldquo;如果能够被解析为函数声明, 那么它就是一个函数声明.&rdquo;</p>

<p>好消息是, 这个问题将要成为历史, 在新的代码中你将不会遇到它, 因为 C++11 移除了这个陷阱. 注意 C++11 并没有修改语义 &ndash; C++11 的向后兼容 C++98 做的非常好, 包括这个语法二义性, 仍然是它原有的含义. 但是, C++11 通过提供新的语法取代情况 (b), 因此我们再也不会掉到这个陷阱中了.</p>

<p><strong>情况 (c) 干净明确</strong></p>

<p><code>cpp
widget w{};                 // (c)
</code></p>

<p>在这儿我们有了第一个使用 <code>{ }</code> 而不使用 <code>()</code> 的理由: 对于任意的 class 类型 <code>widget</code>, 情况 (c) 做的事情像 (a) 一样的明确 &ndash; 无二义性, 干净, 明确.</p>

<p>&ldquo;哈哈, 但是等等, 它可没有那么简单!&rdquo; 有些人可能会反对. &ldquo;如果 <code>widget</code> 有一个接受 <code>std::initializer_list</code> 的构造函数那会怎么样呢? 他们都是被优先选择的, 所以, 如果 <code>widget</code> 有这么一个构造函数, 这个写法不会调用它吗?&rdquo;</p>

<p>答案是不会, 这个真的像你看到的一样简单, 因为标准中明确了, 如果可以的话, 空的 <code>{ }</code> 列表意味着调用默认构造函数. 不过, 能意识到 <code>initializer_list</code> 是好的, 让我们在后面再讨论它.</p>

<p><strong>情况 (d) 和 情况 (e) 是直接初始化</strong></p>

<p><code>cpp
widget w(x);                // (d)
widget w{x};                // (e)
</code></p>

<p>假设 <code>x</code> 不是一个类型名, 这两个都是直接初始化. 因为变量 <code>w</code> 是由 <code>x</code> 直接调用 <code>widget::widget(x)</code> 初始化的. 如果 <code>x</code> 也是 <code>widget</code> 类型, 它会调用拷贝构造函数. 否则的话, 调用一个转换构造函数.</p>

<p>但是, 注意 <code>{x}</code>, 它会创建一个 <code>initializer_list</code>. 如果 <code>widget</code> 有接受 <code>initializer_list</code> 的构造函数的话, 这个构造函数是被优先选择的; 否则, 如果 <code>widget</code> 有接受任意 <code>x</code> 的类型的构造函数的话(包括类型转换), 这个构造函数将会被调用.</p>

<p>情况 (e) 有两个优于 (d) 的地方: 一, 与 (c) 一样, (e) 是明确, 无二义性的. 如果 <code>x</code> 是一个类型名, 那么 (d) 就是一个函数声明, 即使在作用域内有一个名为 <code>x</code> 的变量 (看下文), 而 (e) 不可能是一个函数声明.</p>

<p>第二: (e) 更安全, 因为它不允许有损转换, 一些内建类型是允许的. 考虑下面的代码:</p>

<p><code>cpp
int i1( 12.345 );           // ok: loss .345, we didn't like it anyway
int i2{ 12.345 };           // error: would be lossy implicit narrowing
</code></p>

<p><strong>情况 (f) 与 (g) 是拷贝初始化和拷贝类表初始化</strong></p>

<p>这是最后两个 non-auto 的情况:</p>

<p><code>cpp
widget w = x;               // (f)
</code></p>

<p>这就是所谓的拷贝初始化. <em>从概念上来讲</em>, 变量 <code>w</code> 是由 <code>widget</code> 的转移构造函数或者拷贝构造函数初始化的. 有可能是在调用一个隐式转换函数之后(显式转换不会调用).</p>

<blockquote><p><strong>通常的错误:</strong> 这个绝对是初始化; 绝不是赋值, 所以绝对不会调用 <code>T::operator=()</code>. 是的, 我知道这有一个<code>=</code>赋值符号, 但是不要让这个符号影响到你 &ndash; 这仅仅是从 C 继承而来的符号, 不是赋值操作符.</p></blockquote>

<p>下面是语义:</p>

<ul>
<li>如果 <code>x</code> 的类型是 <code>widget</code>, (f) 与 (d) <code>widget w(x);</code> 的含义完全一致, 除非明确的构造函数不能使用. 他保证了只有一个构造函数被调用.</li>
<li>如果 <code>x</code> 是其他类型, <em>从概念上来讲</em>编译器首先将 <code>x</code> 隐式转换为 <code>widget</code> 类型的临时对象, 然后对临时右值使用转移构造函数, 如果没有好的转移构造函数, 那么会使用拷贝构造函数 &ndash; &ldquo;低效的转移"作为备选. 假设存在可用的隐式转换, (f) 就与 <code>widget w(widget(x))</code> 一致了.</li>
</ul>


<p>注意, 上面说了几次<em>从概念上来讲</em>. 这是因为通常编译器都会做优化, 优化掉临时变量, 如果存在隐式转换, 从 (f) 转换为 (d), 那么就优化掉了额外的转移操作. 但是, 尽管编译器这么做了, <code>widget</code> 的拷贝构造函数也必须是可访问的, 即使没有调用 &ndash; 拷贝构造函数的副作用可能发生也可能不发生, 就这些.</p>

<p>现在来注意一下增加的符号 <code>=</code>:</p>

<p><code>cpp
widget w = {x};             // (g)
</code></p>

<p>这个是所谓的拷贝列表初始化. 它与 <code>widget w{x};</code> 的含义一致 除非显示的构造函数无法使用. 它保证了只有咦个的构造函数被调用.</p>

<p><strong>情况 (h) 和 (i) 也是拷贝初始化, 但是更简单</strong></p>

<p><code>cpp
auto w = x;                 // (h)
auto w = widget{x};         // (i)
</code></p>

<p>语义与 (f) 和 (g) 一样, 但是学习起来更简单, 因为使用了 <code>auto</code> 保证了右侧表达式类型推导的准确性. 需要注意的是 (i) 在隐式转换与显式转换的情况下都能正常工作.</p>

<p>(h) 与 (d) 的含义一致, <code>type_of_x w(x);</code>. 只有一个拷贝构造函数被调用. 它可以保证类型发生变化时, 程序还总是正确的: 因为 (h) 没有明确特性的类型, 它有两个有效的保证, 因为这不会存在类型的转换, 以及更好的维护性, 因为当程序中 <code>x</code> 的类型变更时, &lsquo;w&rsquo; 会自动变更类型与 <code>x</code> 保持一致.</p>

<p>当你想要明确类型或者需要显式的类型转换时, (i) 是最风格一致的, 而且一旦使用了 <code>{ }</code> 就可以避免有损的类型转换了. 大部分的编译器实现, 只会有一个构造函数调用 &ndash; 和我们看到的 (f) 与 (g) 相似, 概念上来讲会有两个构造函数调用, 一个转换构造函数或者拷贝构造函数用来创建临时的 <code>widget{x}</code> 然后紧接着一个转移构造函数来构造 <code>w</code>, 但是编译器会把后一个优化掉.</p>

<p>通常情况下, 我推荐你尝试这两种用法, 并倾向于使用它来伴随你舒服的成长. 现在几乎所有我写的局部变量声明都采用这种方式. (我知道会有一些人怀疑这种方式 &ndash; 更多的关于关键字 <code>auto</code> 的问题在其他的 GotW 中讨论.)</p>

<h3>2. 下面的每一行代码做了什么?</h3>

<p>在第二个问题的代码中, 我们创建了一个 <code>vector&lt;int&gt;</code> 并将参数 <code>10</code> 和 <code>20</code> 传给它的构造函数 &ndash; 第一种情况是 <code>(10, 20)</code>, 第二种情况是 <code>{10, 20}</code>.</p>

<p>两个都会调用构造函数, 但是会调用哪个呢? 嗯, <code>vector&lt;int&gt;</code> 有很多接受两个参数的构造函数, 但是只有下面两个能够正确的接受参数 <code>10</code> 和 <code>20</code>. 为了简单, 忽略掉默认的分配器参数, 两个构造函数应该是下面的样子:</p>

<p>```cpp
vector( size_t n, const int&amp; value );    // A: n copies of value</p>

<p>vector( initializer_list<int> values );  // B: copy of values
```</p>

<p>有两个简单的规则可以帮助我们确定哪个函数将被调用:</p>

<ul>
<li>在表达式的上下文中使用 <code>{ }</code> 你会得到一个 <code>initializer_list</code>.</li>
<li>接受 <code>initializer_list</code> 参数的构造函数会优于其他构造函数被选择, 同时会隐藏其他构造函数, 否则可能是可行的.</li>
</ul>


<p>有了这两条, 答案就很简单了:</p>

<p>```cpp
vector<int> v1( 10, 20 );    // (a) calls A: 10 copies of the value 20
assert( v1.size() == 10 );</p>

<p>vector<int> v2{ 10, 20 };    // (b) calls B: the values 10 and 20
assert( v2.size() == 2 );
```</p>

<h3>3. 除了上面的情况以外, 使用 <code>{ }</code> 初始化对象还有什么其他的好处?</h3>

<p>首先, 这叫做统一初始化, 因为它统一 &ndash; 所有的类型, 包括 <code>structs</code>, 数组, 标准库容器, 而且也不存在恼人的语法解析问题.</p>

<p>```cpp
struct mystruct { int x, y; };</p>

<p>// C++98
rectangle       w( origin(), extents() );       // oops, vexing parse
complex<double> c( 2.71828, 3.14159 );
mystruct        m = { 1, 2 };
int             a[] = { 1, 2, 3, 4 };
vector<int>     v;                              // urk, need more code
for( int i = 1; i &lt;= 4; ++i ) v.push_back(i);   //   to initialize this</p>

<p>// C++11 (note: &ldquo;=&rdquo; is optional)
rectangle       w   = { origin(), extents() };
complex<double> c   = { 2.71828, 3.14159 };
mystruct        m   = { 1, 2 };
int             a[] = { 1, 2, 3, 4 };
vector<int>     v   = { 1, 2, 3, 4 };
```</p>

<p>注意, 这不仅仅是个审美的问题. 考虑编写通用的能够初始化任何类型的代码&hellip; 我们正在做的, 让我们使用完美转发做为例子:</p>

<p>```cpp
template<typename T, typename ...Args>
void forwarder( Args&amp;&amp;&hellip; args ) {</p>

<pre><code>// ...
T local = { std::forward&lt;Args&gt;(args)... };
// ...
</code></pre>

<p>}</p>

<p>forwarder<int>            ( 42 );                  // ok
forwarder<rectangle>      ( origin(), extents() ); // ok
forwarder&lt;complex<double>>( 2.71828, 3.14159 );    // ok
forwarder<mystruct>       ( 1, 2 );                // ok because of {}
forwarder&lt;int[]>          ( 1, 2, 3, 4 );          // ok because of {}
forwarder&lt;vector<int>>    ( 1, 2, 3, 4 );          // ok because of {}
```</p>

<p>如果 <code>forwarder</code> 内部使用了 <code>( )</code> 做初始化符号的话, 那么最后三条是不合法的.</p>

<p>新的符号 <code>{ }</code> 在任何地方都能完美的工作, 包括类成员的初始化:</p>

<p><code>cpp
widget::widget( /*...*/ ) : mem1{init1}, mem2{init2, init3} { /*...*/ }
</code></p>

<p>另外, 它还能简单清晰的表达传递函数参数, 返回值, 而不需要一个具名的临时对象:</p>

<p>```cpp
void draw_rect( rectangle );</p>

<p>draw_rect( rectangle(origin, selection) );         // C++98
draw_rect({ origin, selection });                  // C++11</p>

<p>rectangle compute_rect() {
   // &hellip;
   if(cpp98) return rectangle(origin, selection);  // C++98
   else      return {origin, selection};           // C++11
}
```</p>

<h3>4. 什么时候使用 <code>( )</code> 以及 <code>{ }</code> 来初始化对象? 为什么?</h3>

<p>下面是简单的指导:</p>

<blockquote><p><strong>准则:</strong> 尽量在初始化时使用 <code>{ }</code>, 比如 <code>vector&lt;int&gt; v = { 1, 2, 3, 4 };</code> 或者 <code>auto v = vector&lt;int&gt;{ 1, 2, 3, 4 };</code>, 因为它有更好的一致性, 更正确, 可以避免去了解过去的陷阱. 在单参数的情况下你可能会仅仅看到一个赋值符号 <code>=</code>, 就像 <code>int i = 42;</code> 一样, 这种情况下, 省略括号是好的&hellip;</p></blockquote>

<p>上面的准则可以覆盖绝大部分情况, 但是也有一个例外:</p>

<blockquote><p>&hellip; 在极端情况下, 比如 <code>vector&lt;int&gt; v(10,20);</code> 或者 <code>auto v = vector&lt;int&gt;(10,20);</code> 时, 使用 <code>( )</code> 明确的调用会被 <code>initializer_list</code> 构造函数隐藏的构造函数.</p></blockquote>

<p>但是, 这个仅仅是在极端情况下, 因为默认构造函数以及拷贝构造函数已经很特别, 并且能与括号 <code>{ }</code> 很好的工作, 现在一个好的类的设计会避免用到 <code>()</code> 来提供用户定义的构造函数, 因为下面的设计准则:</p>

<blockquote><p><strong>准则</strong>: 当你设计一个类时, 避免提供一个与 <code>initializer_list</code> 构造函数会产生二义性的构造函数, 这样用户就不需要使用 <code>()</code> 来访问会被隐藏掉的构造函数.</p></blockquote>
]]></content>
  </entry>
  
</feed>
