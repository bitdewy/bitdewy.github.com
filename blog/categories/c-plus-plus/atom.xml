<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Bitdewy]]></title>
  <link href="http://bitdewy.github.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2013-09-30T00:36:06+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++11 完美转发]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/08/cpp11-perfect-forward/"/>
    <updated>2013-07-08T22:09:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/08/cpp11-perfect-forward</id>
    <content type="html"><![CDATA[<h2>动机</h2>

<p>在泛型编码中经常出现的一个问题是: 如何将一组参数原封不动的转发给另一个函数? 这里的原封不动指的是: 保持参数的左值 (右值), const (non-const) 属性不变.</p>

<h2>C++03 中参数转发存在的问题</h2>

<p>下面来看一个例子, 对于表达式 <code>E(a, b, …, c)</code> 我们希望它与 <code>f(a, b, …, c)</code> 完全等价. 在 C++03 中这是不可能的. 下面是几种设计方案, 但所有的都会在某些条件下失效.</p>

<p>最简单的, 使用引用参数:</p>

<p>```cpp
template <typename A, typename B, typename C>
void f(A&amp; a, B&amp; b, C&amp; c) {</p>

<pre><code>E(a, b, c);
</code></pre>

<p>}
```</p>

<p>很遗憾, 函数 f 无法处理临时变量, 例如 <code>f(1, 2, 3)</code>; 会编译失败. 这三个参数都无法绑定到引用.</p>

<p>再来看看 const 引用:</p>

<p>```cpp
template <typename A, typename B, typename C>
void f(const A&amp; a, const B&amp; b, const C&amp; c) {</p>

<pre><code>E(a, b, c);
</code></pre>

<p>}
```</p>

<!-- more -->


<p>这解决了上面的问题, 但是又引入了新的问题, 现在我们无法让 E 接收 non-const 参数了, 下面的代码也会产生一个编译失败.</p>

<p><code>cpp
int i = 1, j = 2, k = 3;
void E(int&amp;, int&amp;, int&amp;);
f(i, j, k); // oops! E cannot modify these
</code></p>

<p>嗯, 再来个尝试, 解决上面的问题, 我们接收 const 引用, 然后使用 const_cast 来去掉 const 属性.</p>

<p>```cpp
template <typename A, typename B, typename C>
void f(const A&amp; a, const B&amp; b, const C&amp; c) {</p>

<pre><code>E(const_cast&lt;A&amp;&gt;(a), const_cast&lt;B&amp;&gt;(b), const_cast&lt;C&amp;&gt;(c));
</code></pre>

<p>}
```</p>

<p>最后来终极解决方案吧, 利用重载, 根据重载决议, 我们可以使用 const 引用和 non-const 引用来进行参数重载, 对于上面的例子, 我们的实现如下:</p>

<p>```cpp
template <typename A, typename B, typename C>
void f(A&amp; a, B&amp; b, C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(const A&amp; a, B&amp; b, C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(A&amp; a, const B&amp; b, C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(A&amp; a, B&amp; b, const C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(const A&amp; a, const B&amp; b, C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(const A&amp; a, B&amp; b, const C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(A&amp; a, const B&amp; b, const C&amp; c);</p>

<p>template <typename A, typename B, typename C>
void f(const A&amp; a, const B&amp; b, const C&amp; c);
```</p>

<p>n 个参数的函数, 就需要 2<sup>n</sup> 个重载版本, 这太恐怖了, 我们非常需要自动完成这些工作. 这个问题在 C++11 中的到了完美的解决.</p>

<h2>完美转发</h2>

<p>C++11 新标准给了我们修复这个问题的机会 (这里有一个破坏性的解决方案, 虽然解决了完美转发的问题, 但是破坏了现有的类型推导规则<a href="http://stackoverflow.com/questions/3591832/perfect-forwarding-in-c03/3591909#3591909">《Perfect Forwarding in C++03》</a>).</p>

<p>C++11 中引入了新的概念, 右值引用. 我们可以在不破坏现有代码的情况下, 定义右值引用的推导规则, 来解决完美转发的问题.</p>

<p>看下面的表格, (TR 表示 T 引用类型)</p>

<p>```cpp
TR   R</p>

<p>T&amp;   &amp;  &ndash;> T&amp;  // lvalue reference to cv TR &ndash;> lvalue reference to T
T&amp;   &amp;&amp; &ndash;> T&amp;  // rvalue reference to cv TR &ndash;> TR (lvalue reference to T)
T&amp;&amp;  &amp;  &ndash;> T&amp;  // lvalue reference to cv TR &ndash;> lvalue reference to T
T&amp;&amp;  &amp;&amp; &ndash;> T&amp;&amp; // rvalue reference to cv TR &ndash;> TR (rvalue reference to T)
```</p>

<p>然后, 模板参数推导时, 如果参数是左值, 那么就推导为左值引用. 否则使用正常的类型推导. 这里又引入了一个新的概念, “全局引用” (universal references), 具体细节详见: <a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11">C++ and Beyond 2012: Scott Meyers &ndash; Universal References in C++11</a></p>

<p>为什么这样就能解决问题? 因为我们保持了参数的类型: 如果参数是一个左值, 我们得到的是左值引用的参数, 否则我们得到的是右值引用类型的参数, 看下面的代码:</p>

<p>```cpp
template <typename T>void deduce(T&amp;&amp; x);</p>

<p>int i;
deduce(i); // deduce&lt;int&amp;>(int&amp; &amp;&amp;) &ndash;> deduce&lt;int&amp;>(int&amp;)
deduce(1); // deduce<int>(int&amp;&amp;)
```</p>

<p>最后就是要做“转发”了. 需要注意的是, 在函数内参数类型是一个左值类型.</p>

<p>```cpp
void foo(int&amp;);</p>

<p>template <typename T>
void deduce(T&amp;&amp; x){</p>

<pre><code>foo(x); // fine, foo can refer to x
</code></pre>

<p>}</p>

<p>deduce(1); // okay, foo operates on x which has a value of 1
```</p>

<p>这还不足够. foo 需要拿到和 deduce 一样的参数类型, 解决方案如下.</p>

<p><code>cpp
static_cast&lt;T&amp;&amp;&gt;(x);
</code></p>

<p>上面这行代码做了什么呢? 我们在 deduce 函数中, 且我们接收了一个左值类型的参数, 这意味着 T 是 A&amp; 类型, 经过静态类型转换 A&amp; &amp;&amp; 仍然是 A&amp; 类型. 因此, 加入 x 以及是一个 A&amp; 类型, 那么我们什么也没有做, 它仍然是一个左值引用类型.</p>

<p>当我们接收的是一个右值, T 就是 A 类型, 因此我们转换后的类型为 A&amp;&amp;. 转换后的类型是一个右值表达式, 这样就不会再作为左值参数了. 我们保持住了参数的类型. 将上面的组合到一起, 我们就得到了“完美转发”:</p>

<p>```cpp
template <typename A>
void f(A&amp;&amp; a) {</p>

<pre><code>E(static_cast&lt;A&amp;&amp;&gt;(a));
</code></pre>

<p>}
```</p>

<p>当 f 接收到一个左值, 那么 E 也接收一个左值, 当 f 接收的是一个右值, 那么 E 接受到的也是一个右值, 完美了.</p>

<p>当然, 上面的代码是有一点丑陋. <code>static_cast&lt;T&amp;&amp;&gt;</code> 古怪而且不容易记住. 标准库中提供了一个工具函数, 叫做 forward, 它所做的事情与类型转换完全一致.</p>

<p><code>cpp
std::forward&lt;A&gt;(a);
// is the same as
static_cast&lt;A&amp;&amp;&gt;(a);
</code></p>

<h2>参考</h2>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">C++标准提案(N1385)：The Forwarding Problem: Arguments</a></li>
<li><a href="http://blog.csdn.net/pongba/article/details/1697636">《C++0x漫谈》系列之：右值引用(或“move语意与完美转发”)(下)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 右值引用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/02/cpp11-rvalue-ref/"/>
    <updated>2013-07-02T22:49:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/02/cpp11-rvalue-ref</id>
    <content type="html"><![CDATA[<h2>什么是右值引用?</h2>

<p>在一般情况下, C++ 不把表达式的左值属性作为类型的一部分, 比如下面的变量声明:</p>

<p><code>cpp
int n;
</code></p>

<p>那么变量 n 的类型是 int. 另外常量 3 也是 int 类型. 虽然他们有相同的类型, 不过这并不是说 n 和 3 总是可以互换的. 比如下面的代码:</p>

<p><code>cpp
int&amp; r = n;  // OK
int&amp; s = 3;  // Error
</code></p>

<p>这是因为标准中规定, 当定义一个引用时, 我们必须使用一个左值来初始化它. 在上面的代码中, n 是一个左值, 而 3 不是. 所以我们不能用 3 来初始化 s. 这个规定可以帮助编译器来捕捉错误, 比如下面的代码:</p>

<p><code>cpp
std::cin &gt;&gt; 3;  // equals std::cin.operator&gt;&gt;(3);
</code></p>

<p>简单的说, 上面的代码调用了 std::cin 的名为 operator>> 的成员函数, 并使用 3 作为参数. operator>> 是重载函数, 虽然它有接受一个 int&amp; 参数的重载版本, 但是没有能接受一个简单的 int 常量, 或者 int 右值作为参数的重载. 因此, 编译器会检查出我们无法使用 int 的右值作为参数来调用 operator>>.</p>

<!-- more -->


<p>C++11 扩展了引用的概念, 增加了右值引用. 右值引用也是一个引用, 但与普通的引用不同, 它只能绑定到右值上. 下面是一个右值引用的声明:</p>

<p><code>cpp
int&amp;&amp; t = 3;
</code></p>

<p>一个普通的引用只能绑定左值, 一个右值引用只能绑定到右值, 也就是说如果我们写了下面的代码, 编译器会报一个错误.</p>

<p><code>cpp
int&amp;&amp; t = n;    // Error: n is an lvalue
</code></p>

<p>右值引用是一个有趣的组合, 虽然你只能绑定右值到右值引用, 但是你使用时它却是一个左值.</p>

<p>例如下面的代码:</p>

<p><code>cpp
int&amp;&amp; t = 3;
++t;
</code></p>

<p>通常情况下, 程序员不能修改右值. 但是通过右值引用, 获得了左值, 这样我们就能修改它的值了. 另外, 右值在通过右值引用绑定之后, 这个右值就不在可访问, 它使用了转移语义来代替拷贝操作.</p>

<p>定义一个接收右值引用参数的函数, 那么函数就会使用转移语义来替代拷贝操作. 但是这样会禁止接收左值参数.</p>

<p><code>cpp
void foo(int&amp;&amp;);
foo(42);        // OK;
int n;
foo(n);         // Error: n is an lvalue
</code></p>

<p>我们当然可以定义一个左值的版本来解决上面的问题:</p>

<p><code>cpp
void bar(int&amp;&amp;);
void bar(const int&amp;);
bar(42);             // calls bar(int&amp;&amp;)
int n;
bar(n);               // calls bar(const int&amp;)
</code></p>

<p>这个技术有个值得记住的地方是, 通过 const 引用和右值引用的两个重载版本, 你告诉了编译器哪个修改参数是安全的, 哪个不是. 此外, 编译器在编译期就决定了使用哪个, 从而避免了运行时的开销.</p>

<h2>Move 语义</h2>

<p>右值引用的引入, 从语言层面提升了性能, 提高了内存与时间上的效率.</p>

<p>在 C++03 及之前的标准中, 临时对象 (称为右值 &ldquo;R-values&rdquo;, 位于赋值运算符之右) 无法被改变, 在 C 中亦同 (且被视为无法和 const T&amp; 做出区分). 虽然在某些情况下临时对象的确会被改变, 甚至也被视为是一个有用的漏洞.</p>

<p>C++11 增加一个新的非常数引用 (reference) 类型, 称作右值引用 (R-value reference), 标记为 <code>T&amp;&amp;</code>. 右值引用所引用的临时对象可以在该临时对象被初始化之后做修改, 这是为了允许 move 语义.</p>

<p>C++03 性能上被长期被诟病的其中之一, 就是其耗时且不必要的深度拷贝. 深度拷贝会发生在当对象是以传值的方式传递. 举例而言, <code>std::vector&lt;T&gt;</code> 是内部保存了 C-style 数组的一个包装, 如果一个 <code>std::vector&lt;T&gt;</code> 的临时对象被建构或是从函数返回, 要将其存储只能通过生成新的 <code>std::vector&lt;T&gt;</code>并且把该临时对象所有的数据复制进去. 该临时对象和其拥有的內存会被摧毁. (为了讨论上的方便，这里忽略返回值优化)</p>

<p>在 C++11 中, 一个 <code>std::vector</code> 的 &ldquo;move 构造函数&rdquo; 对某个 vector 的右值引用可以单纯地从右值复制其内部 C-style 数组的指针到新的 vector, 然后留下空的右值. 这个操作不需要数组的复制, 而且空的临时对象的析构也不会摧毁内存. 传回 vector 临时对象的函数不需要显式地传回 <code>std::vector&lt;T&gt;&amp;&amp;</code>. 如果 vector 没有 move 构造函数, 那么复制构造函数将被调用, 以 <code>const std::vector&lt;T&gt; &amp;</code> 的正常形式. 如果它确实有 move 构造函数, 那么就会调用 move 构造函数, 这能够免除大幅的内存配置.</p>

<p>基于安全的理由, 具名的参数将永远不被认定为右值, 即使它是被如此声明的; 为了获得右值必须使用 <code>std::move&lt;T&gt;()</code>.</p>

<p>```cpp
bool is_r_value(int &amp;&amp;) { return true; }
bool is_r_value(const int &amp;) { return false; }</p>

<p>void test(int &amp;&amp; i)
{</p>

<pre><code>is_r_value(i); // i 为具名变量，即使被声明成右值也不會被认为是右值。
is_r_value(std::move&lt;int&amp;&gt;(i)); // 使用 std::move&lt;T&gt;() 取得右值。
</code></pre>

<p>}
```</p>

<p>由于右值引用的用语特性以及对于左值引用 (L-value references;regular references) 的某些用语修正, 右值引用允许开发者提供完美转发 (perfect function forwarding). 当与变长参数模板结合, 这项能力允许函数模板能够完美地转送引数给其他接受这些特定引数的函数. 最大的用处在于转发构造函数参数, 创造出能够自动为这些特定引数调用正确建构式的工厂函数 (factory function).</p>

<h2>参考</h2>

<ul>
<li><a href="http://blog.csdn.net/pongba/article/details/1684519">《C++0x漫谈》系列之：右值引用(或“move语意与完美转发”)(上)</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/C%2B%2B11#.E5.8F.B3.E5.80.BC.E5.BC.95.E7.94.A8.E5.92.8C_move_.E8.AA.9E.E6.84.8F">维基百科C++11: 右值引用和 move 语义</a></li>
<li><a href="http://stackoverflow.com/questions/3106110/what-are-move-semantics/3109981">Stackoverflow：What are move semantics？</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics">标准文档提案：Move Semantics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 泛型编程之 SFINAE]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/25/cpp-template-sfinae/"/>
    <updated>2013-06-25T23:01:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/25/cpp-template-sfinae</id>
    <content type="html"><![CDATA[<h2>什么是 SFINAE?</h2>

<p>(Substitution Failure Is Not An Error) 匹配失败不是错误. 它可以从一组重载函数中剪裁掉不需要的模板实例.</p>

<p>SFINAE 是 C++ 模板的一个特性, 这个特性在 std::enable_if 中使用的非常广泛. 模板参数推导过程中, C++ 编译器会试图实例化一些候选的函数签名, 以确保函数调用时模板的精确匹配, 当找到一个不合适的匹配时(例如无效的参数或范围值), 则会将这个不合适的匹配从重载决议中删除, 而不是产生一个编译错误. 如果有且只有一个函数的话, 才会产生一个编译错误.</p>

<p>考虑下面的简单的乘法计数器</p>

<p>```cpp
long multiply(int i, int j) { return i * j; }</p>

<p>template <class T>
typename T::multiplication_result multiply(T t1, T t2)
{
  return t1 * t2;
}</p>

<p>int main(void)
{
  multiply(4,5);
  return 0;
}
```</p>

<p>在 main 函数中的函数调用 multiply, 会导致编译器对模板参数的实例化, 虽然第一个非模板函数 multiply 明显是一个更佳的匹配. 在实例化的过程中, 会产生一个非法的类型 int::multiplication_result. 根据 SFINAE, 这个非法的实例化会被自动丢弃. 最终, 非模板的 multiply 会被调用. 编译通过.</p>

<!-- more -->


<h2>SFINAE 的应用</h2>

<p>SFINAE 通常被用作编译时期的类型属性检查. 比如下面的 is_pointer 元函数, 它可以在编译期检查参数类型是否是一个指针.</p>

<p>```cpp
template <typename T>
struct is_pointer
{
  template <typename U>
  static char is_ptr(U *);</p>

<p>  template <typename X, typename Y>
  static char is_ptr(Y X::*);</p>

<p>  template <class U>
  static char is_ptr(U (*)());</p>

<p>  static double is_ptr(&hellip;);</p>

<p>  static T t;
  enum { value = sizeof(is_ptr(t)) == sizeof(char) };
};</p>

<p>struct Foo {
  int bar;
};</p>

<p>int main(void)
{
  typedef int * IntPtr;
  typedef int Foo::<em> FooMemberPtr;
  typedef int (</em>FuncPtr)();</p>

<p>  printf(&ldquo;%d\n&rdquo;,is_pointer<IntPtr>::value);         // prints 1
  printf(&ldquo;%d\n&rdquo;,is_pointer<FooMemberPtr>::value);  // prints 1
  printf(&ldquo;%d\n&rdquo;,is_pointer<FuncPtr>::value);        // prints 1
  return 0;
}
```</p>

<p>如果没有 SFINAE 的话, 元函数 is_pointer 是无法正常工作的. 在 is_pointer 中, 有四个模板函数 is_ptr, 其中三个都会返回一个 char, 这是经过精心设计的. 这三个分别接收不同的参数类型, 一个接受指针变量, 一个接受一个成员指针, 以及一个简单的函数指针类型. 最后一个 is_ptr 是接收任意类型的(使用了省略号), 它的返回值类型是 double, 它的大小始终会大于 char 类型.</p>

<p>当传递一个指针类型(例如上面的 IntPtr)给 is_pointer 时, value 的值将会初始化为 true (因为 sizeof 两边是相等的). 第一个 sizeof 表达式调用 is_ptr, 如果它是一个指针类型, 那么只有一个模板的重载版本会匹配. 根据 SFINAE, 编译不会报错，因为至少有一个函数被匹配上了.  如果没有合适的实例化版本, 那么会选择那个省略号的版本. 不过那个版本会返回 double 类型, 会导致 value 值被初始化为 false (因为 sizeof(double) != sizeof(char)).</p>

<p>需要注意的是, is_ptr 只有声明, 没有定义. 因为声明足以引发 SFINAE 规则, 但是这些必须都是模板函数。一个模板类的非模板函数是不会参与 SFINAE 的, 只有模板函数才会遵循 SFINAE 规则.</p>

<p>在标准库中, 有大量的 SFINAE 应用, 比如 type traits. 有了 SFINAE 我们就可以根据自己的需求, 为我们所关心的特定类型, 写相应的函数重载函数版本, 也可以在编译期判断类型是否符合我们的需求.</p>

<h2>参考</h2>

<ul>
<li>Wikipedia：<a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">Substitution failure is not an error</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 多线程, std::future & std::promise]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/14/cpp11-multithread-promise-future/"/>
    <updated>2013-06-14T22:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/14/cpp11-multithread-promise-future</id>
    <content type="html"><![CDATA[<p>C++11 中最让人高兴的新特性中线程库的支持一定榜上有名. C++11 中提供了 future 和 promise 来简化任务线程间的返回值操作; 同时为启动任务线程提供了 <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">packaged_task</a> 以方便操作.</p>

<h2>std::packaged_task</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a> 可以包装任何可调用的对象(函数, lambda 表达式, std::bind, 或其他函数对象), 以便异步调用, 调用结果保存在 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中, 可以通过成员函数 get_future 访问. 需要注意的是, <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a> 是不可拷贝的(move only).</p>

<p>示例代码</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include <cmath></h1>

<h1>include <thread></h1>

<h1>include <future></h1>

<h1>include <functional></h1>

<p>void task_lambda()
{</p>

<pre><code>std::packaged_task&lt;int(int,int)&gt; task([](int a, int b) {
    return std::pow(a, b); 
});
std::future&lt;int&gt; result = task.get_future();
task(2, 9);
std::cout &lt;&lt; "task_lambda:\t" &lt;&lt; result.get() &lt;&lt; '\n';
</code></pre>

<p>}</p>

<p>void task_bind()
{</p>

<pre><code>std::packaged_task&lt;int()&gt; task(std::bind(std::pow, 2, 11));
std::future&lt;int&gt; result = task.get_future();
task();
std::cout &lt;&lt; "task_bind:\t" &lt;&lt; result.get() &lt;&lt; '\n';
</code></pre>

<p>}</p>

<p>void task_thread()
{</p>

<pre><code>std::packaged_task&lt;int(int,int)&gt; task(std::pow);
std::future&lt;int&gt; result = task.get_future();
std::thread task_td(std::move(task), 2, 10);
task_td.join();
std::cout &lt;&lt; "task_thread:\t" &lt;&lt; result.get() &lt;&lt; '\n';
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>task_lambda();
task_bind();
task_thread();
</code></pre>

<p>}
```</p>

<!-- more -->


<p>仅仅有 packaged_task 还远远不够, 我们还需要更强大的 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 和 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a>.</p>

<p>基本思路很简单: 当一个任务需要向父线程(启动它的线程)返回值时, 它把这个值放到 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 中. 之后, 这个返回值会出现在和此 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 关联的 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 中.于是父线程就能读到返回值. 更简单点的方法, 参看 <a href="http://en.cppreference.com/w/cpp/thread/async">async()</a>.</p>

<p>如果我们有一个 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> f, 通过 get() 可以获得它的值:</p>

<p><code>cpp
X v = f.get();  // if necessary wait for the value to get computed
</code></p>

<p>如果它的返回值还没有到达, 调用线程会进行阻塞等待. 要是等啊等啊, 等到花儿也谢了的话, get() 会抛出异常的(从标准库或等待的线程那个线程中抛出).</p>

<p>如果我们不需要等待返回值(非阻塞方式), 可以简单询问一下 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a>, 看返回值是否已经到达:</p>

<p>```cpp
if (f.wait_for(0))  {</p>

<pre><code>// there is a value to get()
// do something
</code></pre>

<p>} else {</p>

<pre><code>// do something else
</code></pre>

<p>}
```</p>

<p>但是 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 最主要的用途是一个简单的获取返回值的方法: get().</p>

<p><a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 的主要用途是提供一个 &ldquo;put"（或"get"，随你）操作, 以和 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 的 get() 对应.</p>

<p><a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 为 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 传递的结果类型有 2 种: 传一个普通值或者抛出一个异常</p>

<p>```cpp
try {</p>

<pre><code>X res; 
// compute a value for res
p.set_value(res);
</code></pre>

<p>} catch (&hellip;) {   // oops: couldn&rsquo;t compute res</p>

<pre><code>p.set_exception(std::current_exception()); 
</code></pre>

<p>}
```</p>

<p>到目前为止还不错, 不过我们如何匹配 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> / <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 对呢? 一个在我的线程, 另一个在别的啥线程中吗? 是这样: 既然 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 和 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 可以被到处移动(不是拷贝), 那么可能性就挺多的. 最普遍的情况是父子线程配对形式, 父线程用 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 获取子线程 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 返回的值. 在这种情况下, 使用 <a href="http://en.cppreference.com/w/cpp/thread/async">async()</a> 是很优雅的方法.</p>

<h2>std::promise</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 提供一个存储设施, 当一个异步任务通过 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 来获取结果时, <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 可以提供.</p>

<h2>std::future</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 提供了一种机制来访问异步操作的结果:
由 <a href="http://en.cppreference.com/w/cpp/thread/async">std::async</a>, <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a>, 或者 <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 创建的异步操作, 可以提供一个 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 对象, 给创建者, 用来访问异步操作的结果.</p>

<p>异步操作的创建者, 可以使用各种不同的操作来查询, 等待, 或者从 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中取到异步操作的结果. 如果异步操作还没有执行完的话, 这些操作有可能会阻塞.
当一个异步操作完成时可以通过更改(例如使用 <code>std::promise::set_value</code>) 共享状态(该状态保存在 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中) 将结果返回给异步操作的创建者.</p>

<p>示例代码</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include <future></h1>

<h1>include <thread></h1>

<p>int main()
{</p>

<pre><code>// future from a packaged_task
std::packaged_task&lt;int()&gt; task([](){ return 7; }); // wrap the function
std::future&lt;int&gt; f1 = task.get_future();  // get a future
std::thread(std::move(task)).detach(); // launch on a thread
// future from an async()
std::future&lt;int&gt; f2 = std::async(std::launch::async, [](){ return 8; });
// future from a promise
std::promise&lt;int&gt; p;
std::future&lt;int&gt; f3 = p.get_future();
std::thread([](std::promise&lt;int&gt;&amp; p){ p.set_value(9); },
             std::ref(p)).detach();
std::cout &lt;&lt; "Waiting..." &lt;&lt; std::flush;
f1.wait();
</code></pre>

<p>   f2.wait();</p>

<pre><code>f3.wait();
std::cout &lt;&lt; "Done!\nResults are: "
          &lt;&lt; f1.get() &lt;&lt; ' ' &lt;&lt; f2.get() &lt;&lt; ' ' &lt;&lt; f3.get() &lt;&lt; '\n';
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/thread">Cppreference：Thread support library</a></li>
<li><a href="http://en.wikipedia.org/wiki/Futures_and_promises">wikipedia: futures and promises</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++14 std::optional<T>]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/04/cpp14-optional/"/>
    <updated>2013-06-04T01:54:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/04/cpp14-optional</id>
    <content type="html"><![CDATA[<p>C++11已经发布将近2年时间, 各编译器也陆续有了较好的支持. C++14 也已经有相当多的提案被接受, 包括 std::optional, 泛型 lambda, make_unique, 动态数组等, 肯定会出现在下一个标准中. 关于新标准中的提案, 以及已经被接受的提案，详细信息可以参考, wikipedia：<a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14</a>, 以及 open-std 中的 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">C++ 标准草案</a>.</p>

<h2>“无意义”的值</h2>

<p>函数并不总能返回有效的返回值, 很多时候函数可能返回"无意义"的值, 这不意味着函数执行失败, 而是表明函数正确执行了, 但结果却不是有用的值.
表示返回值无意义最常用的做法是增加一个"哨兵"的角色, 它位于解空间之外, 比如 <code>NULL, -1, EOF, std::string::npos, vector::end()</code>等. 但这些做法不够通用, 而且很多时候不存在解空间之外的"哨兵".</p>

<h2>std::optional<T></h2>

<p>optional 库使用"容器"语义, 包装了"可能产生无效值"的对象, 实现了"未初始化"的概念. (在新标准未正式发布之前，可以参考 <a href="http://www.boost.org/doc/libs/1_54_0/libs/optional/doc/html/index.html">boost::optional</a> 的实现.)</p>

<p>optional 使用"容器"语义, 为这种"无效值"的情形提供了一个较好的解决方案. 它很像一个仅能存放一个元素的容器, 它实现了"未初始化"的概念: 如果元素未初始化, 那么容器就是空的, 否则, 容器内就是有效的, 已经初始化的值.</p>

<!-- more  -->


<h2>操作函数</h2>

<p>optional 的模板类型参数 T 可以使任何类型， 就如同一个标准容器对元素的要求, 并不需要T具有缺省构造函数, 但必须是可拷贝构造的.
optional 采用了指针语义来访问内部保存的元素, 这使得 optional 未初始化时的行为就像一个空指针. 它重载了 <code>operator*</code> 和 <code>operator-&gt;</code> 以实现与指针相同的操作, <code>get()</code> 和 <code>get_ptr()</code> 可以以函数的操作形式获得元素的引用和指针. 成员函数 <code>get_value_or(default)</code> 是一个特别的访问函数, 可以保证返回一个有效的值, 如果 optional 已初始化, 那么返回内部的元素, 否则返回 default. optional 也可以用隐式类型转换进行 bool 测试(用于条件判断), 就像一个对指针的判断. optional 还全面支持比较运算，包括 <code>==, !=, &lt;, &lt;=, &gt;, &gt;=</code>. (详细接口参考 <a href="http://en.cppreference.com/w/cpp/utility/optional">cppreference: std::optional</a>)</p>

<h2>用法</h2>

<p>optional 的接口简单明了, 把它认为是一个大小为 1 并且行为类似指针的容器就可以了, 或者把它想象成是一个类似 scoped_ptr, shared_ptr 的智能指针(注意, optional 不是智能指针, 用法类似但用途不同).</p>

<p>```cpp</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<h1>include &ldquo;boost/optional.hpp&rdquo;</h1>

<h1>include &ldquo;boost/lexical_cast.hpp&rdquo;</h1>

<p>// converts int to string if possible
boost::optional<int> str2int(const std::string&amp; str)
{
  boost::optional<int> i;
  try {</p>

<pre><code>i = boost::lexical_cast&lt;int&gt;(str);
</code></pre>

<p>  } catch (boost::bad_lexical_cast&amp;) {</p>

<p>  }
  return i;
}</p>

<p>int get_int_form_user()
{
  std::string s;
  for (;;) {</p>

<pre><code>std::cin &gt;&gt; s;
boost::optional&lt;int&gt; o = str2int(s); // 'o' may or may not contain an int
if (o) {                                 // does optional contain a value?
  return *o;                             // use the value
}
</code></pre>

<p>  }
}</p>

<p>int main()
{
  std::cout &lt;&lt; get_int_form_user();
  return 0;
}
```</p>

<p>如上面的代码所示: 使用 optional, 非法的 int 类型, 就不需要定义一个特别的错误码作为无意义值了.</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/utility/optional">cppreference.com: optional</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">A proposal to add a utility class to represent optional objects (Revision 4)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
