<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bitdewy]]></title>
  <link href="http://bitdewy.github.com/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2015-01-26T23:04:22+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[git tutorial]]></title>
    <link href="http://bitdewy.github.com/blog/2015/01/26/git-tutorial/"/>
    <updated>2015-01-26T23:00:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2015/01/26/git-tutorial</id>
    <content type="html"><![CDATA[<iframe src="https://onedrive.live.com/embed?cid=DABFBDF91EE62075&resid=DABFBDF91EE62075%212829&authkey=APhlgwTfPvXcvCg&em=2" width="800" height="651" frameborder="0" scrolling="no"></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lua tutorial]]></title>
    <link href="http://bitdewy.github.com/blog/2014/12/16/lua-tutorial/"/>
    <updated>2014-12-16T23:34:52+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/12/16/lua-tutorial</id>
    <content type="html"><![CDATA[<iframe src="https://onedrive.live.com/embed?cid=DABFBDF91EE62075&resid=DABFBDF91EE62075%212133&authkey=ACSTWl1GIzIC9IE&em=2" width="800" height="651" frameborder="0" scrolling="no"></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 5: Prefer auto to explicit type declarations.]]></title>
    <link href="http://bitdewy.github.com/blog/2014/11/12/emcpp-item-5/"/>
    <updated>2014-11-12T15:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/11/12/emcpp-item-5</id>
    <content type="html"><![CDATA[<p>看下面的声明，很和谐</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>等等，擦. 忘记初始化了，所以它的值是不确定的。也许，它可能会被初始化成 0。但是很遗憾这是不确定的。</p>

<p>再看看，解引用一个迭代器来初始化局部变量的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>  <span class="c1">// algorithm to dwim (&quot;do what I mean&quot;)</span>
</span><span class='line'><span class="kt">void</span> <span class="n">dwim</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">)</span>   <span class="c1">// for all elements in range from</span>
</span><span class='line'><span class="p">{</span>                       <span class="c1">// b to e</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">currValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'>      <span class="c1">// ...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>呃，用 <code>typename std::iterator_traits&lt;It&gt;::value_type</code> 来表示迭代器所指向的值？这样真的没问题嚒？</p>

<p>再来，如果我们想要一个闭包类型的局部变量。哦，好吧。只有编译器才知道这个闭包是什么类型，我们根本无法写出这个类型。</p>

<p>擦，擦，擦。C++ 写起来还真是头疼。没错，不过那都是过去了。有了 C++11 之后，这些问题都不存在了，我们有了 <code>auto</code>。<code>auto</code> 类型会根据初始化自动推导，所以它们必须被初始化。这意味着在现代 C++ 中你可以和那些变量未初始化的问题挥手说拜拜了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x1</span><span class="p">;</span>        <span class="c1">// potentially uninitialized</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x2</span><span class="p">;</span>       <span class="c1">// error! initializer required</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// fine, x&#39;s valye is well-defined</span>
</span></code></pre></td></tr></table></div></figure>


<p>迭代器解引用初始化局部变量也可以这么来写了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>  <span class="c1">// as before</span>
</span><span class='line'><span class="kt">void</span> <span class="n">dwim</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">currValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'>      <span class="c1">// ...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>由于 <code>auto</code> 类型推导（Item 2），它也可以表示那些只有编译器才知道的类型了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">derefUPLess</span> <span class="o">=</span>                         <span class="c1">// comparison func.</span>
</span><span class='line'>  <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">p1</span><span class="p">,</span>    <span class="c1">// for Widgets</span>
</span><span class='line'>     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">p2</span><span class="p">)</span>    <span class="c1">// pointed to by</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span> <span class="p">};</span>                   <span class="c1">// std::unique_ptrs</span>
</span></code></pre></td></tr></table></div></figure>


<p>很酷吧。C++14 更牛逼了，lambda 可以用 auto 类型的参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">derefUPLess</span> <span class="o">=</span>          <span class="c1">// C++14 comparison</span>
</span><span class='line'>  <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span>        <span class="c1">// function for</span>
</span><span class='line'>     <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>        <span class="c1">// values pointed</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span> <span class="p">};</span>    <span class="c1">// to by anything pointer-like</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管很酷，但你也许会想我们不需要使用 auto 来声明一个闭包，我们有 <code>std::function</code>。是的，可以，但是这也许会和你想的不太一样。现在你可能会想 <code>std::function</code> 对象到底是什么？接下来我们把这个问题讨论清楚。</p>

<p><code>std::function</code> 是 C++11 标准库中的模板类，是函数指针的升级版。函数指针只能指向函数，而 <code>std::function</code> 对象可以表示任何可调用的对象，即任何可以像函数一样调用的对象。就像你必须给函数指针声明一个明确类型一样（类型签名必须与想要调用的函数类型一致），你必须明确 <code>std::function</code> 对象所涉及到的类型。也就是 <code>std::function</code> 的模板参数。举个例子，你想要声明一个 <code>std::function</code> 对象 <code>func</code> 它可以调用如下签名的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span><span class="p">,</span>    <span class="c1">// C++11 signature for</span>
</span><span class='line'>   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span><span class="p">)</span>    <span class="c1">// std::unique_ptr&lt;Widget&gt;</span>
</span><span class='line'>                                      <span class="c1">// comparison function</span>
</span></code></pre></td></tr></table></div></figure>


<p>你需要这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于 lambda 表达式生成可一个可调用的对象，那么闭包可以存在一个 <code>std::function</code> 对象中。也就是说在 C++11 中， 不使用 auto 我们可以像下面这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">derefUPLess</span>
</span><span class='line'>    <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>但一定要明白，即使我们显示的给出了参数类型，但 <code>std::function</code> 与 <code>auto</code> 也不完全一样。用 <code>auto</code> 类型来接受一个闭包，它的类型与实际类型是一致的，内存的占用也是完全一样的。而用 <code>std::function</code> 来接受一个闭包，那么对于给定的签名，内存占用是固定的。而这个大小可能不足以存储该闭包，这个时候 <code>std::function</code> 的构造函数会在堆上分配足够的内存来存储这个闭包。也就是说，通常情况下 <code>std::function</code> 对象会比 <code>auto</code> 对象使用更多的内存。同时会阻止函数内连，让函数调用多一个间接层，通过 <code>std::function</code> 来调用一个闭包集合总是要比 auto 声明的闭包要慢。换句话说，<code>std::function</code> 通常都会比 <code>auto</code> 更大，更慢，而且还可能抛出 <code>out-of-memory</code> 异常。另外，像上面的例子，<code>auto</code> 会比完整类型更简洁。总之，当需要持有一个闭包时，<code>auto</code> 是比 <code>std::function</code> 更好的选择。（另外还有一个类似的东西是 <code>std::bind</code>，同样的也是选择使用 <code>auto</code> 而不是 <code>std::function</code>，不过，在 Item 34 中，我会尽力说服你用 lambda 表达式来代替 <code>std::bind</code>）。</p>

<p><code>auto</code> 除了能避免未初始化变量，显式声明，直接保存闭包。另一个时可以避免 “短类型”，下面是你曾经可能见到过的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">usigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>v.size()</code> 的正确类型是 <code>std::vector&lt;int&gt;::size_type</code>，但是很少有程序员意识到它。<code>std::vector&lt;int&gt;::size_type</code> 内部实现的确是无符号类型，因此很多程序员使用 <code>unsigned</code> 写出了上面的代码。这会产生有趣的结果。在 32 位 Windows 上，<code>unsigned</code> 与 <code>std::vector&lt;int&gt;::size_type</code> 类型完全一致，但是在 64 位 Windows 上，<code>unsigned</code> 是 32 位，而 <code>std::vector&lt;int&gt;::size_type</code> 却是 64 位。这意味着那些在 32 位机器上运行正常的代码可能在 64 位机器上产生错误，另外当将你的程序从 32 位移植到 64 位机器上时，谁愿意花时间在这些问题上呢？</p>

<p>如果使用 <code>auto</code> 就可以不必理会这个问题了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="c1">// sz&#39;s type is std::vector&lt;int&gt;::size_type</span>
</span></code></pre></td></tr></table></div></figure>


<p>还不确定 <code>auto</code> 够不够好嚒？考虑下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unorderd_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ...    do something with p</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来很完美？但是这是有问题的，你看发现了吗？</p>

<p>要意识到 <code>std::unorderd_map</code> 的 key 类型是 const，因此散列表（<code>std::unordered_map</code>） 的元素类型 不是 <code>std::pair&lt;std::string, int&gt;</code> 而是 <code>std::pair&lt;const std::string, int&gt;</code>。但是这与上面代码中 <code>p</code> 的类型不符。因此，编译器会将 <code>std::pair&lt;const std::string, int&gt;</code> 对象转换为 <code>std::pair&lt;std::string, int&gt;</code> 对象。这会拷贝 m 的每个元素，然后将临时对象绑定到 p。在每次循环迭代的最后临时对象会释放。如果你写了上面的代码，你一定会被上面的行为惊到，因为你的意图仅仅是将 p 引用到 m 的每个元素上而已。</p>

<p>像这样的误用，我们也可以用 <code>auto</code> 解决：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// ...  as before</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这不仅是高效的，而且写起来也更方便。还不仅如此，如果你想要取 p 的地址，你会取到 m 中的元素的指针。在没有使用 <code>auto</code> 的代码中，你取到的是临时对象的指针 —— 它会在当此循环结束时销毁。</p>

<p>最后两个例子 —— 使用 <code>unsinged</code> 代替 <code>std::vector&lt;int&gt;::size_type</code> 以及 <code>std::pair&lt;std::string, int&gt;</code> 代替 <code>std::pair&lt;const std::string, int&gt;</code> —— 展示了明确类型会导致的那些你不想要的隐式转换。如果你使用 <code>auto</code> 就不用担心声明的类型与表达式实际类型不一致的问题了。</p>

<p>还有很多使用 <code>auto</code> 类型的理由。虽然 <code>auto</code> 是不完美的。<code>auto</code> 类型是根据初始化的表达式类型自动推导的，而有时候自动退到出的类型不是我们期待的类型。这种情况我们在 Item 2 与 6 中讨论。在这里，我们把注意力转移到另外一个问题上，你可能会有用 <code>auto</code> 代替传统的类型声明的问题：源代码可读性问题。</p>

<p>首先，做一次深呼吸，放松一下。<code>auto</code> 只是一种选择，而不是强制的任务。如果在你有专业的判断，使用显式类型的声会更清晰和更容易维护或以某种其他方式更好地通过，你可以自由地继续使用它们。C++ 没有采用什么新的东西，而只是运用早已被大家所熟知的类型推断而已。其他静态语言 (比如 C#, D, Scala, Visual Basic) 或多或少的都包含这种特性，更不用说静态类型的函数式语言(比如 ML, Haskell, OCaml, F# 等)了。这也归功于那些几乎从不明确类型的动态语言 Perl， Python，Ruby 的成功。软件开发社区在使用类型推断方面有着丰富的经验，它显示了这种技术与创建和维护大型、 工业强度的代码是有没有矛盾的。</p>

<p>一些开发者可能会由于无法在阅读代码时第一时间知道对象类型而感到不安。不过，IDE 通常都有办法展示出对象的类型来缓解这个问题（Item 4 中我们有提到这个问题），并且在通常情况下一个抽象的类型就可以与一个明确类型一样提供给我们足够的信息。比如，知道一个对象是容器或者计数器或者一个智能指针，而不知道它们的具体类型。如果我们精心挑选了有意义的变量名，那么这些抽象类型的信息就很容易知道了。</p>

<p>事实就是写明确类型往往会引入一些小错误，无论是类型的正确性，还是效率方面。此外，auto 类型在你更改了初始化表达式的时候会自动更改，这意味着你重构代码时一些代码的重构由 auto 代为处理了。举个例子，现在有一个函数的返回值是 <code>int</code> 类型，但不久之后，你发现 <code>long</code> 是个更好的选择，那么哪些用 <code>auto</code> 来接收函数返回值的地方在你下一次编译的时候会自动更新。如果那些代码是明确用 <code>int</code> 类型接收的话，你就需要找到所有那些调用的地方，一个个的更改它们。</p>

<h2>需要记住的</h2>

<ul>
<li><code>auto</code> 变量必须被初始化，它可以有效避免类型不匹配造成的移植性问题与性能问题，可以方便重构，通常也会比明确类型打更少的字。</li>
<li><code>auto</code> 类型的陷阱在 Item 2 与 Item 6 中。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 4: Know how to view deduced types]]></title>
    <link href="http://bitdewy.github.com/blog/2014/11/04/emcpp-item-4/"/>
    <updated>2014-11-04T14:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/11/04/emcpp-item-4</id>
    <content type="html"><![CDATA[<p>如何选择查看类型推导结果的工具依赖于你想在开发的那个阶段查看这个类型信息。下面来介绍三种可能的情况，编辑代码时，编译过程中，以及运行时。</p>

<h3>IDE 编辑器</h3>

<p>当你将鼠标移动到某处代码时，IDE 编辑器通常都会显示出类型（比如，变量，参数，函数的类型等），例如下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">theAnswer</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">theAnswer</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">theAnswer</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>IDE 编辑器应该显示变量 <code>x</code> 的类型是 <code>int</code>，变量 <code>y</code> 的类型是 <code>const int*</code>。</p>

<p>要让上面的情况可以工作，你的代码必须是可编译的，因为编辑器之所以能够提示出变量的类型，是因为已经有足够的信息供它内部的编译器（或者至少是编译器前端）来做类型推导的工作。如果信息不足够供编译器做类型推导的话，那么变量类型是不会提示出来的。</p>

<p>对于像 <code>int</code> 一样的简单类型，IDE 生成的信息通常都是正确的。但是对于更复杂的情况，就像后面我们将看到的一样，IDE 生成的信息也许就不是那么有帮助了。</p>

<h3>编译器诊断</h3>

<p>让编译器提示类型推导的类型的一个有效的办法是，用这个类型构造一个编译失败的错误。编译错误的信息会告诉你这个类型。</p>

<p>考虑之前的例子，我们想看一看 <code>x</code> 和 <code>y</code> 的类型。首先我们声明一个未定义的模板类，它看起来应该是下面这样；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>    <span class="c1">// declaration only for TD;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">TD</span><span class="p">;</span>                <span class="c1">// TD == &quot;Type Displayer&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>企图实例化这个模板会产生错误，因为这个模板类我们根本就没有定义。接下来，想要看 <code>x</code> 和 <code>y</code> 的类型，我们只需要用它们的类型实例化 TD 就可以了；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">TD</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">xType</span><span class="p">;</span>    <span class="c1">// elicit errors containing</span>
</span><span class='line'><span class="n">TD</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">yType</span><span class="p">;</span>    <span class="c1">// x&#39;s and y&#39;s types;</span>
</span><span class='line'>                          <span class="c1">// see Item 3 for info on decltype</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>这里我们使用 变量名+Type 来命名，方便我们从错误信息中找到它。对于上面的代码某些编译器的错误提示是下面这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="nl">error:</span> <span class="n">aggregate</span> <span class="err">&#39;</span><span class="n">TD</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">xType</span><span class="err">&#39;</span> <span class="n">has</span> <span class="n">incomplete</span> <span class="n">type</span> <span class="n">and</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">defined</span>
</span><span class='line'><span class="nl">error:</span> <span class="n">aggregate</span> <span class="err">&#39;</span><span class="n">TD</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*&gt;</span> <span class="n">yType</span><span class="err">&#39;</span> <span class="n">has</span> <span class="n">incomplete</span> <span class="n">type</span> <span class="n">and</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">defined</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外一些编译器提示从形式上来看稍微有些不同：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="nl">error:</span> <span class="err">&#39;</span><span class="n">xType</span><span class="err">&#39;</span> <span class="n">uses</span> <span class="n">undefined</span> <span class="k">class</span> <span class="err">&#39;</span><span class="nc">TD</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="err">&#39;</span>
</span><span class='line'><span class="nl">error:</span> <span class="err">&#39;</span><span class="n">yType</span><span class="err">&#39;</span> <span class="n">uses</span> <span class="n">undefined</span> <span class="k">class</span> <span class="err">&#39;</span><span class="nc">TD</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*&gt;</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然形式稍微有些不同，但是测试过的所有编译器都能给出有用的信息。</p>

<h3>运行时输出</h3>

<p><code>printf</code> 虽然只能在运行时期打印出类型信息（我并不是想推荐你使用 <code>printf</code> 哦~），但是我们可以格式化我们想要输出的内容。现在的问题如何产生适合显示的类型信息字符串。你会想，“不用担心，<code>typeid</code> 和 <code>std::type_info::name</code> 会把我们从这个问题中解救出来”。对于我们要看 <code>x</code> 和 <code>y</code> 的类型信息的需求，你也许会说我们可以写如下的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// display types for</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">y</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// x and y</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码对 <code>x</code> 和 <code>y</code> 使用 <code>typeid</code> 返回一个 <code>std::type_info</code> 对象，然后调用它的 <code>name()</code> 方法，它会返回一个 C 风格的字符串（比如：const char*）来表示类型信息。</p>

<p>调用 <code>std::type_info::name</code> 不能保证一定返回有用的信息。但是编译器的实现会尽量保证信息是有用的。但是这个 <code>有用</code> 的范围就比较模糊了。比如 GNU 和 Clang 编译器的结果是 <code>x</code> 的类型为 &ldquo;i&#8221;，<code>y</code> 的类型为 &#8220;PKi&#8221;。一旦你熟悉了它之后，这些信息都是有用的，&#8221;i&rdquo; 表示的是 <code>int</code>，&#8221;PK&#8221; 表示的是 &ldquo;pointer to const&#8221;。（而且这两个编译器都提供一个工具 c++filt，可以来解码这些经过 mangled 的类型。）微软的编译器给出的输出看起来更清楚一些：<code>x</code> 是 &#8220;int&#8221;，而 <code>y</code> 是 &#8220;int const *&#8221;。</p>

<p>对于 <code>x</code> 和 <code>y</code> 的类型我们都得到了正确的结果，你可能会认为识别类型推导的具体类型的问题已经解决了，但是别高兴的太早，我们来看一个更复杂的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>  <span class="c1">// template function to be called</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">createVec</span><span class="p">();</span>  <span class="c1">// factory function</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="k">auto</span> <span class="n">vw</span> <span class="o">=</span> <span class="n">createVec</span><span class="p">();</span>    <span class="c1">// init vw w/factory return</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vw</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vw</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>        <span class="c1">// call f</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码，调用了一个用户定义类型 <code>Widget</code>，一个标准库容器 <code>std::vector</code>，以及一个 <code>auto</code> 变量 <code>vm</code>，这是一个你想要查看类型信息时更具代表性的一个例子。知道模板参数 <code>T</code> 以及 <code>param</code> 的类型是非常有用的。</p>

<p>使用 <code>typeid</code> 是一个很直白的方法，只需要在函数体中增加一点点代码即可；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;T =     &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>      <span class="c1">// show T</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;param = &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">param</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>  <span class="c1">// show param&#39;s type</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 GNU 和 Clang 编译器上跑一下我们得到如下输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">T</span> <span class="o">=</span>     <span class="n">PK6Widget</span>
</span><span class='line'><span class="n">param</span> <span class="o">=</span> <span class="n">PK6Widget</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于这个两个编译器，我们已经知道 &ldquo;PK&rdquo;  的含义是 &ldquo;pointer to const&#8221;，那么唯一的疑问就是这个神奇的数字 6了。其实很简单，这个 6 就是类名 <code>Widget</code> 的字符个数。所以，编译器告诉我们的就是 <code>T</code> 与 <code>param</code> 的类型都是 <code>const Widget*</code>。</p>

<p>微软的编译器输出如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">T</span> <span class="o">=</span>     <span class="k">class</span> <span class="nc">Widget</span> <span class="k">const</span> <span class="o">*</span>
</span><span class='line'><span class="n">param</span> <span class="o">=</span> <span class="k">class</span> <span class="nc">Widget</span> <span class="k">const</span> <span class="o">*</span>
</span></code></pre></td></tr></table></div></figure>


<p>三家编译器给出了相同的结果，貌似答案是正确的。不过再仔细看看。在模板函数 <code>f</code> 中，<code>param</code> 的声明是 <code>const T&amp;</code>。这就很奇怪了，<code>T</code> 和 <code>param</code> 怎么可能是一样的类型呢。如果 <code>T</code> 是 <code>int</code> 类型，那么 <code>param</code> 的类型应该是 <code>const int&amp;</code> —— 完全不一样的类型。</p>

<p>很遗憾，<code>std::type_info::name</code> 是不可靠的，上面的例子中，三家的编译器给出的 <code>param</code> 的类型都是错的。不过，他们必须，也只能是错的，因为标准中规定了 <code>std::type_info::name</code> 的类型信息要遵循模板函数的传值参数的推导规则。就像 Item 1 中描述的那样，这意味着引用，<code>const</code> 以及 <code>volatile</code> 都会别忽略。这就是为什么 <code>param</code> 的类型 —— <code>const Widget * const &amp;</code> —— 却输出为 <code>const Widget *</code>。首先，引用被忽略掉了，同时指针本身的 <code>const</code> 修饰也被忽略掉了。</p>

<p>同样很遗憾，IDE 的编辑器的提示信息同样是不可靠的 —— 或者说是至少不可用的。比如 <code>T</code> 类型的提示信息在某个 IED 下是下面这样的（我绝对没有做过更改~）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">_Simple_types</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">_Wrap_alloc</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">_Vec_base_types</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">_Alloc</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="o">*</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样的 <code>param</code> 的类型是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">_Simple_types</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个比 <code>T</code> 的类型看起来更短一些，不过中间的 <code>...</code> 可能会迷惑你一阵，直到你意识到这是编辑器在提示你 &ldquo;中间省略的内容与 <code>T</code> 类型一致&rdquo; 为止。运气好的话，你的开发环境可以帮助你来识别类型。</p>

<p>不过如果你更倾向于使用库而不是凭运气的话，你需要知道 <code>std::type_info::name</code> 和 IDE 都是靠不住的，而 Boost TypeIndex 库 (Boost.TypeIndex) 是一个选择。这不是标准库的一部分，也不是 IDE 提供的功能，更不是类似 <code>TD</code> 的模板。Boost 库 (<a href="http://boost.org">boost.org</a>) 是一个跨平台，开源的，并且有一个宽松的许可协议的 C++ 库。</p>

<p>下面我们来看看如何使用 Boost.TypeIndex 来解决我们上面的问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;boost/type_index.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">tyepindex</span><span class="o">::</span><span class="n">type_id_with_cvr</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// show T</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;T =     &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// show param&#39;s type</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;param = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>boost::tyepindex::type_id_with_cvr</code> 接受一个类型参数，并且不会去掉 const，volatile 以及引用修饰 (命名中的 <code>with_cvr</code> 也能说明这一点)。然后构造出了一个 <code>boost::tyepindex::type_index</code> 对象，成员函数 <code>pretty_name</code> 会返回一个可读性很高的 <code>std::string</code>，它的值就是我们所期待的类型信息。</p>

<p>对于这个版本的模板函数 <code>f</code> 的实现，我们再来看看之前的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">createVec</span><span class="p">();</span>  <span class="c1">// factory function</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="k">auto</span> <span class="n">vw</span> <span class="o">=</span> <span class="n">createVec</span><span class="p">();</span>    <span class="c1">// init vw w/factory return</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vw</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vw</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>        <span class="c1">// call f</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 Boost.TypeIndex 时，GNU 和 Clang 编译器输出的信息如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">T</span> <span class="o">=</span>     <span class="n">Widget</span> <span class="k">const</span><span class="o">*</span>
</span><span class='line'><span class="n">param</span> <span class="o">=</span> <span class="n">Widget</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>微软的编译器输出的信息几乎完全一致，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">T</span> <span class="o">=</span>     <span class="k">class</span> <span class="nc">Widget</span> <span class="k">const</span><span class="o">*</span>
</span><span class='line'><span class="n">param</span> <span class="o">=</span> <span class="k">class</span> <span class="nc">Widget</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这下看起来比较完美了，不过要记住，IDE 的编辑器、编译器提示信息以及像 Boost.TypeIndex 这样的库，虽然是有用的，但它们仅仅是帮助你识别类型推导结果的工具。不能代替你理解 Item 1-3 中所讲的类型推导规则。</p>

<h2>需要记住的</h2>

<ul>
<li>类型推导的结果通常可以通过 IDE 编辑器，编译器提示信息，以及 Boost.TypeIndex 库来查看。</li>
<li>一些工具产生的结果可能是没用甚至是不准确的，因此理解 C++ 的类型推导规则仍然是很必要的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 3: Understand decltype]]></title>
    <link href="http://bitdewy.github.com/blog/2014/10/21/emcpp-item-3/"/>
    <updated>2014-10-21T14:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/10/21/emcpp-item-3</id>
    <content type="html"><![CDATA[<p><code>decltype</code> 是一个奇怪的发明。给一个名字或者表达式，<code>decltype</code> 可以告诉你这个名字或者表达式的类型。通常的情况下，他告诉你的都是你预期的。但是偶尔也会有些出人意料。</p>

<p>我们从最典型的情况开始 —— 那些不会让你惊奇的情况。与模板类型推导和 <code>auto</code> 类型推导不同，<code>decltype</code> 通常只是鹦鹉学舌般的返回你传入的名字或表达式的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// decltype(i) is const int</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>    <span class="c1">// decltype(w) is const Widget&amp;</span>
</span><span class='line'>                            <span class="c1">// decltype(f) is bool(const Widget&amp;)</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>               <span class="c1">// decltype(Point::x) is int</span>
</span><span class='line'><span class="p">};</span>                          <span class="c1">// decltype(Point::y) is int</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// decltype(w) is Widget</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="p">{</span>                 <span class="c1">// decltype(f(w)) is bool</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>        <span class="c1">// simplified version of std::vector</span>
</span><span class='line'><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>              <span class="c1">// decltype(v) is vector&lt;int&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>            <span class="c1">// decltype(v[0]) is int&amp;</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是完全没有惊喜？</p>

<!-- more -->


<p>在 C++11 中，<code>decltype</code> 的作用也许就是声明一个返回值类型依赖于模板参数的模板函数。举个例子，假设我们准备写一个以容器 (接受下标操作的) 和索引 <code>index</code> 为参数的函数，验证用户之后返回。返回值的类型与容器下标操作的类型相同。</p>

<p><code>T</code> 类型容器的 <code>operator[]</code> 返回值类型通常是 <code>T&amp;</code>。对于 <code>std::deque</code> 来说，是这个样，对于 <code>std::vector</code> 来说，大部分情况下也是的，不过对于 <code>std::vector&lt;bool&gt;</code> 来说，情况就不一样了，它的返回值不是 <code>bool&amp;</code>。这就是我们要在 Item 6 中讨论的问题。在这里，最重要的是，我们要知道容器的 <code>operator[]</code> 的返回值依赖于容器。</p>

<p><code>decltype</code> 可以让这个问题变得简单，下面的代码展示如何利用 <code>decltype</code> 来计算返回值。它还可以进一步的精简，我们稍后再说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span>  <span class="c1">// works, but requires refinement </span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数名前面的 <code>auto</code> 在类型推导中什么用处都没有。取而代之的是 C++11 的尾随返回值类型 (trailing return type)。函数返回值的类型在函数参数列表之后声明 (在 &ndash;> 符号之后)。尾随返回值类型的好处是，函数的参数可以用于声明返回值类型。在 <code>authAndAccess</code> 中，我们的返回值类型声明用到了参数 <code>c</code> 与 <code>i</code>。如果我们将返回值类型置于函数名前，那么我们就无法使用 <code>c</code> 和 <code>i</code>，因为这时它们还没有声明。</p>

<p>上面的声明中，<code>autoAndAccess</code> 的返回值与我们预期的完全一致，就是容器 <code>Container</code> 的 <code>operator[]</code> 的返回值类型。</p>

<p>C++11 支持单句 <code>lambda</code> 的返回值类型推导，而 C++14 进行了扩展，支持所有 <code>lambda</code> 和函数，包括那些多条语句的。这意味着在上面的例子中，使用 C++14 我们可以省略掉尾随返回值类型，仅仅保留最前面的 <code>auto</code> 即可。在这里，<code>auto</code> 是类型推导的占位符。编译器会根据函数的具体实现来推导函数的返回值类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>    <span class="c1">// C++14, not require</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>            <span class="c1">// return type deduced from c[i]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，在这里返回值类型推导使用的是哪个类型推导规则？模板？ <code>auto</code> ? 还是 <code>decltype</code> ?</p>

<p>也许你会有些惊讶，函数的 <code>auto</code> 返回值类型遵循的是模板类型推导规则。看起来 <code>auto</code> 类型推导规则，在这里是一个更好的选择，不过 <code>auto</code> 类型推导与模板类型推导机会是完全一致的。唯一的区别就是模板类型推导无法推导大括号初始化。</p>

<p>在这里，<code>authAndAccess</code> 的返回值类型推导使用模板类型推导是有问题的，不过 <code>auto</code> 类型推导也是一样存在问题。这里的问题是，我们需要推导的表达式是一个引用。</p>

<p>回想一下之前的讨论，<code>operator[]</code> 对于大多数容器类型 <code>T</code> 来说，返回值类型都是 <code>T&amp;</code>，我们在 Item 1 中已经讨论过了，在模板类型推导时，表达式的引用会被忽略。考虑下这对我们上面的代码意味着什么：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">authAndAccess</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// authenticate user, return d[5], then assign 10 to it; this won&#39;t compile!</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，<code>d[5]</code> 返回类型是 <code>int&amp;</code>，但是 <code>auto</code> 返回值类型推导会将引用忽略掉，变成了 <code>int</code> 类型。而 <code>int</code> 类型作为一个函数的返回值，是一个右值，而上面的代码中企图将 <code>10</code> 赋值给一个右值。这在 C++ 中是禁止的，因此会编译失败。</p>

<p>这个问题是由于我们使用了会忽略引用的模板类型推导。在这里，我们需要的实际上是 <code>decltype</code> 类型推导。它能够保证返回值类型与 <code>c[i]</code> 的类型完全一致。</p>

<p>C++ 将引入新的类型推导规则，<code>decltype</code> 类型推导，在 C++14 中通过标识符 <code>decltype(auto)</code> 来实现。这看起来有些奇怪，但是很好的表达了意图：<code>auto</code> 是要推导的类型，<code>decltype</code> 表明需要遵循 <code>decltype</code> 类型推导规则。现在我们可以把之前的代码改成下面这样了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>    <span class="c1">// C++14, works, but still requires refinement</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在 <code>authAndAccess</code> 的返回值与 <code>c[i]</code> 的类型完全一致了，一般情况下当 <code>c[i]</code> 返回 <code>T&amp;</code> 类型时，<code>authAndAccess</code> 也会返回 <code>T&amp;</code>，而当 <code>c[i]</code> 需要返回一个 object 类型时，<code>authAndAccess</code> 也会返回 object 类型。</p>

<p><code>decltype(auto)</code> 的使用，不仅限于函数返回值类型，当你需要使用 <code>decltype</code> 类型推导规则时，它可以用于声明变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">cw</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">myWiget1</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>    <span class="c1">// auto type deduction:</span>
</span><span class='line'>                       <span class="c1">// myWidget1&#39;s type is Widget</span>
</span><span class='line'>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">myWidget2</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>  <span class="c1">// decltype type deduction:</span>
</span><span class='line'>                                <span class="c1">// myWidget2&#39;s type is const Widget&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>但肯定还有两个问题困扰着你，一个就是上面的代码中提到的优化，我们到现在还没有谈到，现在就让我们来看这个问题。</p>

<p>回头看看我们的 C++14 版本的 <code>authAndAccess</code> 函数声明；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>容器参数的类型是左值引用，这样可以让容器返回元素供调用者修改。但是这意味着这个函数无法接受右值的容器作为参数了，因为右值是无法绑定到左值引用的。</p>

<p>不可否认，传一个右值给 <code>authAndAccess</code> 的场景非常少见。一个右值的容器作为一个临时对象会在函数 <code>authAndAccess</code> 结束时销毁，这意味着容器元素的引用（ <code>authAndAccess</code> 函数的返回值）会失效。但是给 <code>authAndAccess</code> 传入一个临时对象还是有意义的。调用者有时会需要一个容器元素的拷贝的，比如下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">makeStringDeque</span><span class="p">();</span>  <span class="c1">// factory function</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// make copy of 5th element of deque returned</span>
</span><span class='line'><span class="c1">// from makeStringDeque</span>
</span><span class='line'><span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">makeStringDeque</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>支持上面的用法，意味着我们要将原本的函数修改为同时支持左值和右值。重载是可以解决这个问题，但是这样一来我们就需要维护两个函数了。有一种办法可以避免同时维护两个函数，我们可以让函数 <code>authAndAccess</code> 同时支持左值以及右值参数，Item 24 中，我们会详细的介绍全局引用。修改后的 <code>authAndAccess</code> 函数声明如下和：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>          <span class="c1">// c is now a </span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span>  <span class="c1">// universal reference</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的模板中，我们不知道 <code>Container</code> 的类型，同时我们也忽略了 index 对象的类型。对一个未知类型使用值传递会因为不必要的拷贝而造成性能问题，也会有对象切割问题（Item 41），还会被同事吐槽，不过在这里我们只考虑标准库容器的情况（比如，<code>std::string</code>, <code>std::vector</code> 以及 <code>std::deque</code> 的 <code>operator[]</code>），在这里仍然坚持使用值传递。</p>

<p>不过我们还需要更新一下模板函数的实现，根据 Item 25，我们使用 <code>std::forward</code> 把全局引用包起来，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>  <span class="c1">// final C++14 version</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码完全符合我们的需求，不过需要支持 C++14 的编译器。如果你现在还没有支持 C++14 的编译器的话，那就需要一个 C++11 的版本。和 C++14 的版本非常相似，唯一的不同点是我们需要手动的指定返回值类型，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>    <span class="c1">// final C++11 version</span>
</span><span class='line'><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另一个问题 —— 除非你是一个库的作者，不然的话，这种情况基本不可能遇到。</p>

<p>要完全明白 <code>decltype</code> 的行为，你必须了解少数的特殊情况。大多数不值得在本书中讨论，不过我们现在来看一看它们是如何使用的。</p>

<p>对一个变量名使用 <code>decltype</code>，会得到与变量名一致的类型。变量名是一个左值，但是不会影响 <code>decltype</code> 的行为。但对于左值表达式来说，情况就变的复杂了，它会使 <code>decltype</code> 返回左值引用。也就是说，如果一个左值表达式不仅仅是一个变量名，那么对于类型 <code>T</code> 的左值表达式使用 <code>decltype</code>， 它会得到一个 <code>T&amp;</code> 类型。这很少会产生冲突，因为大部分的左值表达式都内含左值引用的限定符。例如返回左值的函数通常返回的都是左值引用。</p>

<p>但是这还是会产生一些不期望的问题，例如，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>x</code> 是变量名，<code>decltype(x)</code> 的类型是 <code>int</code>。但是，使用括号将 <code>x</code> 包起来，情况就不一样了。<code>x</code> 是一个左值， <code>(x)</code> 是一个左值表达式，<code>decltype((x))</code> 的类型是 <code>int&amp;</code>。一个括号改变了 <code>decltype</code> 的类型。</p>

<p>在 C++11 中，这不是大问题，但在 C++14 中，由于支持了 <code>decltype(auto)</code>，这个微不足道的变化会变的影响含漱的返回值类型推导。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f1</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// decltype(x) is int, so f1 returns int</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f2</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>    <span class="c1">// decltype((x)) is int&amp;, so f2 returns int&amp;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，<code>f2</code> 不仅仅只是与 <code>f1</code> 的返回值类型不同，它还返回了一个局部变量的引用。这使得你的代码不知不觉的就产生了未定义行为。</p>

<p>这就是说当你使用 <code>decltype(auto)</code> 时，必须要非常小心。一些非常小的细节就可能会影响 <code>decltype(auto)</code> 的类型推导结果。确定类型推导的结果是否符合你的预期，你需要用到 Item 4 中介绍的技术手段。</p>

<p>与此同时，不要忘记从更高的角度来审视这个问题。<code>decltype</code>（不论是否与 <code>auto</code> 在一起）偶尔会产生让你惊讶的结果，但是它不是一般情况。<code>decltype</code> 通常都会符合你的预期。这对于变量名来说是非常正确的。这种情况下，<code>decltype</code> 就像它们看起来的那样：它推导的结果就是变量声明的类型。</p>

<h2>需要记住的</h2>

<ul>
<li><code>decltype</code> 几乎总是与表达式的类型完全一致。</li>
<li>对于类型为 <code>T</code> 的左值表达式（除了变量名），<code>decltype</code> 的类型为 <code>T&amp;</code>。</li>
<li>C++14 支持 <code>decltype(auto)</code>，与 <code>auto</code> 类似，在初始化的时候推导变量的类型，但是使用 <code>decltype</code> 类型推导规则。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 2: Understand auto type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2/"/>
    <updated>2014-09-18T23:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2</id>
    <content type="html"><![CDATA[<p>如果你已经阅读了 Item 1 模板类型推导，那么你应该已经掌握了 <code>auto</code> 的类型推导，出了下面要讲到的一个不同之外，其他都和 Item 1 完全一致，但是你肯定还有疑问，为什么模板类型推导涉及到了模板，函数以及参数，而 <code>auto</code> 却不涉及这些。</p>

<p>没错，但是这也没什么关系。其实模板类型推导与 <code>auto</code> 类型推导有直接的映射关系。有很直观的转换关系。</p>

<p>在 Item 1 中，我们使用下面的模板函数用来描述模板类型推导，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span> <span class="p">(</span><span class="n">expr</span><span class="p">);</span>    <span class="c1">// call f with some expression</span>
</span></code></pre></td></tr></table></div></figure>


<p>在调用函数 <code>f</code> 时，编译器使用表达式 <code>expr</code> 来推导类型 <code>T</code> 和 <code>ParamType</code>。</p>

<p>当使用 <code>auto</code> 来声明变量时，<code>auto</code> 代替了上面 <code>T</code> 的位置，同时变量的类型就是 <code>ParamType</code> 的类型。看下面的例子会更直观，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，变量 <code>x</code> 的类型标识符就是一个简单的 <code>auto</code>，在</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>中，类型标识符是 <code>const auto</code>，在</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>中，类型标识符是 <code>const auto&amp;</code>。推导上面 <code>x</code>, <code>cx</code> 以及 <code>rx</code> 的类型，编译器所做的事情就像是有一个模板函数一样，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_x</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>           <span class="c1">// conceptual template for deducing x&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_x</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is x&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_cx</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// conceptual template for deducing cx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_cx</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is cx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_rx</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>   <span class="c1">// conceptual template for deducing rx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_rx</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is rx&#39;s type</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>就像刚才说的一样，<code>auto</code> 的类型推导只有一点（一会儿会讲到）不一样之外，其他与模板类型推导完全一致。</p>

<p>Item 1 中根据 <code>ParamType</code> 的类型，把类型推导分了三种情况来处理，在 <code>auto</code> 类型推导时，<code>auto</code> 替代了 <code>ParamType</code>  也同样分为三种情况，</p>

<ul>
<li>情况1：类型标识符是一个指针或者引用，但不是右值引用</li>
<li>情况2：类型标识符是一个全局引用</li>
<li>情况3：类型标识符既不是指针也不是引用</li>
</ul>


<p>我们已经见过了情况1 与情况3 的例子了，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>           <span class="c1">// case 3 (x is neither ptr nor reference)</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">// case 3 (cx isn&#39;t neither)</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// case 1 (rx is a non-universal ref.)</span>
</span></code></pre></td></tr></table></div></figure>


<p>情况2 就像你预期的那样，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">// x is int lvalue, so uref1&#39;s type is int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref2</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>    <span class="c1">// cx is const int and lvalue, so uref2&#39;s type is const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref3</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>    <span class="c1">// 27 is int and rvalue, so uref3&#39;s type is int&amp;&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Item 1 中我们讨论了非引用的数组和函数是如何退化成指针的。在 <code>auto</code> 类型推导中也是一样的，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;R. N. Briggs&quot;</span><span class="p">;</span>    <span class="c1">// name&#39;s type is const char[13]</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">arr1</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>                      <span class="c1">// arr1&#39;s type is const char *</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>                     <span class="c1">// arr2&#39;s type is const char (&amp;)[13]</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>            <span class="c1">// someFunc is function, type is void(int, double)</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">func1</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span>                 <span class="c1">// func1&#39;s type is void(*)(int, double)</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;</span> <span class="n">func2</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span>                <span class="c1">// func2&#39;s type is void(&amp;)(int, double)</span>
</span></code></pre></td></tr></table></div></figure>


<p>就像你看到这样，<code>auto</code> 类型推导就像模板类型推导一样。</p>

<p>仅有一种情况，他们是不一样的。我们从一个简单的例子开始，在 C++98 中，我们用 27 来初始化一个 int 变量，我们可以有下面两种写法，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11 统一初始化，增加了下面的写法，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>总而言之，4中不同的写法的结果都是一样的，初始化了一个值为 27 的整型。</p>

<p>但是，就像 Item 5 中解释的一样，使用 <code>auto</code> 来声明类型是可以获得好处的，所有我们可以将上面的 <code>int</code> 全部替换为 <code>auto</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这 4 种写法都能够正常编译，但是却表达了不同的含义。前两种写法定义了一个值为 27 的整型。但后两种写法实际上定义了一个只有一个元素 27 的 <code>std::initializer_list&lt;int&gt;</code>！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>        <span class="c1">// type is int, value is 27</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>         <span class="c1">// ditto</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>    <span class="c1">// type is std::initializier_list&lt;int&gt;, value is { 27 }</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>       <span class="c1">// ditto</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是 <code>auto</code> 类型推导的一个特殊规则。当使用大括号初始化一个 <code>auto</code> 变量时，类型会被推导为 <code>std::initializer_list</code>，如果类型推导不成功（比如，大括号中的某个元素类型与其他的不一致），那么将会编译失败：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x5</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">};</span>    <span class="c1">// error! can&#39;t deduce T for std::initializer_list&lt;int&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>就像上面注释中写的一样，类型推导在这种情况下会失败，但是要明白这里有两个类型推导，这是很重要的。第一个是 <code>auto</code>，<code>x5</code> 使用了大括号来初始化，那么 <code>auto</code> 会被推导为 <code>std::initializer_list</code> 类型，但同时 <code>std::initializer_list</code> 是一个模板类型，模板参数 <code>T</code> 同样需要推导，类型推导失败产生于第二步：模板类型推导。在上面的例子中，就是由于大括号中的元素类型不一致而导致的模板类型推导失败。</p>

<p><code>auto</code> 类型推导与模板类型推导的唯一不同在于大括号初始化。当使用大括号初始化时，<code>auto</code> 会推到为 <code>std::initializer_list</code> 类型，但对于模板类型推导来说，这会产生一个错误，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>  <span class="c1">// x&#39;s type is std::initializer_list&lt;int&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>         <span class="c1">// template with parameter declaration equivalent to x&#39;s</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">({</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span><span class="p">});</span>         <span class="c1">// error! can&#39;t deduce type for T</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过，如果你明确指定了 <code>param</code> 的类型为 <code>std::initializer_list&lt;T&gt;</code> 那么模板类型推导会推导出 <code>T</code> 的类型，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">initList</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">({</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span> <span class="p">});</span>    <span class="c1">// T deduce as int, and initList&#39;s type is std::initializer_list&lt;int&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，<code>auto</code> 类型推导与模板类型推导唯一的不同在于，对于大括号初始化，<code>auto</code> 类型推导会将它推导为 <code>std::initializer_list</code>，而模板类型推导不会。</p>

<p>也许你会想知道为什么会有这样的区别。我也曾想过，但是没有找到一个很好的解释。不过规则就是规则，你只需要记住，当使用大括号初始化 <code>auto</code> 类型时，它会被自动推到为 <code>std::initializer_list</code> 类型。如果你想要使用新的统一初始化，那么记住这一点是非常重要的。一个典型的 C++11 错误就是当你想要一个其他类型时却意外的声明了一个 <code>std::initializer_list</code> 类型。这也是为什么有些开发者仅仅在必要的时候才使用大括号初始化的一个原因。（我们会在 Item 7 中详细讨论）</p>

<p>对 C++11 来说，这就是全部了。但是对于 C++14，还有些其他内容。C++14 允许使用 <code>auto</code> 来表示需要被推导的函数返回值类型（详见 Item 3），C++14 的 lambda 中也允许 <code>auto</code> 用作参数类型。但是这些 <code>auto</code> 遵循的是模板类型推导，而不是 <code>auto</code> 类型推导。因此，一个返回值类型声明为 <code>auto</code> 返回一个大括号初始化时，会导致编译失败，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">createInitList</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>    <span class="c1">// error: can&#39;t deduce type for { 1, 2, 3 }</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>lambda:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="k">auto</span> <span class="n">resetV</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">v</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">newValue</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span> <span class="o">=</span> <span class="n">newValue</span><span class="p">;</span> <span class="p">};</span>    <span class="c1">// C++14</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'><span class="n">resetV</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">});</span>    <span class="c1">// error! can&#39;t deduce type for { 1, 2, 3 }</span>
</span></code></pre></td></tr></table></div></figure>


<h2>需要记住的</h2>

<ul>
<li><code>auto</code> 类型推导通常和模板类型推导是一致的，但是 <code>auto</code> 类型推导会将大括号初始化推到为 <code>std::initializer_list</code>，而模板类型推导不会</li>
<li><code>auto</code> 在函数返回值以及 lambda 参数类型推导时，遵循模板类型推导，而不是 <code>auto</code> 类型推导。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 1: Understand template type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/08/23/emcpp-item-1/"/>
    <updated>2014-08-23T00:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/08/23/emcpp-item-1</id>
    <content type="html"><![CDATA[<p>在使用一个复杂的系统时，我们可以不用知道具体的细节。从这个方面来说，C++ 的模板类型推导是很成功的。数以百万的程序员都使用过模板，即使他们可能很难描述清楚这些类型是如何推导的。</p>

<p>如果你是其中的一员，我有一个好消息，也有一个坏消息。好消息是，模板类型推导是最引人注目的 C++11 新特性 <code>auto</code> 的基础。如果你很清楚 C++98 中的模板类型推导，那么你会很容易明白 C++11 中的 <code>auto</code>。坏消息是，当使用 <code>auto</code> 时，有些类型推导会变得没有那么直观。因此完全掌握类型推导的规则是非常有必要的。Item 1 会介绍你必须知道的类型推导规则。</p>

<p>我们从一小段伪代码开始：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span> <span class="p">(</span><span class="n">expr</span><span class="p">);</span>    <span class="c1">// call f with some expression</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编译期间，编译器使用表达式 <code>expr</code> 来推导两个类型：一个是 <code>T</code> 另一个是 <code>ParamType</code>。这两个类型通常是不一样的，因为 <code>ParamType</code> 通常是含有修饰的，比如 <code>const</code> 或者引用。举个例子，如果模板的声明如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// ParamType is const T&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>    <span class="c1">// call f with an int</span>
</span></code></pre></td></tr></table></div></figure>


<p>类型 <code>T</code> 会被推导为 <code>int</code>，而 <code>ParamType</code> 被推导为 <code>const int&amp;</code>。</p>

<p>将类型 <code>T</code> 推导为传入的参数类型是很自然的，即 <code>T</code> 的类型就是 <code>expr</code> 的类型。在上面的例子中，<code>x</code> 是 <code>int</code> 类型，<code>T</code> 被推导为 <code>int</code> 类型。但是有时候却不是这样的。类型推导不仅仅依赖于表达式 <code>expr</code> 的类型，同时还依赖于 <code>ParamType</code> 的形式。有下面三种情况：</p>

<ul>
<li>ParamType 是一个指针或者引用类型，但是不是全局引用。（全局引用将会在 Item 24 中讲述。现在你只需要知道他不同于引用，也不同于右值引用即可）。</li>
<li>ParamType 是一个全局引用。</li>
<li>ParamType 即不是指针也不是引用</li>
</ul>


<!-- more -->


<p>因此我们需要考虑上面描述的三种场景来一一讲述。每个都基于下面的伪代码，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>    <span class="c1">// deduce T and ParamType from expr</span>
</span></code></pre></td></tr></table></div></figure>


<h3>情况1：<code>ParamType</code> 是一个指针或者引用，但不是右值引用</h3>

<p>这是最简单的一种情况，在这种情况下，类型推导的工作如下：</p>

<ol>
<li>如果 <code>expr</code> 是一个引用类型，忽略引用部分。</li>
<li>然后模式匹配 <code>expr</code> 的类型，根据 <code>ParamType</code> 的类型来决定 <code>T</code> 的类型。</li>
</ol>


<p>举个例子，如果我们的模板是下面这样，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// param is a reference</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后我们有如下的变量声明，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>           <span class="c1">// x is an int</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">// cx is a const int</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// rx is a reference to x as a const int</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>param</code> 和 <code>T</code> 的类型推导结果如下，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>     <span class="c1">// T is int, param&#39;s type is int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>    <span class="c1">// T is const int, param&#39;s type is const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>    <span class="c1">// T is const int, param&#39;s type is const int&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在第二个以及第三个调用中，注意由于 <code>cx</code> 和 <code>rx</code> 是 <code>const</code> 值，所以 <code>T</code> 被推导为 <code>const int</code> 类型，这对调用者来说是至关重要的。当调用者传入一个 <code>const</code> 对象给一个引用参数时，参数仍然是不可更改的。比如，参数是一个 <code>const</code> 引用。这也是为什么传入一个 <code>const</code> 对象给一个接受 <code>T&amp;</code> 类型的模板参数是安全的：<code>const</code> 约束直接变为了 <code>T</code> 类型的一部分。</p>

<p>在第三个调用中，注意虽然 <code>rx</code> 的类型是引用，<code>T</code> 仍然被推导为非引用。这是由于类型推导过程中 <code>rx</code> 的引用修饰被忽略掉了。</p>

<p>上面的例子都是左值引用参数，但其实右值引用的类型推导和上面是完全一样的。当然，只有右值类型的参数才能传递给右值引用，但他对类型推导完全没有影响。</p>

<p>如果我们将 <code>f</code> 的参数类型由 <code>T&amp;</code> 更改为 <code>const T&amp;</code>，情况会有一些变化，但非常好理解。<code>cx</code> 和 <code>rx</code> 的 <code>const</code> 修饰仍然有用。但由于现在假定 <code>param</code> 的类型是一个 <code>const</code> 引用，现在不再需要将 <code>const</code> 推断为类型 <code>T</code> 的一部分了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// param is now ref-to-const</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>                <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>          <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>         <span class="c1">// as before</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                      <span class="c1">// T is int, param&#39;s type is const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                     <span class="c1">// T is int, param&#39;s type is const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                     <span class="c1">// T is int, param&#39;s type is const int&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>和上面一样，<code>rx</code> 的引用修饰在类型推导时会被忽略。</p>

<p>如果 <code>param</code> 是一个指针（或者 <code>const</code> 指针），类型推导基本是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">param</span><span class="p">);</span>          <span class="c1">// param is now a pointer</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>                <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>        <span class="c1">// px is a ptr to x as a const int</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// T is int, param&#39;s type is int*</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">px</span><span class="p">);</span>                     <span class="c1">// T is const int, param&#39;s type is const int*</span>
</span></code></pre></td></tr></table></div></figure>


<p>到目前位置，你可能已经哈欠不断了，因为对于指针和引用的类型推导，规则这么简单，所有的结果都是显而易见的，就和你想象的完全一样。</p>

<h3>情况2：<code>ParamType</code> 是全局引用</h3>

<p>当模版参数是全局引用时，类型推导就没有那么明显了。声明的形式有点像右值引用（全局引用的类型声明形式是 <code>T&amp;&amp;</code>），但是当传入的参数是左值类型时行为是不一样的。具体细节在 Item 24 中讲述，现在我们来看一个简单的版本：</p>

<ul>
<li>如果 <code>expr</code> 是一个左值，那么 <code>T</code> 和 <code>ParamType</code> 都会推导为左值引用。有两个不寻常的地方。第一，这是仅有的模板类型推导会将类型 <code>T</code> 推导为引用类型的情形。第二，尽管 <code>ParamType</code> 的类型声明使用了右值引用的符号，但却推导为了左值引用。</li>
<li>如果 <code>expr</code> 是一个右值，会使用“正常的”（情况1）规则。</li>
</ul>


<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">tempalte</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>        <span class="c1">// param is now a universal reference</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>               <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>         <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// as before</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// x is lvalue, so T is int&amp;, param&#39;s type is also int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                    <span class="c1">// cx is lvalue, so T is const int&amp;, param&#39;s type is also const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                    <span class="c1">// rx is lvalue, so T is const int&amp;, param&#39;s type is also const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>                    <span class="c1">// 27 is rvalue, so T is int, param&#39;s type is therefore int&amp;&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Item 24 中会详细解释为什么在上面的情形中类型推导是这样的。在这里我们的重点是，左值参数和右值参数对于全局引用来说，类型推导的规则是不一样的。这很特别的，当使用全局引用时，类型推导会区别对待左值参数和右值参数，这是在其他类型中不会发生的。</p>

<h3>情况3：<code>ParamType</code> 即不是引用也不是指针</h3>

<p>当 <code>ParamType</code> 既不是引用也不是指针时，我们来按值传递，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>          <span class="c1">// param is now passed by value</span>
</span></code></pre></td></tr></table></div></figure>


<p>这意味着 <code>param</code> 会做一个拷贝 —— 产生一个全新的对象。<code>param</code> 的类型推导遵循如下规则：</p>

<ol>
<li>像上面一样，如果 <code>expr</code> 的类型是一个引用，那么引用类型会被忽略。</li>
<li>如果忽略了 <code>expr</code> 的引用修饰之后，<code>expr</code> 是一个 <code>const</code>，那么将 <code>const</code> 也忽略。如果有 <code>volatile</code> 修饰，也同样忽略。（<code>volatile</code> 修饰并不常用，通常只是在实现设备驱动时会用到。更多细节，参见 Item 40）。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>              <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>       <span class="c1">// as before</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                    <span class="c1">// T&#39;s and param&#39;s types are both int</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                   <span class="c1">// T&#39;s and param&#39;s types are again both int</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                   <span class="c1">// T&#39;s and param&#39;s types are still both int</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，即使 <code>cx</code> 和 <code>rx</code> 都是 <code>const</code> 类型，<code>param</code> 的类型也不是 <code>const</code>。这是有道理的。<code>param</code> 是一个与 <code>cx</code> 和 <code>rx</code> 无关的对象 —— 是一份拷贝。因此， <code>cx</code> 和 <code>rx</code> 的 <code>const</code> 属性，不会影响 <code>param</code>。这就是为什么在类型推导过程中 <code>expr</code> 的 <code>const</code>（以及 volatile）修饰会被忽略的原因：<code>expr</code> 不可更改并不意味着它的拷贝不可以。</p>

<p>意识到 <code>const</code>（以及<code>volatile</code>）修饰仅仅在传值参数中会被忽略，是非常重要的。像前面看到的，对于 <code>const</code> 引用，或者 指向 <code>const</code> 对象的指针参数，<code>expr</code> 的 <code>const</code> 修饰是保留到类型推导中的。但是考虑以下情况，<code>expr</code> 是一个指向 <code>const</code> 对象的 <code>const</code> 指针，且 <code>expr</code> 是值传递给 <code>param</code> 的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                              <span class="c1">// param is still passed by value</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Fun with pointers&quot;</span><span class="p">;</span>  <span class="c1">// ptr is const pointer to const object</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>                                       <span class="c1">// pass arg of type const char * const</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，右边（第二个）的 <code>const</code> 表示 <code>ptr</code> 不可更改。左边（第一个）表示 <code>ptr</code> 指向的常量字符串不可更改。当 <code>ptr</code> 传递给 <code>f</code> 时，<code>ptr</code> 值传递会产生一个拷贝，根据类型推导规则，<code>ptr</code> 的 <code>const</code> 修饰会被忽略掉，最终 <code>param</code> 类型为 <code>const char*</code>，即指向常量字符串的指针。<code>ptr</code> 所指向的内容的 <code>cosnt</code> 修饰被保留，而 <code>ptr</code> 本身的 <code>const</code> 修饰在值传递时被忽略。</p>

<h4>数组参数</h4>

<p>几乎所有主流的模板类型推导都包含它，但是还是有一些值得注意的地方。数组类型与指针类型是不同的，尽管他们有时可以转换。在很多时候数组是可以退化成指针的。下面的代码可以编译通过：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;J. P. Briggs&quot;</span><span class="p">;</span>   <span class="c1">// name&#39;s type is const char[13]</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptrToName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>         <span class="c1">// array decays to pointer</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，<code>ptrToName</code> 作为一个 <code>const char*</code> 类型，使用了 <code>const char[13]</code> 类型的 <code>name</code> 来初始化。但是这两个类型是不同的，由于数组到指针的退化规则才使得代码能够编译通过。</p>

<p>但当我们将一个数组类型传递给一个值传递的模版参数时，会发生什么呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>               <span class="c1">// template with by-value paramter</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>                       <span class="c1">// what types are deduced for T and param ?</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们使用没有模板的情况先来观察，对，没错，下面的语法是合法的，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">myFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">param</span><span class="p">[]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是数组参数的声明会被退化成指针，这意味着它和下面的声明是完全一致的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">myFunc</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">param</span><span class="p">);</span>     <span class="c1">// same function as above</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的退化是从 C 语言中继承而来的，他给我们造成了数组类型与指针类型是一样的这种幻觉。</p>

<p>由于数组参数的声明会被当作指针来看待，那么当模版参数是数组并且按值传递时，参数会被推导为指针类型。这意味着模板函数 <code>f</code> 的模板参数 <code>T</code> 会被推导为 <code>const char *</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>        <span class="c1">// name is array, but T deduced as const char*</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是现在问题出现了，尽管参数不能是一个真正的数组类型，但是我们可以声明一个数组的引用。因此当我们更改模板函数 <code>f</code> 使他接受引用参数时，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>        <span class="c1">// template with by-reference parameter</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后我们传入有一个数组，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>                 <span class="c1">// pass array of f</span>
</span></code></pre></td></tr></table></div></figure>


<p>类型推导会将 <code>T</code> 推导为数组类型，这个类型包括了数组的长度，在这个例子中，<code>T</code> 的类型被推导成为 <code>const char[13]</code>，函数 <code>f</code> 的参数类型为 <code>const char(&amp;)[13]</code>。</p>

<p>有趣的是，它提供了一种推导数组元素个数的方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// return size of an array as a compile-time constant. (The array parameter has no name,</span>
</span><span class='line'><span class="c1">// because we care only about the number of elements it contains.)</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>                                <span class="c1">// info</span>
</span><span class='line'><span class="n">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="n">noexcept</span>    <span class="c1">// below on</span>
</span><span class='line'><span class="p">{</span>                                                    <span class="c1">// constexpr</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">N</span><span class="p">;</span>                                        <span class="c1">// and</span>
</span><span class='line'><span class="p">}</span>                                                    <span class="c1">// noexcept</span>
</span></code></pre></td></tr></table></div></figure>


<p>与 Item 15 中解释的一样，声明一个 <code>constexpr</code> 函数，那么它的返回值在编译期就确定了。这就让用一个已知的数组去声明一个同样大小的数组成为可能：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">keyVals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">35</span> <span class="p">};</span>    <span class="c1">// keyVals has 7 elements</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">mappedVals</span><span class="p">[</span><span class="n">arraySize</span><span class="p">(</span><span class="n">keyVals</span><span class="p">)];</span>               <span class="c1">// so does mappedVals</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，作为一个现代的 C++ 程序员，你会很自然的习惯于用 <code>std::array</code> 来代替内建的数组类型，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">keyVals</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mappedVals</span><span class="p">;</span>   <span class="c1">// mappedVals&#39; size is 7</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>arraySize</code> 声明时带着 <code>noexcept</code>，这帮助编译器生成更好的代码。详细内容，参见 Item 14。</p>

<h4>函数参数</h4>

<p>在 C++ 中，不是只有数组才会退化成指针。函数类型可以退化成函数指针，上面我们讨论的关于数组的类型推导规则也适用于函数，只是退化成函数指针而已。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>    <span class="c1">// someFunc is a function;</span>
</span><span class='line'>                               <span class="c1">// type is void(int, double)</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>              <span class="c1">// in f1, param passed by value</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>             <span class="c1">// in f2, param passed by ref</span>
</span><span class='line'>
</span><span class='line'><span class="n">f1</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>                  <span class="c1">// param deduced as ptr-to-func;</span>
</span><span class='line'>                               <span class="c1">// type is void (*)(int, double)</span>
</span><span class='line'><span class="n">f2</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>                  <span class="c1">// param deduced as ref-to-func;</span>
</span><span class='line'>                               <span class="c1">// type is void (&amp;)(int, double)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在日常的使用中，这几乎没有什么区别，但是如果你已经知道了数组会退化成指针，那么你也会很自然的知道函数到指针的退化。</p>

<p>这就是模板类型推导的规则。大部分情况下它非常简单。左值在传递给全局引用时的推导有些稍微不同，但是数组和函数类型的退化更让人迷惑。有时候你会想抓住编译器问，“告诉我你在推导什么类型！” 这个时候，你需要 Item 4 中的内容，它会告诉你如何查看正在推导的类型。</p>

<h2>需要记住的</h2>

<ul>
<li>在模板类型推导时，引用类型的参数会被当作非引用，即引用限定会被忽略。</li>
<li>当推导类型是全局引用时，左值会被特殊对待。</li>
<li>当推导值传递参数时，<code>const</code>, <code>volatile</code> 会被忽略。</li>
<li>在类型推导时，数组以及函数名会退化为指针，除非它们被用来初始化引用变量。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Effecticve Modern C++》预览]]></title>
    <link href="http://bitdewy.github.com/blog/2014/07/21/effective-modern-cpp-preview/"/>
    <updated>2014-07-21T22:14:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/07/21/effective-modern-cpp-preview</id>
    <content type="html"><![CDATA[<p>虽然最近工作在用 javascript, 但 C++ 也没放下, <a href="http://www.aristeia.com">Scott Meyers</a> 的新书《Effective modern C++》终于在 O&#8217;Reilly <a href="http://shop.oreilly.com/product/0636920033707.do">上架了</a>. 第一时间买了一本. 2年前的时候, <a href="http://www.aristeia.com">Scott</a> 就给了<a href="http://blog.bitdewy.me/blog/2012/06/24/effective-c-plus-plus-11/">一版</a> Effective C++11 的初步想法, 两年后的今天, 顺带着 C++14 终于正式出炉了, 不过目前还是 early release 版本, 还没有经过 review, 正式版要到年底才会放出.</p>

<p>不得不说, C++ 现在终于有了它该有的样子. 大致浏览了一下, 如果现在才开始关注 C++11/C++14 的话, 非常推荐这本书. 如果看过前两代 《Effective C++》和《More effective C++》的话, 那你会再次找到久违的感觉.</p>

<p>全书共分为 6 章, 包括: 类型推导, 新关键字 auto, C++98 到 C++11/14 的变化, 智能指针, 右值引用转移语义与完美转发, lambda 表达式, 并发 API.</p>

<p>关于类型推导, 由于 C++11/14 引入了新的关键字 <code>auto</code>, <code>decltype</code>, 以及新的概念右值引用, 那么类型推导就不仅仅存在于模板中了, 因此从现在开始掌握类型推导的规则是 C++ 的必备技能了.</p>

<p>C++11/14 和以前相比, 变化非常的大, 在这本书中, 用了近 1/3 的章节来讲述如何从 C++98 过度到 C++11/14. 有些甚至推翻了之前的推荐做法, 比如 Item 13: Prefer const_iterators to iterators 就与作者之前的 《Effective STL》中的 item 26 完全相反. 所以对于每个写 C++ 代码的人来说, 这一部分是必须要更新的知识.</p>

<p>对于智能智能, 相信大家早就不陌生, 作者的《More Effective C++》中也讲到了智能指针. 这一次, 终于成为了标准, 本书中也讲到了各种类型智能指针合适的使用场景, 掌握了这些之后, 相信资源管理的问题, 就能够减少很多了.</p>

<p>转移语义很好的解决了性能问题, 完美转发解决了模板函数重载时爆炸式增长的问题, 而右值引用就是这两个特性的基础. 对于那些写库的人来说, 这些特性真是天大的好事.</p>

<p>关于 lambda 表达式, 有了 lambda 表达式, 标准库中的那些算法终于能变得好用了. 在没有 lambda 之前, 在使用每个标准库算法之前, 还需要一个仿函数, 这是一件多么不爽的事情.</p>

<p>对于并发, 在 C++98 以及之前, 标准连多线程的概念都没有, 我们只能使用平台相关的多线程设施, 甚至一些我们觉得没问题的多线程模型都会在这种情况下出问题. (比如: 这篇<a href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">C++ and the Perils of Double-Checked Locking</a>) 现在标准中不仅有了 thread, 甚至还有了更高级的 task, future, promise. 当然如果能有 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a> 就更好了, 不过这个特性可能要等到 C++17 了.</p>

<!-- more -->


<p>最后放出《effecticve modern C++》的目录</p>

<h4>Chapter 1 Deducing Types</h4>

<ul>
<li>Item 1: Understand template type deduction.</li>
<li>Item 2: Understand auto type deduction.</li>
<li>Item 3: Understand decltype.</li>
<li>Item 4: Know how to view deduced types.</li>
</ul>


<h4>Chapter 2 auto</h4>

<ul>
<li>Item 5: Prefer auto to explicit type declarations.</li>
<li>Item 6: Be aware of the typed initializer idiom.</li>
</ul>


<h4>Chapter 3 From C++98 to C++11 and C++14</h4>

<ul>
<li>Item 7: Distinguish () and {} when creating objects.</li>
<li>Item 8: Prefer nullptr to 0 and NULL.</li>
<li>Item 9: Prefer alias declarations to typedefs.</li>
<li>Item 10: Prefer scoped enums to unscoped enums.</li>
<li>Item 11: Prefer deleted functions to private undefined ones.</li>
<li>Item 12: Declare overriding functions override.</li>
<li>Item 13: Prefer const_iterators to iterators.</li>
<li>Item 14: Use constexpr whenever possible.</li>
<li>Item 15: Make const member functions thread-safe.</li>
<li>Item 16: Declare functions noexcept whenever possible.</li>
<li>Item 17: Consider pass by value for cheap-to-move parameters that are always copied.</li>
<li>Item 18: Consider emplacement instead of insertion.</li>
<li>Item 19: Understand special member function generation.</li>
</ul>


<h4>Chapter 4 Smart Pointers</h4>

<ul>
<li>Item 20: Use std::unique_ptr for exclusive-ownership resource management.</li>
<li>Item 21: Use std::shared_ptr for shared-ownership resource management.</li>
<li>Item 22: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle.</li>
<li>Item 23: Prefer std::make_unique and std::make_shared to direct use of new.</li>
<li>Item 24: When using the Pimpl Idiom, define special member functions in the implementation file.</li>
</ul>


<h4>Chapter 5 Rvalue References, Move Semantics, and Perfect Forwarding</h4>

<ul>
<li>Item 25: Understand std::move and std::forward.</li>
<li>Item 26: Distinguish universal references from rvalue references.</li>
<li>Item 27: Use std::move on rvalue references, std::forward on universal references.</li>
<li>Item 28: Avoid overloading on universal references.</li>
<li>Item 29: Familiarize yourself with alternatives to overloading on universal references.</li>
<li>Item 30: Understand reference collapsing.</li>
<li>Item 31: Assume that move operations are not present, not cheap, and not used.</li>
<li>Item 32: Familiarize yourself with perfect forwarding failure cases.</li>
</ul>


<h4>Chapter 6 Lambda Expressions</h4>

<ul>
<li>Item 33: Avoid default capture modes.</li>
<li>Item 34: Use init capture to move objects into closures.</li>
<li>Item 35: Use decltype on auto&amp;&amp; parameters to std::forward them.</li>
<li>Item 36: Prefer lambdas to std::bind.</li>
</ul>


<h4>Chapter 7 The Concurrency API</h4>

<ul>
<li>Item 37: Prefer task-based programming to thread-based.</li>
<li>Item 38: Specify std::launch::async if asynchronicity is essential.</li>
<li>Item 39: Make std::threads unjoinable on all paths.</li>
<li>Item 40: Be aware of varying thread handle destructor behavior.</li>
<li>Item 41: Consider void futures for one-shot event communication.</li>
<li>Item 42: Use std::atomic for concurrency, volatile for special memory.</li>
</ul>


<p>有时间的话, 后续会持续更新每一章节的具体内容.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript new keyword: yield]]></title>
    <link href="http://bitdewy.github.com/blog/2014/06/29/why-yield/"/>
    <updated>2014-06-29T22:14:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/06/29/why-yield</id>
    <content type="html"><![CDATA[<h2>生成器与迭代器</h2>

<p>在以前写代码的时候, 涉及到迭代算法时, 通常整个过程中都需要维护一个状态变量, 而我们想使用迭代算法的中间值得时候, 不得不使用回调函数.</p>

<p>下面是一个斐波那契数列的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">do_callback</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">fib</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">do_callback</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">j</span> <span class="o">+=</span> <span class="nx">t</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">n</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">fib</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中使用了回调函数, 将小于 10 的斐波那契数列的元素输出到控制台.</p>

<p>迭代器和生成器提供了一个新的, 更好的途径来做同样的事情. 下面是使用生成器实现的代码:</p>

<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="o">*</span><span class="nx">fib</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">yield</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">j</span> <span class="o">+=</span> <span class="nx">t</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">fib</span><span class="p">();</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的 <code>function *fib</code>, 函数体中含有关键字 <code>yield</code> 的函数就是生成器. 当你调用它的时候, 它的形参绑定到实参, 但函数本身并不进行求值, 而是返回一个 <code>generator-iterator</code>, 每调用一次 <code>generator-iterator</code> 的 <code>next</code> 方法, 迭代算法会进行一次. 每一步产生的值都由关键字 <code>yield</code> 返回. <code>yield</code> 关键字可以看做 <code>generator-iterator</code> 的返回值, 它代表迭代算法每次迭代的分界线. 每当调用 <code>next</code> 方法时, 生成器会接着从 <code>yield</code> 语句紧接着的下一句恢复状态继续执行.</p>

<p>我们循环调用生成器的 <code>next</code> 方法, 直到我们想要的结果, 上面的例子中, 我们打印了斐波那契数列的前 10 项. 但是生成器的版本允许我们生成任意多项, 只要继续循环调用 <code>next</code> 方法即可.</p>

<p>对于那些认为 <code>yield</code>, 生成器仅仅是语法糖的人, 我只能表示: 呵呵. 如果一个能影响编程时的思考方式的东西也叫做语法糖的话, 那么 <code>C</code> 是汇编的语法糖, <code>C++</code> 就是 <code>C</code> 的语法糖了.</p>

<p>对 <code>yield</code> 关键字有了概念之后, 我们来看看它都给我们带来了些什么.</p>

<h2>生成器是产生迭代器更好的方式</h2>

<p>学过 <code>python</code> 的同学应该知道 <a href="https://docs.python.org/2/library/functions.html#range"><code>range</code></a> 与 <a href="https://docs.python.org/2/library/functions.html#xrange"><code>xrange</code></a> 的区别. 如果不清楚的话, 见<a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange">这个</a>问题. 没错, <code>range</code> 会返回一个 <code>list</code>, 而 <code>xrange</code> 却是惰性求值的. (不是严格意义上的生成器, 但特性类似)</p>

<p>因此, 当我们需要遍历一个非常非常大的列表时, 一次性返回全部结果, 非常的消耗内存, 显然不是一个可行的办法. 我们需要惰性求值, 需要迭代器. 但实现一个迭代器, 我们需要手工维护迭代器的内部状态, 实现 <code>next</code> 方法等等. 此时就该轮到我们的生成器登场了.</p>

<p>使用生成器我们可以仅仅使用一个 <code>function</code> 就实现一个具有内部状态的迭代算法. That&rsquo;s awesome!</p>

<p>我在写 <a href="http://blog.bitdewy.me/roar/">roar</a> 时, 实现惰性求值是一个纠结的问题, 由于 <code>C++</code> 没有生成器类似的特性, 迭代器都是手工完成的, 需要手工维护迭代器状态, 容易出错, 而且实现其他功能也会带来阻碍, 举个例子, 如果 <code>C++</code> 支持 <code>yield</code> 的话, 那么 LINQ 的 concat 函数一个可能的实现就是下面这样了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Collection</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">typename</span> <span class="n">Collection</span><span class="o">::</span><span class="n">iterator</span> <span class="n">concat</span><span class="p">(</span><span class="n">Collection</span> <span class="n">a</span><span class="p">,</span> <span class="n">Collection</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">yield</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">yield</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从思考到实现都是那么的流畅, 而不用像现在一样还在纠结如何才能在不对 <code>Collection</code> 进行合并操作就能让迭代器很好的工作这个问题了.</p>

<h2>yield 不仅仅为迭代器而生</h2>

<p>本质上, <code>yield</code> 语句就是利用编译器/解释器替我们做了CPS变换而已. 而CPS变化是控制流的最主要武器. 也许, yield 能帮我们简化控制流, 远离 callback hell?</p>

<p>先来回顾一下 <code>yield</code> 的用法及执行过程, 当遇到 <code>yield</code> 语句时, 生成器函数暂停, 交出控制权, 当外部指定生成器函数继续时(调用 <code>next</code> 方法), 控制权又交回生成器函数继续执行直到下一个 <code>yield</code> 语句. 如果我们能够将所有耗时/已经是异步 callback 的函数更改为 <code>yield</code>, 然后在 callback 中直接调用生成器的 <code>next</code> 方法, 那么我们就可以完全的抛弃 callback 来优雅的完成控制流. 已经有人利用生成器的特性完成这个功能了. 见 <a href="https://github.com/jmar777/suspend">suspend</a>.</p>

<p>对异步编程稍微有点研究的话, 相信不难从上面看到 await 的影子, async 和 await 是 C# 5.0 中引入的关键字, 它使得异步编程变得更简单, await 与 yield 类似, 会暂停并交出控制权, 之前的 <a href="http://blog.bitdewy.me/blog/2013/12/23/cps-async/">异步编程和延续传递风格</a> 和 <a href="http://blog.bitdewy.me/blog/2013/08/20/async-and-await/">异步编程 async &amp; await</a> 提到过相关内容. C++ 也会引入相应的标准, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a> 的提案就是 async &amp; await 的 C++ 版.</p>

<p>遗憾的是, 虽然 <code>yield</code> 虽然进入了 ES6, 但是 <code>await</code> 却没有. 如果 <code>await</code> 能够进入标准的话, 那么也许可以早日改善流程控制库满天飞的局面. ╮(╯▽╰)╭</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/">Python yield 使用浅析</a></li>
<li><a href="http://legacy.python.org/dev/peps/pep-0255/">PEP 255 &mdash; Simple Generators</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/hh191443.aspx">Asynchronous Programming with Async and Await</a></li>
<li><a href="http://www.cppblog.com/vczh/archive/2013/07/27/202154.html">如何设计一门语言（八）——异步编程和CPS变换</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[首尔-釜山-青岛8日游]]></title>
    <link href="http://bitdewy.github.com/blog/2014/05/15/korea-seoul/"/>
    <updated>2014-05-15T22:57:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/05/15/korea-seoul</id>
    <content type="html"><![CDATA[<p>五一假期请了 3 天假, 和几个比较好的朋友一起韩国自由行. (原本预谋好的是台湾自由行, 但是由于小伙伴的证件问题, 只能换了路线 ╮(╯▽╰)╭)</p>

<p>出国当然必备护照, 据说有小伙伴办护照填表格瞎填一通, 还被带到了小黑屋.( ⊙ o ⊙ ). 大家要小心千万不要乱填哈. 关于护照可以参考<a href="http://blog.bitdewy.me/blog/2014/01/28/passport/">这里</a>.</p>

<p>韩国签证还是比较容易办理, 如果没时间去领事馆的话淘宝花 300 块钱左右就可以代办了, 不需要本人办理, 不需要面签.</p>

<p>酒店在国内提前订好, 回避广告, 就不说在哪里定的了, 行程安排是 首尔-釜山-首尔 各住 2 晚. 人均 200 CNY/天. 釜山便宜一些, 首尔较贵, 但住的都不差. 如果能稍微提高一点点预算的话, 能住的非常好呢.</p>

<p>特别安排了 首尔-釜山-首尔 的路线, 坐了韩国的 KTX 高铁, 对外国游客韩国有 KR PASS, 可以直接在网站上预定. 定了 3 日票, 3 日内可以韩国火车随便乱坐, 虽然我们只坐了 首尔-釜山 的往返, 但也比直接买票划算不少. 关于 KR PASS 还差点搞出乌龙, KR PASS 有普通票和同行票, 同行票需要一个普通票带着才可以, 一张普通票最多可以带 5 个同行票(大概是 9 折左右的优惠), 差点全都买成同行票, 还好在出发前又重新定好. 人均 520 CNY.</p>

<p>作为马斯洛需求体系最底层的 WiFi 需求, 当然要提前做好工作, 由于不通韩语, 英语又没信心 ╮(╯▽╰)╭, 最终决定在国内定 wifi egg(3G路由), 国内还. 40CYN/天. 如果是韩国取韩国还的话, 还能再便宜一些. 但是作为一个极度缺乏安全感的人来说, 还是选择了多花一点点钱, 保证万无一失. ^_^</p>

<p>虽然做了不少准备工作, 也还是有不少 bug, 同行的小伙伴没有一个人用的是 中国电信, 而韩国只有 CMDA2000, 导致大家电话都无法使用, 不过 7-11 就有卖电话卡, 也不是什么大问题. 但是毕竟出门在外, 避免有了信号大家乱跑, 最终还是一致决定所有人都紧紧围绕在 WiFi egg 周围, 保持队形.(<em>^__^</em>) 不分开.</p>

<p>最后就是机票了, 往返机票大约 2400 CNY/人. 国际机票税比较高. 提前一个月定的机票, 如果再提前一些的话可能还会更便宜.</p>

<p>废话结束.</p>

<!-- more -->


<h2>Day0 北京-首尔-明洞-首尔塔</h2>

<p>提前在某网站定了车, 一大早4点多钟就起来, 5点钟从我大石景山出发, 一路浩浩荡荡 50 多公里到机场, 只花了 78 块钱. 司机人也超级 nice. 简直赚翻了. 一路过了海关, 安检, 到了国际隔离区第一件事请就是取 WiFi egg, 飞机很准时, 8:10 准时起飞, 上了飞机就开始补充睡眠了.</p>

<p>到首尔大概是中午了, 首先去换了一点点零钱, 机场的汇率很不划算, 少换一点点, 够公交卡就可以了. 到了之后首先是要安顿下来.</p>

<p>由于语言不通, 出行的方式选择了确定性最高的地铁, 各种便利店 7-11, CU 都有卖 T Money 公交卡, 自动售票机器可以充值. 全国通用, 在韩国 7 天到处乱跑, 大概花了 26000 KRW, 约合 150 CYN.</p>

<p><img src="http://5oelva.by3302.livefilestore.com/y2pXmwtkkqrS_9h4v1gs-sN80jgqUJziCii8RJVzL1Gl7alLT6GLlNJFSlkhRz4plVxWxYDd_lXkU-jnVBP2XaO40aNlEDICeEOpEw7JOu-zWM/0.png" alt="去酒店的路上" /></p>

<p>第一站首尔塔附近的酒店, 这是这次行程中最好的一家酒店, 有早餐, 有中文服务, 去釜山时候轻装上阵, 旅行箱也存在这家店里.</p>

<p>稍事休息之后, 向第一站明洞出发. 韩国的街区都叫做 xx 洞. 明洞应该是比较有名的商业区, 在我大宇宙中心-五道口, 还有一家店叫明洞排骨呢. 这里的汇率比较高, 在这里换钱比较合算, 一次性多换一些吧. 如果有不需要转换金的外币卡的话, 刷卡也是蛮划算的, 另外韩国很多地方都支持银联哦, 可以直接人民币消费.</p>

<p><img src="http://4uelva.by3302.livefilestore.com/y2pXJ9WZ8wqh2KaXCO1m84PN6Jl0RlvMBBFC_Z-frvbRjAFDnLA3FdGdNCGZZeiQUllGu_q8DWNKuYejNZ458KbKgOycOMPoj8mCFTWtXFmCMk/1.png" alt="明洞" /></p>

<p>第一天, 都比较羞涩, 就吃了些路边摊, 瞎逛, 没买什么东西就撤了. 晚餐是在明洞的一家有名的石锅拌饭.</p>

<p><img src="http://4pelva.by3302.livefilestore.com/y2p8iJie2FXBK0ZIghVur0XkzgD_xBdG1WqfaD400CPiHabTYUXz9ykUDoQFUF0Jq4XPi-P2rLlVQxmYw3q6bVWs4ctGlhYi1G9wvo_6m2IFRQ/2.png" alt="泉州中央会馆" /></p>

<p>要坐着吃, 才有韩国范儿. 石锅拌饭来啦.</p>

<p><img src="http://3uelva.by3302.livefilestore.com/y2pFGsUCvjj2b4MdTVD5ZqS7_yBV-28o-Uhj1V_xIOnnvss-aUS_A13G-K7SWq-JIKvoWk7uJBRVwSKBIjZ_K9NTf3Ddh1ikRigzmIcpcYkNMs/3.png" alt="石锅拌饭来啦" /></p>

<p>晚饭结束后去了首尔塔, 就是这根粉红色的柱子. 地图上看没多远, 但是爬山爬了好一会儿.</p>

<p><img src="http://3eelva.by3302.livefilestore.com/y2pIY_4c1g7-8z1rnm_TflD2wlXgyrsUn19FsQdFppF-OELzlQPtJcNztFC9sk75Zz-goy9YRCTJeZkQ7Z9ID91C0Hq9ChpXfwogDgaYJG9eCo/4.png" alt="首尔塔" /></p>

<p>原本还计划去 泰迪熊博物馆 也没有去~ ╮(╯▽╰)╭, 首尔塔上卖的糖果.</p>

<p><img src="http://3pelva.by3302.livefilestore.com/y2pv68fU3d-mgHL8-RQYdk1yWued3uHS_eTuWrhmCkqDaEHgCmZI5V3l_O1L6MJCxGqaeYJKi_pamxqbl9WMU7yXoZT4wupG0vkvP7LBIHpYL4/5.png" alt="首尔塔" /></p>

<p>有卖明信片, 买了两张, 寄给朋友一张, 寄给自己一张.</p>

<p><img src="http://4oelva.by3302.livefilestore.com/y2pWviiosjd8vBXTo_b7Lt5jJoHlTeobzO65-zw8lo2mPhiHKx9bU3ICWce9f685qMCvsZRxu72Nd_J9_e2bKhIilLv36uYrKfs68G6VLR7ErI/6.png" alt="首尔塔明信片" /></p>

<p>首尔塔上晒幸福</p>

<p><img src="http://2uelva.by3302.livefilestore.com/y2pGVqznVXe959WD6g_0wDnfd21pcpK6P_X-tvTckqfwz2dHDbXCbzCFbQf6qNQMCtRuRZdjX7PjmF1ODismx-7DeICFZOgXU0E68g2PC9f73Y/7.png" alt="" /></p>

<p>好多锁, 超级多.</p>

<p><img src="http://2eelva.by3302.livefilestore.com/y2py9E95pR5WuxB7ocn7RjQYMhI1ETz9QZHE9EzL28uk1gFBJX0lGQXWvctJV1lL68Ane9pbXtYhVYETAIK6kFDlJEYnES0EMlDwTGd5fJQk9E/8.png" alt="" /></p>

<p>从首尔塔回去已经很晚了, 第一天完.</p>

<h2>Day1 仁寺洞-景福宫-三清洞-梨花壁画村-东大门</h2>

<p>第二天, 首先是早餐~(≧▽≦)/~啦啦啦. 有免费早餐还是很幸福的.</p>

<p><img src="http://4ecmmq.by3302.livefilestore.com/y2p7YmYtKKg-Gg6bAe0IebBomsTDMApkCUDt222Sz64-GRgkO8Nv63dSPFrHxtP1WfRuhtKGwzc7ojzbREz5X39EKkQEpTIf-nEk3v82cBCoeo/9.png" alt="早餐" /></p>

<p>韩国的主题, 就是逛街. 早餐过后来到了仁寺洞, 来的太早, 很多店都还木有开门. 全是鸟文, 不知道是神马意思.</p>

<p><img src="http://4ucmmq.by3302.livefilestore.com/y2pMTD4jk2udiJdStPL3aZFH7fd0CWl57dHt_92mgEvvkeomvGMtDEIG9DoP1I4IN2wKIlHzTBb2lQ0VfZ03LOVuOa2QiIXRRwSUVJLARa7KXw/10.png" alt="仁寺洞" /></p>

<p>不知道这个 &ldquo;人人&rdquo; 到底是神马意思, 别人游记中都拍这个, 那我也拍一张吧.</p>

<p><img src="http://4pcmmq.by3302.livefilestore.com/y2pyo8phOB8SHKYCnHAvcFb6nso0W2iasLeuojI1O9eooGru_0koL4kmNLd2XQ_adQADUVCn_3Z76GEpDNDztJmn543kuozfemRQH9VjSrQ3z8/11.png" alt="仁寺洞人人" /></p>

<p>韩国地铁</p>

<p><img src="http://5ocmmq.by3302.livefilestore.com/y2pKpORkeBCHavPB2f17uj7Y5LVQhSeKoCUozoNEmUb1G6XaDDFg26FYixT4vmcSsBBfUxZtsNprbKbO0wL-q7B65etZiX2XycuCUpvdWNeARw/12.png" alt="地铁" /></p>

<p>从仁寺洞坐一站地铁来到了景福宫, 还碰巧赶上了表演, 里面没神马好看的, 貌似有很多棒子的宫廷剧是在景福宫拍摄的, 虽然我也没看过. ╮(╯▽╰)╭</p>

<p><img src="http://3ecmmq.by3302.livefilestore.com/y2pqQFCRxE3UomM386iBExwgYOIucj7DipGcI2_0ZqGhvJV4PgyGoFWdZupn00XRW0CgRtxooXz7o5wa1Rij-zXfWWYSllkfTsqwNoJ41lKSGo/13.png" alt="景福宫表演" /></p>

<p>午饭时间, 来到了景福宫旁边的任何时候都排长队的土俗村参鸡汤, 鸡肚子里有糯米, 板栗, 红枣, 人参, 好吃. ( ⊙ o ⊙ )！ 可惜餐前忘记了拍照给食物消毒. (╯‵□′)╯︵┻━┻ 来张店里的风景吧. 还是坐地上吃. 各种腿麻.</p>

<p><img src="http://3pcmmq.by3302.livefilestore.com/y2pxqXZmDb6W024ho_Sd9FjR22bOSowKCvydxI10fodDTwn2y8GwdYGtQ6vmFBKuGSvH8E4Oyxf3bTHbPO82uxVs1EIGlFrpVIHNNmwvDDxyOg/14.png" alt="参鸡汤" /></p>

<p>青瓦台, 韩国的中南海, 警备森然, 还不能乱拍照, 有小伙伴拍照, 被持枪的警察喝止.</p>

<p><img src="http://3ucmmq.by3302.livefilestore.com/y2pHfNP3YqRnQZAfdnLGF9qAffqYC_wUN248av08tjEXdMVilQGfDuKbFhwSIPAH4X1pIUopQgVoI-SsDMF9EGXGu0OvuTYu_Rid9TWetRZRYo/15.png" alt="青瓦台" /></p>

<p>过了青瓦台不远就到了三清洞, 又开始逛街. 逛完一洞又一洞. 乘地铁去逛大学路, 随便逛逛, 吃了路边摊. 然后徒步去梨花壁画村, 一度在发现了目标之后没当回事儿, 绕了一大圈才找到, 当返回的时候, 发现原来是这里的时候, 我们整个都斯巴达了. (╯‵□′)╯︵┻━┻.</p>

<p><img src="http://4ocmmq.by3302.livefilestore.com/y2pI8loNMMOQsDS9zB5SopnkKWsKafC5Ief4i10-7B_olgOWfC2ZVjEyQ8xH4QX0by4dEDLzOwlXKFdoU1ZbWu8lyGdX1kcPz1U8xICJkBf09Q/16.png" alt="壁画村" /></p>

<p>晚上的主题是东大门逛商场. 第二天完.</p>

<h2>Day2 首尔-釜山-南浦洞-海云台</h2>

<p>第三天一早, 收拾东西出发去釜山, 到达釜山已经接近中午, 天空不作美, 一来釜山就下大雨, 先去了南浦洞随便逛逛. 已经是第三天, 购物没第一天那么矜持了. 主旋律就是买买买. 天都黑了也要各种买.</p>

<p><img src="http://2ecmmq.by3302.livefilestore.com/y2p9loa-_d25Pzjlry5y0bWw1oChfz1kNd1XAL6oyV5XhCYw8jMK2N3Ic1rmn_NXskFRszZMFIWXo2JHQsyelHOAif-3UCCgdT-nP5CYRfZA4c/17.png" alt="南浦洞" /></p>

<p>来釜山就是为了海云台, 以前只吃过海云台, 这次可以见到真的了. 酒店就在海云台海水浴场很近的地方. 来了才发现, 这地方各种 Motel. ( ⊙ o ⊙ )</p>

<p><img src="http://2ucmmq.by3302.livefilestore.com/y2pQkUuZ1f7C6wxVaByFgsDVzJ9vNW9B49ATAbbPCN26dblFBMkgcqveZa816RLmwQCJk8FlW57JSoseeNeqxQLRh2wc6iC8U0aN3lOMicPRRQ/18.png" alt="海云台" /></p>

<p>睡的是地铺, 还在地板上发现了大量钞票. ( ⊙ o ⊙ )！</p>

<p><img src="http://4efbpq.by3302.livefilestore.com/y2p5FS31sa3mGgrY5uh6FJxF3205twkZIe7LK9lgI0NILPn1uwnIQUy11RHWH6yEsEH1NxY5ZUuKC0sKrJElrbVkQkDPMUI5XtzxgOt5OsT3lg/19.png" alt="海云台地铺" /></p>

<p>入住已经很晚了, 都懒得动, 只好派人去买晚饭, 还点名要炸鸡啤酒, 人生地不熟, 语言不通, 暴雨. 一路暴走, 走到了海边, 拍了些照片, 最后买了这些东西回来.</p>

<p><img src="http://4pfbpq.by3302.livefilestore.com/y2pX9YajED1sD-s6Sg4uC8DiT7hrf8mBPV17FTGNT5WFI-rU8qRkxiX9zdVdS0fMT6ZDHhAzWyrwzs7T_LnxOTyL0bRgRddBmVOQ_uokEOzLFA/20.png" alt="汉堡王" /></p>

<p>还有两瓶奇怪的东西乱入
<img src="http://5ofbpq.by3302.livefilestore.com/y2pjjMPS1w6jsGAMC8PuBY0Vey9dN1eK7Ho3dZSYgxFCHsp-L-zIlR6lrgo8QfQJGwf2jwaNcZjD9O3tNzCQ0Rj6qugmV6y8ukqgqsFk5roLQU/21.png" alt="" /></p>

<p>第三天就这么结束了.</p>

<h2>Day3 海云台-迎月路-VESTA汗蒸</h2>

<p>这是最舒服的一天, 主题就是玩沙子 + 汗蒸.</p>

<p><img src="http://4ufbpq.by3302.livefilestore.com/y2p_s1AL8MFrjxjEzcl2MsDb9YiVHcUehDA4bph7kbwa23AJ7VBFNlYtrUxRVG2FR1Ur_AWlKtrwlY6FarOBFqOoY24mKTCqWwZaY5Ze2Dy7sg/22.png" alt="海云台" /></p>

<p>拍照技巧之一拼星星</p>

<p><img src="http://3ufbpq.by3302.livefilestore.com/y2pDrFyr01vnAeSsKhdvhJMHxzHGLWxxrWiIJtdw2RCHswuQ4ZQD-1X6g4AEyKismWDKZu5qJBK2ra6fT1eo6rUJXlufe-swpm97K6XdIgWuqk/23.png" alt="拼星星" /></p>

<p>玩沙子玩到中午, 去吃了烤肉, 虽然语言不通, 但是老板娘很热情, 还帮烤好并喂到妹纸嘴里. 作为男孩子, 就木有这个福利了. ╮(╯▽╰)╭</p>

<p>下午的主题就是洗澡. 没法贴照片了. 第一次看着大海洗澡. 感觉还是很爽的, 哈哈.</p>

<p>晚上去吃了海鲜. 已经到了第 4 天, 拍照变得没那么勤快了.</p>

<h2>Day4 海云台-首尔-八色烤肉-弘大</h2>

<p>第 5 天早上, 早早的起来, 准备看日出, 可惜天气不好，云太厚 ╮(╯﹏╰）╭, 没能看成.</p>

<p><img src="http://3efbpq.by3302.livefilestore.com/y2pO07WFZTh0-ARIOoS3doc2z0Pks0hrH7Y_E3iiv9uMie4t_bCxO7LiEcpHl3UMoqbrMokRZX4AeFMRDcf1Ym3p-X3DrnzZhVnmzzD13K5k2s/24.png" alt="清晨的海云台" /></p>

<p>韩国海难刚过去不久, 有人在海云台边上点的蜡烛祈福</p>

<p><img src="http://3pfbpq.by3302.livefilestore.com/y2pfcilFVrjrj8Zi2anshIWhtG1T53QUktkeKP5p9TnEOGcwufxpOp_2jj8YAb_mX0WQlvQMirAQ0gdWUciamusc1eWBR6RP4V50K7fhxGmxQQ/25.png" alt="祈福" /></p>

<p>很遗憾, 没看成日出, 大家都表示要回笼. 回去回笼之后吃了早餐出发回首尔. 由于回笼太久, 到达首尔已经过了午饭时间, 大家一致表示晚上要吃一顿大的. 午餐就免了. 取回行李后, 赶到新的入住地点, 弘益大学附近. 入住之后, 在弘大附近瞎逛一下, 开始觅食寻找八色五花肉. 这家店在地下一层. 门面很不起眼. 路过都没看见. 一个韩国大叔看我们拿着 ipad 寻觅, 主动提供帮助, 一路我们领到了店门口. 好吃不贵, 感觉比国内还便宜, 肉也够厚, 味道很好.</p>

<p><img src="http://2ufbpq.by3302.livefilestore.com/y2ptkzspaxZG56Bj9FTcZZncDbEGLtGiKWSj08Aztr7uC8iP-69Q8Jdq8ixZ6UZH8v-lBzI8cWcVZ5iK1dBTFzus0DIIxuL2uRQuU35PtsNbFg/26.png" alt="八色五花肉" /></p>

<p>吃饱了, 逛街又有劲儿了. 第 5 日完.</p>

<h2>Day5 梨花女子大学-东大门-国立中央博物管-3D美术馆-炸鸡啤酒</h2>

<p>梨花女子大学, 不解释.</p>

<p><img src="http://4ofbpq.by3302.livefilestore.com/y2pXKgkblEDSkhXt6-qkPMIgO16FJiza5NF0ALTECImqE1B4x_y1sik8lk7yGDOzIn2XJXwEqBmbqx6zaO3CG92LiwzkxsBfxfBHgwnZDNpBSQ/27.png" alt="梨花女子大学" /></p>

<p>放眼望去全是妹纸, 不知道该看哪里.</p>

<p><img src="http://2efbpq.by3302.livefilestore.com/y2pg6187-yNBVPt6F358Rav3W6SDodEmVZwY7QvOwfJ5Bl1EIYnA3R7YyxygRBGY6Zwl1ioLxzereZkcWQ3POnfhf2LN-aQfo_F6GQQp0Ufdzo/28.png" alt="" /></p>

<p>在梨花女子大学的妇女文化博物馆还遇到了来学习的中学生(萝莉).</p>

<p>到了最后的日子, 只有疯狂的购物才是主旋律. 买的差不多了之后, 才想起要去国立中央博物馆看看, 可惜赶到的时候博物馆已经关门, 只能在博物馆外面围观.</p>

<p><img src="http://4edcgg.by3302.livefilestore.com/y2pmND85irttef8lFxrzm_S6CTndD3ZJ9h0PxygRv6WyvJX9iGbUIeiia4t9eLBr3jBJK3FKnWJuYk7fcyQBbmKdsQYyIt0OMniPJkjZse-6Mk/29.png" alt="国立中央博物馆" /></p>

<p>去博物馆未遂, 回到了住处继续逛弘大, 去了 3D 美术馆, 各种拍照. 国内貌似也有不少这种地方. 可惜的是时间不多, 而我们却在外面免费的地方折腾了超长时间. 囧o(╯□╰)o</p>

<p><img src="http://4udcgg.by3302.livefilestore.com/y2pTKsz1Zz9G0ul-ClsJ2fzdXjq651IWCFX2DTkwk7ssaR-pGTZ48YenqWlpTVc80WAWUTpQ-ux3gqKhNKsRoh-z__h9JQF5pHTDm-yYt9j8Ps/30.png" alt="" /></p>

<p>这是在韩国的最后一晚, 当然少不了炸鸡啤酒. 跋山涉水走了 N 个街区找到了这家有名的店.</p>

<p><img src="http://4pdcgg.by3302.livefilestore.com/y2pm6sIn3zKwjuVRNb_PUWwvrRdtI-juRTIMS_yLCkANoU1is2rgCvPKY62o_VhgILeYXzNTkqUORbVxb328Do1Txc6omzlIqpw8jjbElikG9M/31.png" alt="炸鸡啤酒" /></p>

<p>尽兴而归, 又是买买买, 在一家化妆品店里一次买了 210000 KRW 的东西, 导购妹子各种热情, 送了不少东西, 还送了每人一瓶玫瑰茶. 第 6 天完.</p>

<h2>Day6 梨花女子大学-仁川机场-青岛</h2>

<p>最后一天疯狂的购物, 又来到了梨花女子大学附近, 发现了 工口 乱入.</p>

<p><img src="http://5odcgg.by3302.livefilestore.com/y2p4a-87Qq57mnzyWrUC75ysdhh6ELoM_NAc9AHZNX9-SHtnVwSUx9xSOWWtASyVss6W4d0jznZvo1uEE7WBGgkZsZB2o0PZxC1fe2pnp8dyBk/32.png" alt="工口" /></p>

<p>买了一上午之后, 就要赶去机场准备回国了, 在我们离开韩国地铁 2 号线到达机场一个小时之后, 它就撞了. ( ⊙ o ⊙ ). 好惊悚. 机场退税退了不少, 全都在免税店花完了. ╮(╯▽╰)╭</p>

<p>下午 6 点就到了青岛, 住小伙伴家, 家长各种款待. 都不好意思了.</p>

<h2>Day7 青岛</h2>

<p>小伙伴家住八大关, 家门口各种游客, 我们进进出出, 游客都会投来诧异的目光. 他的麻麻还在淘宝上淘了个复古的报箱挂在大铁门上, 不少游客都以报箱为背景拍照. 忘了照报箱了, 随便拿一张八大关的照片顶一下吧.</p>

<p><img src="http://3edcgg.by3302.livefilestore.com/y2pSBtjYAoqIFITiZt-mOE87vxfXuRFNQy3tBxl1d8V7X9S7h8nsk8bPPo4ZSi7g3S0b_GyLpDB5h_QA6Bwmd_ZXHSaBCRgL7xD7jWErj670ZE/33.png" alt="八大关" /></p>

<p>这一天, 沿着青岛海岸线一路狂奔, 并发现了美女.</p>

<p><img src="http://3udcgg.by3302.livefilestore.com/y2pT72VndPKJpoLOzIAIZeg4IyiErhVAMyR2e-j5eCd73Jr2fQnygbNudrlgOOD1ZQbTN2si5jcUFttQ899Jas7tiGqm5pFphiojquTA0a2yLk/34.png" alt="美女" /></p>

<p>一路上的风景都很不错, 晚上6点从青岛出发回北京, 第二天上班. 8 天的旅行就这么结束了.<del>(>_&lt;)</del> 什么时候再去( ⊙ o ⊙ )啊！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 前端开发小测验, part 1 之 CSS]]></title>
    <link href="http://bitdewy.github.com/blog/2014/03/09/front-end-web-development-quiz-part1-css/"/>
    <updated>2014-03-09T01:30:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/03/09/front-end-web-development-quiz-part1-css</id>
    <content type="html"><![CDATA[<p>这是 <a href="http://www.devqin.com/">@devqin</a> 在 <a href="http://bb.ijser.cn/topic/46/%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E5%BE%97%E5%88%B0%E5%A4%9A%E5%B0%91%E5%88%86-%E8%87%AA%E6%88%91%E6%84%9F%E8%A7%89%E8%89%AF%E5%A5%BD%E8%80%85%E8%8E%AB%E5%85%A5-%E5%9B%A0%E4%B8%BA-%E5%AE%98%E6%96%B9%E8%AF%B4%E7%9A%84%E6%98%AF-maight-hurt-your-feelings">NADbb</a> 上发的一个找虐的测试. (原作者有个提示: Warning: might hurt your feelings).</p>

<p>我来挨个找证据, 今天是 part 1, CSS 部分.</p>

<h4>1)</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">MaRGin</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Are CSS property names case-sensitive?</p>

<p>CSS 属性名是大小写敏感的吗 ?</p>

<p><strong>答</strong>: 不敏感. <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 的 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#forward-compatible-parsing">7.1 Forward-compatible parsing</a> 最后有这么一段话,</p>

<blockquote><p>All CSS style sheets are case-insensitive, except for parts that are not under the control of CSS. I.e., in CSS1, font family names and URLs can be case-sensitive. Also, the case-sensitivity of the CLASS and ID attributes is under the control of HTML.</p></blockquote>

<p>因此, 只有不受 CSS 控制的, 如 <code>font family</code> 的名字, <code>url</code>, 以及受 <code>HTML</code> 控制的 <code>ID</code> 和 <code>class</code> 大小写敏感, 其他受 CSS 控制的内容都是大小写不敏感的.</p>

<h4>2) Does setting <code>margin-top</code> and <code>margin-bottom</code> have an affect on an inline element ?</h4>

<p><code>margin-top</code> 与 <code>margin-bottom</code> 对内联元素是否有效 ?</p>

<p><strong>答</strong>: 没效果, <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 的 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#inline-elements">4.2 Inline elements</a> 中有如下描述:</p>

<blockquote><p>If the inline element has margins, borders, padding or text decorations attached, these will have no effect where the element is broken.</p></blockquote>

<p>CSS2.1 中, <a href="http://www.w3.org/TR/CSS21/box.html#propdef-margin-bottom">8.3 Margin properties: &lsquo;margin-top&rsquo;, &lsquo;margin-right&rsquo;, &lsquo;margin-bottom&rsquo;, &lsquo;margin-left&rsquo;, and &lsquo;margin&rsquo;</a> 节关于 <code>margin-top</code> 和 <code>margin-bottom</code> 有如下描述:</p>

<blockquote><p>These properties have no effect on non-replaced inline elements.</p></blockquote>

<p>关于 non-replaced 与 replaced element 的定义可以参考 CSS2.1 中的 <a href="http://www.w3.org/TR/CSS21/conform.html#replaced-element">Replaced element</a></p>

<h4>3) Does setting <code>padding-top</code> and <code>padding-bottom</code> on an inline element add to its dimensions ?</h4>

<!-- more -->


<p><code>padding-top</code> 与 <code>padding-bottom</code> 会增加内联元素的大小吗 ?</p>

<p><strong>答</strong>: 不会, <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 的 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#inline-elements">4.2 Inline elements</a> 中有如下描述:</p>

<blockquote><p>If the inline element has margins, borders, padding or text decorations attached, these will have no effect where the element is broken.</p></blockquote>

<p>CSS2.1 中, <a href="http://www.w3.org/TR/CSS21/visudet.html#Computing_heights_and_margins">10.6.1 Inline, non-replaced elements</a> 节, 有如下描述:</p>

<blockquote><p>The vertical padding, border and margin of an inline, non-replaced box start at the top and bottom of the content area, and has nothing to do with the &lsquo;line-height&rsquo;. But only the &lsquo;line-height&rsquo; is used when calculating the height of the line box.</p></blockquote>

<p>因此, 只有 <code>line-height</code> 属性才能改变内联元素的高度.</p>

<h4>4) If you have a <code>&lt;p&gt;</code> element with <code>font-size: 10rem</code>, will the text be responsive when the user resizes / drags the browser window?</h4>

<p>当拖动浏览器窗口大小时, 有 <code>font-size: 10rem</code> 属性的 <code>&lt;p&gt;</code> 元素中的文本内容是否会有反应 ?</p>

<p><strong>答</strong>: 不会有反应. CSS3 中, 对 <a href="http://www.w3.org/TR/css3-values/#font-relative-lengths">rem unit</a> 有如下描述:</p>

<blockquote><p>Equal to the computed value of ‘font-size’ on the root element. When specified on the ‘font-size’ property of the root element, the ‘rem’ units refer to the property&rsquo;s initial value.</p></blockquote>

<p>因此 <code>&lt;p&gt;</code> 元素中的文本内容只与根元素的字体大小有关, (主流的浏览器, 默认根元素的 <code>font-size</code> 为 <code>16px</code>), 而拖动窗口大小是不会改变根元素的 <code>font-size</code> 属性值的. 所以不会有反应.</p>

<h4>5) The pseudo class <code>:checked</code> will select inputs with type radio or checkbox, but not <code>&lt;option&gt;</code> elements.</h4>

<p>伪类 <code>:checked</code> 会作用于 <code>radio</code> 或者 <code>checkbox</code>, 但是不会作用于 <code>&lt;option&gt;</code>.</p>

<p><strong>答</strong>: 错. CSS3 中, <a href="http://www.w3.org/TR/css3-selectors/#UIstates">6.6.4.2. The :checked pseudo-class</a> 中有如下描述:</p>

<blockquote><p>Radio and checkbox elements can be toggled by the user. Some menu items are &ldquo;checked&rdquo; when the user selects them. When such elements are toggled &ldquo;on&rdquo; the :checked pseudo-class applies. While the :checked pseudo-class is dynamic in nature, and can altered by user action, since it can also be based on the presence of semantic attributes in the document, it applies to all media. For example, the :checked pseudo-class initially applies to such elements that have the HTML4 selected and checked attributes as described in Section 17.2.1 of HTML4, but of course the user can toggle &ldquo;off&rdquo; such elements in which case the :checked pseudo-class would no longer apply.</p></blockquote>

<p>从上面的描述中可以看出, 除了 radio 和 checkbox 之外, 伪类 <code>:checked</code> 也可以作用于 HTML 标准中含有 <code>selected</code> 和 <code>checked</code> 属性的元素,  在 HTML4 <a href="http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.2.1">17.2.1 Control types</a> 一节的描述中包含 option, 因此 <code>:checked</code> 可以作用于 <code>&lt;option&gt;</code>.</p>

<h4>6) In a HTML document, the pseudo class <code>:root</code> always refers to the <code>&lt;html&gt;</code> element.</h4>

<p>在一个 HTML 文档中, 伪类 <code>:root</code> 总是代表 <code>&lt;html&gt;</code> 元素.</p>

<p><strong>答</strong>: 是. CSS3 <a href="http://www.w3.org/TR/css3-selectors/#root-pseudo">6.6.5.1. :root pseudo-class</a> 一节, 有如下描述:</p>

<blockquote><p>The :root pseudo-class represents an element that is the root of the document. In HTML 4, this is always the HTML element.</p></blockquote>

<p>而 HTML5 <a href="http://www.w3.org/TR/html5/semantics.html#the-root-element">4.1 The root element</a> 一节, 也有如下描述:</p>

<blockquote><p>The html element represents the root of an HTML document.</p></blockquote>

<p>所以, <code>:root</code> 就是 <code>&lt;html&gt;</code> 元素.</p>

<h4>7) The <code>translate()</code> function can move the position of an element on the z-axis.</h4>

<p>函数 <code>translate()</code> 可以在 z 轴上移动元素的位置.</p>

<p><strong>答</strong>: 错误. CSS Transforms Module Level 1 中 <a href="http://www.w3.org/TR/css3-transforms/#funcdef-translate">translate</a> 的定义如下:</p>

<p><code>translate() = translate( &lt;translation-value&gt; [, &lt;translation-value&gt; ]? )</code></p>

<blockquote><p>specifies a 2D translation by the vector [tx, ty], where tx is the first translation-value parameter and ty is the optional second translation-value parameter. If <ty> is not provided, ty has zero as a value.</p></blockquote>

<p>所以 <code>translate()</code> 函数是一个 2D 变换的函数, 仅仅能改变 x 与 y 轴的位置, 不能改变 z 轴的位置.</p>

<h4>8)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nt">li</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<p><strong>答</strong>: 蓝色.</p>

<p>首先来看一下标准中的描述, <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 中 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#cascading-order">3.2 Cascading order</a> 一节, 有如下描述.</p>

<blockquote><p>Conflicting rules are intrinsic to the CSS mechanism. To find the value for an element/property combination, the following algorithm must be followed:</p>

<ol>
<li><p> Find all declarations that apply to the element/property in question. Declarations apply if the selector matches the element in question. If no declarations apply, the inherited value is used. If there is no inherited value (this is the case for the &lsquo;HTML&rsquo; element and for properties that do not inherit), the initial value is used.</p></li>
<li><p>Sort the declarations by explicit weight: declarations marked &lsquo;!important&rsquo; carry more weight than unmarked (normal) declarations.</p></li>
<li><p>Sort by origin: the author&rsquo;s style sheets override the reader&rsquo;s style sheet which override the UA&rsquo;s default values. An imported style sheet has the same origin as the style sheet from which it is imported.</p></li>
<li><p>Sort by specificity of selector: more specific selectors will override more general ones. To find the specificity, count the number of ID attributes in the selector (a), the number of CLASS attributes in the selector (b), and the number of tag names in the selector (c). Concatenating the three numbers (in a number system with a large base) gives the specificity.</p></li>
<li><p>Sort by order specified: if two rules have the same weight, the latter specified wins. Rules in imported style sheets are considered to be before any rules in the style sheet itself.</p></li>
</ol>
</blockquote>

<p>第 4 条关于权重的细节跳过.</p>

<p>根据第 1 条, 显然 <code>li</code> 比 <code>ul</code> 元素匹配更精确, 因此选择 <code>li</code> 蓝色.</p>

<h4>9)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span> <span class="nt">li</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#must-buy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度, 两个一致, 都选择到了 <code>span</code> 的父元素 <code>li</code>.</li>
<li>显式声明的权重也一致.</li>
<li>这里不用考虑 CSS 文件, 用户, 以及浏览器默认的样式覆盖问题.</li>
<li>根据选择器的权重, <code>ID</code> 获胜.</li>
</ol>


<p>因此答案是: 蓝色.</p>

<h4>10)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.shopping-list</span> <span class="nc">.favorite</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#must-buy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度, 两个一致, 都选择到了 <code>span</code> 的父元素 <code>li</code>.</li>
<li>显式声明的权重也一致.</li>
<li>这里不用考虑 CSS 文件, 用户, 以及浏览器默认的样式覆盖问题.</li>
<li>根据选择器的权重, <code>ID</code> 获胜.</li>
</ol>


<p>因此答案是: 蓝色.</p>

<h4>11)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span><span class="nf">#awesome</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nt">ul</span><span class="nc">.shopping-list</span> <span class="nt">li</span><span class="nc">.favorite</span> <span class="nt">span</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度不一致, 虽然 <code>ul#awesome</code> 的权重很高, 但是只选到了 <code>span</code> 的父元素 <code>li</code>.</li>
</ol>


<p>因此答案是: 蓝色.</p>

<h4>12)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span><span class="nf">#awesome</span> <span class="nf">#must-buy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.favorite</span> <span class="nt">span</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="cp">!important</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度不一致, 虽然 <code>ul#awesome #must-buy</code> 的权重很高, 但是只选到了 <code>span</code> 的父元素 <code>li</code>.</li>
</ol>


<p>因此答案是: 蓝色. (即使没有 <code>!important</code> 也是蓝色.</p>

<h4>13)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span><span class="nc">.shopping-list</span> <span class="nt">li</span> <span class="nc">.highlight</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nt">ul</span><span class="nc">.shopping-list</span> <span class="nt">li</span> <span class="nc">.highlight</span><span class="nd">:nth-of-type</span><span class="o">(</span><span class="nt">odd</span><span class="o">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度, 两个一致, 都选择到了 <code>span</code> 的父元素 <code>li</code>.</li>
<li>显式声明的权重也一致.</li>
<li>这里不用考虑 CSS 文件, 用户, 以及浏览器默认的样式覆盖问题.</li>
<li><code>ul.shopping-list li .highlight:nth-of-type(odd)</code> 多了一个伪类, 权重多 10.</li>
</ol>


<p>因此答案是: 蓝色.</p>

<h4>14)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#awesome</span> <span class="nc">.favorite</span><span class="nd">:not</span><span class="o">(</span><span class="nf">#awesome</span><span class="o">)</span> <span class="nc">.highlight</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#awesome</span> <span class="nc">.highlight</span><span class="nd">:nth-of-type</span><span class="o">(</span><span class="nt">1</span><span class="o">)</span><span class="nd">:nth-last-of-type</span><span class="o">(</span><span class="nt">1</span><span class="o">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度, 两个一致, 都选择到了 <code>span</code> 的父元素 <code>li</code>.</li>
<li>显式声明的权重也一致.</li>
<li>这里不用考虑 CSS 文件, 用户, 以及浏览器默认的样式覆盖问题.</li>
<li>这个题目是权重的题目, 但是 <code>#awesome .favorite:not(#awesome) .highlight</code> 的权重究竟是多少呢 ?</li>
</ol>


<p>CSS3 selectors <a href="http://www.w3.org/TR/css3-selectors/#specificity">9. Calculating a selector&rsquo;s specificity</a> 一节中有如下描述,</p>

<blockquote><p>Selectors inside the negation pseudo-class are counted like any other, but the negation itself does not count as a pseudo-class.</p></blockquote>

<p>所以, 很明显, <code>#awesome .favorite:not(#awesome) .highlight</code> 有两个 <code>ID</code> 两个 <code>class</code> 权重 220, 远远大于 <code>#awesome .highlight:nth-of-type(1):nth-last-of-type(1)</code> 的 130</p>

<p>因此答案是: 蓝色.</p>

<h4>15)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">&quot;example&quot;</span><span class="nt">&gt;</span>Hello<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#example</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">margin-bottom</span><span class="o">:</span> <span class="m">-5px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What will happen to the position of <code>#example</code> ?</p>

<p><code>#example</code> 的位置会有何变化 ?</p>

<p><strong>答</strong>: 后面的元素都向上移动 5px.</p>

<p>CSS2.1 标准 <a href="http://www.w3.org/TR/CSS21/box.html#padding-properties">8.4 Padding properties</a> 一节中有如下描述:</p>

<blockquote><p>Negative values for margin properties are allowed, but there may be implementation-specific limits.</p></blockquote>

<p>这个题目是 browser specific 的, 不过大部分主流的浏览器实现方式都是一致的. 可以参考这里: <a href="http://coding.smashingmagazine.com/2009/07/27/the-definitive-guide-to-using-negative-margins/">http://coding.smashingmagazine.com/2009/07/27/the-definitive-guide-to-using-negative-margins/</a></p>

<p><img src="https://xf8dta.by3302.livefilestore.com/y2p5iAEbpvpJ4V698_MY1TJEkWQirSTMe36n8ag5WbwJCdcv_U-_f76T_HKTl_5zhaqklMq_ND0fmuYxLBLT8RIEJi0rzr-pwYbmsK0WmxI_lc/margin-motion.gif" alt="" /></p>

<h4>16)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">&quot;example&quot;</span><span class="nt">&gt;</span>Hello<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#example</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">margin-left</span><span class="o">:</span> <span class="m">-5px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What will happen to the position of <code>#example</code> ?</p>

<p><code>#example</code> 的位置会有何变化 ?</p>

<p><strong>答</strong>: 像左←移动 5px. 证据同上一题.</p>

<h4>17)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;test1&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">&quot;test2&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#i-am-useless</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&#39;mypic.jpg&#39;)</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Are unused style resources still downloaded by the browser?</p>

<p>浏览器会下载未使用的样式资源吗 ?</p>

<p><strong>答</strong>: 不会. 这又是一个 browser specific 的题目. 不过主流的浏览器都会遵循 <code>lazy-loading</code> 的原则. 因此这个图片不会下载.</p>

<h4>18)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;test1&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">&quot;test2&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#test2</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&#39;mypic.jpg&#39;)</span><span class="p">;</span>
</span><span class='line'>    <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>On page load, will <code>mypic.jpg</code> get downloaded by the browser ?</p>

<p>页面加载时, 浏览器会下载图片 <code>mypic.jpg</code> 吗 ?</p>

<p><strong>答</strong>: 会. 虽然属性 <code>display</code> 的值为 <code>none</code>, 但是图片仍然会被下载, 因为 css 文件解析是自上而下的, 因此当解析到 <code>background-image</code> 时, 没有足够的信息表明 test2 将不会显示时, 因此图片会下载.</p>

<h4>19)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;test1&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">&quot;test2&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#test1</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#test2</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&#39;mypic.jpg&#39;)</span><span class="p">;</span>
</span><span class='line'>    <span class="k">visibility</span><span class="o">:</span> <span class="k">hidden</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>On page load, will <code>mypic.jpg</code> get downloaded by the browser ?</p>

<p>页面加载时, 浏览器会下载图片 <code>mypic.jpg</code> 吗 ?</p>

<p><strong>答</strong>: 不会. 与上面的分析一致, 只是此时已有足够的信息表明 <code>test2</code> 将不会显示.</p>

<h4>20)</h4>

<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="k">@media</span> <span class="nt">only</span> <span class="nt">screen</span> <span class="nt">and</span> <span class="o">(</span><span class="nt">max-width</span><span class="o">:</span> <span class="nt">1024px</span><span class="o">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">margin</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the use of the <code>only</code> selector ?</p>

<p><code>only</code> 选择器的作用是什么 ?</p>

<p><strong>答</strong>: Stops older browsers from parsing the remainder of the selector. 是阻止旧浏览器解析后续的选择器的.</p>

<p>在 CSS3 <a href="http://www.w3.org/TR/css3-mediaqueries/#media0">Media Queries</a> 中有如下描述:</p>

<blockquote><p>The keyword ‘only’ can also be used to hide style sheets from older user agents. User agents must process media queries starting with ‘only’ as if the ‘only’ keyword was not present.</p></blockquote>

<p>所以, 关键字 <code>only</code> 就是为了不让旧浏览器正确解析的.</p>

<h4>21)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;p&gt;</span>I am floated<span class="nt">&lt;/p&gt;</span>
</span><span class='line'>    <span class="nt">&lt;p&gt;</span>So am I<span class="nt">&lt;/p&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">div</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">overflow</span><span class="o">:</span> <span class="k">hidden</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nt">p</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">float</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Does <code>overflow: hidden</code> create a new block formatting context ?</p>

<p><code>overflow: hidden</code> 会创建一个新的块级格式化上下文吗 ?</p>

<p><strong>答</strong>: 会. CSS2.1 <a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting">9.4.1 Block formatting contexts</a> 一节中有如下描述:</p>

<blockquote><p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with &lsquo;overflow&rsquo; other than &lsquo;visible&rsquo; (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p></blockquote>

<p>因此, 只要 <code>overflow</code> 的值不是 <code>visible</code> 时, 都会创建一个新的块级格式化上下文.</p>

<h4>22)</h4>

<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="k">@media</span> <span class="nt">only</span> <span class="nt">screen</span> <span class="nt">and</span> <span class="o">(</span><span class="nt">max-width</span><span class="o">:</span> <span class="nt">1024px</span><span class="o">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">margin</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Does the <code>screen</code> keyword apply to the device&rsquo;s physical screen or the browser&rsquo;s viewport ?</p>

<p>关键字 <code>screen</code> 指的是设备的物理屏幕, 还是指的浏览器的 viewport ?</p>

<p><strong>答</strong>: CSS2 <a href="http://www.w3.org/TR/CSS2/media.html#media-types">Media types</a> 一节, 有如下描述,</p>

<blockquote><p><strong>screen</strong></p>

<p>Intended primarily for color computer screens.</p></blockquote>

<p>因此, 答案应该是设备的物理屏幕, 但是原作者给的答案是浏览器的 viewport. (不知所措. o(>﹏&lt;)o</p>

<p><code>HTML</code>, 以及 <code>Javascript</code> 的后续部分, 敬请期待 ~O(∩_∩)O~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[护照, 往来港澳通行证以及大陆居民往来台湾地区通行证办理记录]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/28/passport/"/>
    <updated>2014-01-28T19:20:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/28/passport</id>
    <content type="html"><![CDATA[<p>首先, 吐槽一下, 在自己国家的土地上都不能自由通行, 还需要办理各种证件. (╯‵□′)╯︵┻━┻</p>

<p>以西安为例, 西安市出入境管理中心在科技路二号(西斜七路十字西南角), 工作时间为法定工作日 9:00-17:00. 据说中午有休息时间. 由于本人 14:50 才到, 中午休息时间未知. (如果一次性需要办多个证件, 需要填多张表格, 所以即使中午休息时间到也没有关系, 领表格自行填写, 填写完之后再办手续).</p>

<p>表格的填写一般都有样例, 不过样例可能已经与现在填写的版本不一致, 这个不用担心, 主要填写基本信息, 不知如何填写的可以留空. 办理时, 工作人员会最后确认的. (这次给我办理的是个制服美女. O(∩_∩)O 哈哈~ 跑题了.</p>

<h2>护照</h2>

<p>护照是一个国家的公民出入本国国境和到国外旅行或居留时, 由本国发给的一种证明该公民国籍和身份的合法证件. 没有护照是没法出国的. 目前对大陆免签的国家非常少啊, 非常少. (╯‵□′)╯︵┻━┻</p>

<p>护照申请表格一式一份 2 张, 需要本人填写的只有一些基本信息, 办理过程需要录入指纹, 申请表格有一栏是需要工作人员确认信息完成后, 当面签字的. 如果需要邮寄的话, 需要在最后填写邮寄地址. 如果旧护照已过期, 那么与首次申请办理护照没有区别, 旧护照可以自己留作纪念.</p>

<h2>往来港澳通行证</h2>

<p>内地居民因私往来香港或澳门特别行政区旅游, 探亲, 从事商务, 培训, 就业等非公务活动, 向户口所在地的市, 县公安出入境管理部门提出申请, 凭公安出入境管理部门签发的往来港澳通行证及有效签注才能前往.</p>

<p>如果持有大陆护照, 以及入台的各种证件, 和香港转机机票, 则不需要往来港澳通行证即可在港澳最多停留 7 日.</p>

<p>由于西安目前还不是港澳自由行的城市, 因此还不能办理个人 G 签, 只能办理团队 L 签. 如果只想去香港, 那么只能从深圳找当地旅行团协助过关. 至于有效期及签注次数个人自行选择. 本人选择的是澳门 1 次有效签注, 有效期 1 年. 香港 2 次有效签注, 有效期 1年.</p>

<p>往来港澳通行证申请表格一式一份 1 张, 除了基本信息, 需要注意的是申请的签注类型, 首选个人 G 签, 如果所在城市不支持, 那工作人员会自动帮助你更改为团队 L 签. 如果需要邮寄的话, 需要在最后填写邮寄地址.</p>

<!-- more -->


<h2>大陆居民往来台湾地区通行证</h2>

<p>大陆居民往来台湾所持有的证件. 也被称做大通证, 大陆证, 陆胞证. 由大陆颁发. 申请的同时可以申请 G 签(必须是开放台湾自由行的城市). 1次有效签注, 有效期 6 个月.</p>

<p>想去台湾, 只有大陆居民往来台湾地区通行证和大陆的有效签注是不行的. 还需要台湾方面颁发的中华民国台湾地区入出境许可证. 这个证个人无法办理, 需要找有资质的旅行社代办, 具体细节以后更新.</p>

<p>大陆居民往来台湾地区通行证申请表格一式一份 1 张, 内容与往来港澳通行证区别不大. 开放台湾自由行的城市可以选择个人 G 签. 如果需要邮寄的话, 需要在最后填写邮寄地址.</p>

<h2>办理流程</h2>

<p>准备工作: <strong>黑色签字笔一支, 身份证原件, 户口本原件, 干净整洁的面容 (深色衣服, 照片是白底).</strong></p>

<p>2014 年 1 月 28 日, 14:50 到达西安市出入境管理中心, 先到西门上二楼,</p>

<ul>
<li>取表复印: 直接去取表复印处, 交出身份证以及户口本原件, 告诉工作人员需要办理的证件(本人一次办了护照, 港澳通行证, 台湾通行证), 专业人员, 直接把你的身份证, 户口本复印到表格相应的地方. 缴纳 1.5 元钱, 领表复印就结束了.</li>
<li>照相: 照相 30 元, 基本上是立等可取. 白底照片一共 5 张, 三个证件各用 1 张, 照片有个条形码, 办理手续的时候工作人员需要扫描.</li>
<li>填表: 等照片的过程可以先填表格, 3 个表格填起来还是需要些时间的. (PS: 取表复印, 照相顺序自行安排, 去的时候正是高峰期, 人山人海, 取表复印和照相都排队了一段时间. 表格填写好之后, 将剪裁完的照片成用浆糊贴到指定位置, 就可以排号准备办理了.)</li>
<li>办理, 拿申请回执单: 将三份贴好照片的申请表, 以及身份证原件, 户口本原件交给工作人员, 工作人员会核对信息开始办理, 护照的办理相对麻烦, 需要录入两个大拇指的指纹, 还需要用摄像头拍一下, 如果填写的信息都无误的话, 签字之后就可以拿着申请回执单去交费了. 回执单上写的取证日期是 2 月 14 日.</li>
<li>交费: 交费地点在东门一楼, 带着申请回执单去办理, 护照 220 元, 港澳通行证 160 元(根据签注次数, 以及有效期价格不同), 台湾通行证 70 元. 总计 450 元. <strong>不能现金</strong>, 刷了信用卡. 由于无法自取, 三个证件都办理了邮寄, 使用现金, 每个 22 元. 总计 66 元.</li>
<li>交还快递收据: 缴费, 办理邮寄时, 三个回执单都被收回, 拿到快递收据后, 再回到办理的工作人员那, 交出快递收据, 任务完成.</li>
</ul>


<p>任务达成时间 2014 年 1 月 28 日, 16:30</p>

<p>现在离出发去台湾还差一个台湾方面颁发的入台证了. 稍后更新. O(∩_∩)O~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]GotW #95 Solution: Thread Safety and Synchronization]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/19/gotw-95/"/>
    <updated>2014-01-19T23:54:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/19/gotw-95</id>
    <content type="html"><![CDATA[<p><em>原文地址: <a href="http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/">GotW #95 Solution: Thread Safety and Synchronization</a></em></p>

<p><em>这篇 GotW 是来回答一些关于线程安全与同步的问题的. 我们的讨论几乎适用于所有主流语言</em></p>

<h1>问题</h1>

<h2>JG 问题</h2>

<p><strong>1) 竞态条件(race condition)指的是什么? 它有很严重吗?</strong></p>

<p><strong>2) 什么是正确同步的程序? 你是如何实现的? 请具体说明.</strong></p>

<h2>Guru 问题</h2>

<p><strong>3) 考虑下面的代码, <code>some_obj</code> 是一个多个线程可见的共享变量.</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>如果线程 1 与线程 2 能够并行, 那么当 <code>some_ojb</code> 是如下类型时, 代码是否能够正确同步?</strong></p>

<ul>
<li>a) <code>int</code></li>
<li>b) <code>string</code></li>
<li>c) <code>vector&lt;map&lt;int,string&gt;&gt;</code></li>
<li>d) <code>shared_ptr&lt;widget&gt;</code></li>
<li>e) <code>mutex</code></li>
<li>f) <code>condition_variable</code></li>
<li>g) <code>atomic&lt;unsigned&gt;</code></li>
</ul>


<p><strong>提示: 虽然有 7 个类型, 但实际上答案只有两种.</strong></p>

<p><strong>4) 外部同步, 意味着使用共享对象的代码需要自己来保证对象的同步. 回答下面有关外部同步的问题:</strong></p>

<ul>
<li>a) 一般的外部同步的职责是什么?</li>
<li>b) 什么是&#8221;基本的线程安全保障&#8221;?</li>
<li>c) 哪些内部同步是在共享变量的实现中需要做的?</li>
</ul>


<p><strong>5) 完全的内部同步类型(线程安全类型), 意味着所有的同步在对象内部完成, 外部不需要再进行同步. 哪些类型是内部同步的, 为什么?</strong></p>

<!-- more -->


<h1>解决方案</h1>

<p><strong>1) 竞态条件(race condition)指的是什么? 它有很严重吗?</strong></p>

<p>当两个线程同时访问一个共享变量时, 并且至少有一个是 non-const 操作(写操作)时会发生竞态条件(race condition). 并发的 const 操作是允许的, 不会发生竞态条件.</p>

<p>如果发生了竞态条件, 那么你的程序会产生未定义行为 (undefined behavior).</p>

<p><em>准则: 针对共享变量的只读 (const) 操作, 在没有外部同步的情况下也是安全的.</em></p>

<p><strong>2) 什么是正确同步的程序? 你是如何实现的? 请具体说明.</strong></p>

<p>正确同步的程序指的是没有竞态条件的程序.</p>

<p>共享变量通常的保护方式有:</p>

<ul>
<li>通常使用 <code>mutex</code> 或其他类似的东西;</li>
<li>极少情况下使用 <code>atomic</code>;</li>
<li>极少情况下确认是内部同步的类型, 下面会讲到.</li>
</ul>


<p><strong>3) 考虑下面的代码, <code>some_obj</code> 是一个多个线程可见的共享变量.</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>如果线程 1 与线程 2 能够并行, 那么当 <code>some_ojb</code> 是如下类型时, 代码是否能够正确同步?</strong></p>

<ul>
<li>a) <code>int</code></li>
<li>b) <code>string</code></li>
<li>c) <code>vector&lt;map&lt;int,string&gt;&gt;</code></li>
<li>d) <code>shared_ptr&lt;widget&gt;</code></li>
</ul>


<p>不能. 代码中有一个线程对 some_obj 做读操作(const 操作), 而另一个线程对 <code>some_obj</code> 进行写操作. 如果这两个线程同时执行, 那么就有可能发生竞态条件.</p>

<p>要正确同步, 需要对 <code>some_obj</code> 的访问进行同步, 比如使用 <code>mutex</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span> <span class="n">hold</span><span class="p">(</span><span class="n">mut_some_obj</span><span class="p">);</span>     <span class="c1">// acquire lock</span>
</span><span class='line'>    <span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span> <span class="n">hold</span><span class="p">(</span><span class="n">mut_some_obj</span><span class="p">);</span>     <span class="c1">// acquire lock</span>
</span><span class='line'>    <span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>几乎所有类型, 包括 <code>shared_ptr</code> 以及 <code>vector</code> 以及其他类型, 他们的线程安全级别与 <code>int</code> 是一样的. 它们没有特别的为并行设计. 无论 <code>some_obj</code> 是一个 <code>int</code>, <code>string</code>, 容器, 还是智能指针类型, 并发读 (const 操作) 不需要同步也是安全的, 但是共享变量是可写的, 因此使用该变量的代码需要同步访问.</p>

<p>但是, 上面说的是 &ldquo;几乎所有类型&rdquo;, 指的是不包含内部同步的类, 那些类型设计的时候就是为了并发而来的.</p>

<p><strong>3) 考虑下面的代码, <code>some_obj</code> 是一个多个线程可见的共享变量.</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>如果线程 1 与线程 2 能够并行, 那么当 <code>some_ojb</code> 是如下类型时, 代码是否能够正确同步?</strong></p>

<ul>
<li>e) <code>mutex</code></li>
<li>f) <code>condition_variable</code></li>
<li>g) <code>atomic&lt;unsigned&gt;</code></li>
</ul>


<p>对上面的三个类型来说, 代码是 OK 的, 因为他们本身就是内部同步的, 所有不需要在外部再做同步.</p>

<p>实际上, 这些类型必须保证不需要外部同步时也是安全的, 因为这些同步原语, 是你用来保证其他变量同步的工具.</p>

<p><em>准则: 只有当一个类型的目的是线程间通讯 (如: 消息队列) 或同步(如: mutex)时, 这个类型才需要是内部同步的</em></p>

<p><strong>4) 外部同步, 意味着使用共享对象的代码需要自己来保证对象的同步. 回答下面有关外部同步的问题:</strong></p>

<p>a) 一般的外部同步的职责是什么?</p>

<p>同步的职责很简单: 当有可写的共享变量时, 需要同步访问它. 典型的做法是使用 <code>mutex</code> 或类似的东西, 或者如果可行的话将该类型变为 <code>atomic</code>.</p>

<p><em>准则: 如果代码中访问了可写的共享变量, 那么需要对他进行访问同步.</em></p>

<p>b) 什么是&#8221;基本的线程安全保障&#8221;?</p>

<p>如果要保证上面描述的东西是正确的, 那么对象本身必须有如下两个保证.</p>

<p>首先, 并行访问两个实例对象必须是安全的. 比如, 类 <code>X</code> 有两个对象 <code>x1</code> 和 <code>x2</code>, 每个对象都仅在自己的线程中使用. 考虑下面的情形:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case A: Using distinct objects</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">x1</span><span class="p">.</span><span class="n">something</span><span class="p">();</span>                   <span class="c1">// do something with x1</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">x2</span> <span class="o">=</span> <span class="n">something_else</span><span class="p">;</span>              <span class="c1">// do something else with x2</span>
</span></code></pre></td></tr></table></div></figure>


<p>这必须始终是正确同步的. 记住, 这里的 <code>x1</code> 和 <code>x2</code> 是两个对象, 而不是别名或类似的东西.</p>

<p>另外, 并发的 const 操作, 也就是只读操作必须是安全的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case B: const access to the same object</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">x</span><span class="p">.</span><span class="n">something_const</span><span class="p">();</span>              <span class="c1">// read from x (const operation)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">x</span><span class="p">.</span><span class="n">something_else_const</span><span class="p">();</span>         <span class="c1">// read from x (const operation)</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码也是正确同步的. 没有外部同步时他们也能很好的工作. 这不是一个竞态条件. 因为这两个线程都仅仅是对共享变量进行读操作.</p>

<p>这把我们带到了同时需要外部同步和内部同步的情形.</p>

<p>c) 哪些内部同步是在共享变量的实现中需要做的?</p>

<p>在某些类, 对象中表面上看起来他们是不同的, 但实际上仍然共享着某些状态, 而不需要调用者做任何事情来指定幕后的连接状态. 注意这不是前面准则的例外, 这是和前面一样的准则.</p>

<p><em>准则: 如果代码中访问了可写的共享变量, 那么需要对他进行访问同步. 这始终是正确的. 如果可写的共享变量隐藏在类实现的内部, 那么仅仅对那部分共享变量的访问做同步即可.</em></p>

<p>引用计数, 就是上面所描述的内部共享状态, 下面的两个例子是 <code>std::shared_ptr</code> 以及 copy-on-write. 下面来看 <code>shared_ptr</code> 的例子.</p>

<p>像 <code>shared_ptr</code> 一样的带有引用计数的智能指针会在对象内部保存引用计数信息. 下面来看两个不同的 <code>shared_ptr</code> 对象 <code>sp1</code> 与 <code>sp2</code>, 每一个都仅在自己的线程中使用. 考虑下面的情形:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case A: Using distinct objects</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sp1</span><span class="p">;</span>                      <span class="c1">// read from sp1 (writes the count!) </span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">sp2</span> <span class="o">=</span> <span class="n">something_else</span><span class="p">;</span>              <span class="c1">// write to sp2 (writes the count!)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个代码会正确同步, 而且完全不需要外部同步. 没错&hellip;</p>

<p>但是, 如果 <code>sp1</code> 与 <code>sp2</code> 指向同一个对象, 共享引用计数信息时呢? 这时, 引用计数信息是一个可写的共享变量, 它必须同步访问来避免竞态条件, 但是这基本是无法在外部调用代码中完成的, 因为我们甚至都感知不到它存在共享的内容. 我们看不到引用计数的大小, 也不知道他的变量名, 也不知道还有谁正在共享.</p>

<p>类似的, 我们看下面代码, 两个线程只从同一个变量 <code>sp</code> 中读取内容:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case B: const access to the same object</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">sp3</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>                     <span class="c1">// read from sp (writes the count!)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">sp4</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>                     <span class="c1">// read from sp (writes the count!)</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码不需要外部同步也可以正确同步. 这不是竞态条件, 因为这两个线程对 <code>sp</code> 都进行的是只读的 const 操作. 但在内部共享的引用计数是可写的, 它们需要正确同步来避免竞态条件, 像上面所说, 我们不可能在调用代码中保证它正确同步, 因为我们甚至不知道有共享的内容.</p>

<p>因此要处理这种情形, 以 <code>shared_ptr</code> 的引用计数为例, 典型的做法是将引用计数变量更改为 mutable atomic 类型.</p>

<p>为了完整, 我们再看需要外部同步的情形. 像上面说说的, 当多线程共享 <code>shared_ptr</code> 可写对象时, 仍然是需要外部同步的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case C: External synchronization still required as usual</span>
</span><span class='line'><span class="c1">//         for non-const access to same visible shared object</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span> <span class="n">hold</span><span class="p">(</span><span class="n">mut_sp</span><span class="p">);</span>           <span class="c1">// acquire lock</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">sp3</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>                     <span class="c1">// read from sp</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span> <span class="n">hold</span><span class="p">(</span><span class="n">mut_sp</span><span class="p">);</span>           <span class="c1">// acquire lock</span>
</span><span class='line'>    <span class="n">sp</span> <span class="o">=</span> <span class="n">something_else</span><span class="p">;</span>               <span class="c1">// modify sp</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以, <code>shared_ptr</code> 不是内部同步的类型, 如果调用者需要在多个线程中共享该类型的可写变量, 那么必须像问题 3(d) 中那样, 在外部做同步访问.</p>

<p>那么内部同步的目的是什么? 它仅仅做那些外部不可见, 外部无法做同步, 而内部需要共享的内容的同步. 这样一来外部就能使用通常的做法来保证正确同步了.</p>

<p>对于 copy-on-write 来说, 情况和引用计数也类似.</p>

<p><em>准则: 如果你设计一个类, 如果两个对象实例之间有外部看不到的 <code>mutable</code> 共享状态, 那么保证这个共享状态能够正确同步是你的职责, 因为这个共享状态对外部来说是未知的.</em></p>

<p>为什么内部共享状态是 <code>mutable</code> 的, 请看 GotW #6a 和 #6b.</p>

<p><strong>5) 完全的内部同步类型(线程安全类型), 意味着所有的同步在对象内部完成, 外部不需要再进行同步. 哪些类型是内部同步的, 为什么?</strong></p>

<p>只有一种类型需要完全的内部同步, 不需要外部的同步就能保证并发的安全, 那就是: 线程间同步和通讯的原语. 这包括标准库中的 <code>mutex</code>, <code>atomic</code>, 还有你可能自己会写的线程间通信的消息队列, 生产者/消费者的活动对象, 或者一个线程安全的计数器.</p>

<p>如果你想知道是否还有其他的类型也应该做成内部同步的话, 请考虑: 只有那些你能明确知道,这个类型一旦创建,  那它就是要共享给多个线程来做可写访问的时候, 你猜需要让这个类型是内部同步的&hellip; 这个语义同时也意味着这个类型就是为了线程间通讯以及同步而设计的.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[why make_shared ?]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/12/why-make-shared/"/>
    <updated>2014-01-12T21:01:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/12/why-make-shared</id>
    <content type="html"><![CDATA[<p>C++11 中引入了智能指针, 同时还有一个模板函数 <code>std::make_shared</code> 可以返回一个指定类型的 <code>std::shared_ptr</code>, 那与 <code>std::shared_ptr</code> 的构造函数相比它能给我们带来什么好处呢 ?</p>

<h2>优点</h2>

<h3>效率更高</h3>

<p><code>shared_ptr</code> 需要维护引用计数的信息,</p>

<ul>
<li>强引用, 用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放).</li>
<li>弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话).</li>
</ul>


<p>如果你通过使用原始的 new 表达式分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">widget</span><span class="p">();</span>
</span><span class='line'><span class="n">shared_ptr</span> <span class="n">sp1</span><span class="p">{</span> <span class="n">p</span> <span class="p">},</span> <span class="n">sp2</span><span class="p">{</span> <span class="n">sp1</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://y6bhba.bay.livefilestore.com/y1pDu8kORu85CKSKHFVBvapxrccVoMAjc8W0d6mScWwunuhqV8n25QZKgZhM6MPtFGV1c6dPgjil7g/sharedptr1.png" alt="" /></p>

<p>如果选择使用 <code>make_shared</code> 的话, 情况就会变成下面这样:</p>

<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">sp1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="p">(),</span> <span class="n">sp2</span><span class="p">{</span> <span class="n">sp1</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://y6yska.bay.livefilestore.com/y1p-Y0XAkcMZMrSdxkTa85nShcDkVKvqhMTFVGSDc0jURLybPXTGHPdWv9CZGgcGmvZwQQvd6Y1Qdg/sharedptr2.png" alt="" /></p>

<p>内存分配的动作, 可以一次性完成. 这减少了内存分配的次数, 而内存分配是代价很高的操作.</p>

<p>关于两种方式的性能测试可以看这里 <a href="http://tech-foo.blogspot.hk/2012/04/experimenting-with-c-stdmakeshared.html">Experimenting with C++ std::make_shared</a></p>

<h3>异常安全</h3>

<p>看看下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">F</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">F</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Lhs</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">)),</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Rhs</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++ 是不保证参数求值顺序, 以及内部表达式的求值顺序的, 所以可能的执行顺序如下:</p>

<ol>
<li>new Lhs(&ldquo;foo&rdquo;))</li>
<li>new Rhs(&ldquo;bar&rdquo;))</li>
<li>std::shared_ptr<Lhs></li>
<li>std::shared_ptr<Rhs></li>
</ol>


<p>好了, 现在我们假设在第 2 步的时候, 抛出了一个异常 (比如 out of memory, 总之, Rhs 的构造函数异常了), 那么第一步申请的 Lhs 对象内存泄露了. 这个问题的核心在于, shared_ptr 没有立即获得裸指针.</p>

<p>我们可以用如下方式来修复这个问题.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Lhs</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">));</span>
</span><span class='line'><span class="k">auto</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Rhs</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">));</span>
</span><span class='line'><span class="n">F</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然, 推荐的做法是使用 <code>std::make_shared</code> 来代替:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">F</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>缺点</h2>

<h3>构造函数是保护或私有时,无法使用 make_shared</h3>

<p><code>make_shared</code> 虽好, 但也存在一些问题, 比如, 当我想要创建的对象没有公有的构造函数时, <code>make_shared</code> 就无法使用了, 当然我们可以使用一些小技巧来解决这个问题, 比如这里 <a href="http://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const?rq=1">How do I call ::std::make_shared on a class with only protected or private constructors?</a></p>

<h3>对象的内存可能无法及时回收</h3>

<p><code>make_shared</code> 只分配一次内存, 这看起来很好. 减少了内存分配的开销. 问题来了, <code>weak_ptr</code> 会保持控制块(强引用, 以及弱引用的信息)的生命周期, 而因此连带着保持了对象分配的内存, 只有最后一个 <code>weak_ptr</code> 离开作用域时, 内存才会被释放. 原本强引用减为 0 时就可以释放的内存, 现在变为了强引用, 若引用都减为 0 时才能释放, 意外的延迟了内存释放的时间. 这对于内存要求高的场景来说, 是一个需要注意的问题. 关于这个问题可以看这里 <a href="http://lanzkron.wordpress.com/2012/04/22/make_shared-almost-a-silver-bullet/">make_shared, almost a silver bullet</a></p>

<h2>参考</h2>

<ul>
<li><a href="http://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/">GotW #89 Solution: Smart Pointers</a></li>
<li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">cppreference.com &ndash; std::make_shared</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当 Windows API 遇上 RAII]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/06/windows-api-raii/"/>
    <updated>2014-01-06T00:18:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/06/windows-api-raii</id>
    <content type="html"><![CDATA[<h2>什么是 RAII (Resource Acquisition Is Initialization) ?</h2>

<p>RAII (Resource Acquisition Is Initialization), 也称为&#8221;资源获取就是初始化&#8221;, 是 C++ 语言的一种管理资源, 避免泄漏的惯用法. C++ 标准保证任何情况下, 已构造的对象最终会销毁, 即它的析构函数最终会被调用. 简单的说, RAII 的做法是使用一个对象, 在其构造时获取资源, 在对象生命期控制对资源的访问使之始终保持有效, 最后在对象析构的时候释放资源.</p>

<p>RAII 是保证代码异常安全的重要基础设施. RAII 的使用场景有很多, 如: C++11 中的智能指针, scope lock, scope exit 等等. (早在2000年，<a href="http://erdani.com/">Andrei Alexandrescu</a> 就在DDJ杂志上发表了一篇文章，提出了这个叫做 <a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758">ScopeGuard</a> 的设施)</p>

<h2>当 Windows API 遇上 RAII</h2>

<p>Windows API 大多是 C 语言风格的函数和句柄, 或者是 COM 风格的接口, 这些用起来都不太方便, 需要进行一定的封装. 至于为什么要封装就不用多说了, 如果你想要异常安全, 想要不必在每个分支中都写清理代码的话, 你一定知道利用 RAII 封装的意义.</p>

<p>ATL 中有对 COM 接口的封装, 智能指针 <code>CComPtr</code>, <code>CComQIPtr</code> 解决了一遍遍的手工 <code>Release</code> 以及 <code>QueryInterface</code>. 但对于普通的 C 语言风格的函数和句柄呢? 难道还要一遍遍的 <code>CloseHandle</code> , <code>ReleaseDC</code>, <code>GlobalUnlock</code> 麽? 弱爆了.</p>

<p>借助 <code>ScopeGuard</code> 和 lambda 表达式(⊙_⊙)？ 可以是可以, 但是并不是所有的资源获取都会成功, 那么每次都要产生一个具名的 <code>ScopeGuard</code>, 在申请失败的时候调用 <code>Dismiss</code>, 取消清理的动作嘛? 像这样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Acquire</span> <span class="n">Resource1</span>
</span><span class='line'><span class="n">ScopeGuard</span> <span class="n">release1</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource1 */</span> <span class="p">})</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">release1</span><span class="p">.</span><span class="n">Dismiss</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Acquire</span> <span class="n">Resource2</span>
</span><span class='line'><span class="n">ScopeGuard</span> <span class="n">release2</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource2 */</span> <span class="p">})</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">release2</span><span class="p">.</span><span class="n">Dismiss</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>这样如果连续申请多个资源 <code>ScopeGuard</code> 对象命名都会成为问题. 又或者是先判断资源是否申请成功, 然后再使用匿名的 <code>ScopeGuard</code> 来保证正确释放资源? 像这样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Acquire</span> <span class="n">Resource1</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">ON_SCOPE_EXIT</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource1 */</span> <span class="p">})</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">Acquire</span> <span class="n">Resource2</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">ON_SCOPE_EXIT</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource2 */</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样好是好, 可是割裂了申请与释放的代码, 而且每申请一个资源就要至少写上 3 行或以上结构类似代码(可以考虑宏了) ?</p>

<p>当然, 我们是有追求的, 我们还需要更厉害的设施. 也许 <code>unique_ptr</code> 可以给我提供一些思路. 我们需要一个基本的类型, 也许是 <code>HANDLE</code>, 也许是 <code>HINTERNET</code> 等等, 同时我们还需要一个清理函数. 再加上一个资源是否可用的接口即可. 为了避免过多的模板参数, 我们把清理函数以及不可用资源封装到 <code>Traits</code> 类中, 下面是一个例子, 可以很好的完成我们的需求. 另外仿照 <code>unique_ptr</code> 加了一些 move 语义, 转移构造等东西. 下面的代码只实现了 <code>HANDLE</code> 的特化版本, 相信 <code>HINTERNET</code> 的版本, 大家写起来应该也是毫无压力了. 只需要写 <code>Traits</code> 类即可.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Traits</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">unique_handle</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">bool_struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">member</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">bool_type</span> <span class="o">=</span> <span class="kt">int</span> <span class="n">bool_struct</span><span class="o">::*</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">explicit</span> <span class="n">unique_handle</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Traits</span><span class="o">::</span><span class="n">invalid</span><span class="p">())</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">unique_handle</span><span class="p">(</span><span class="n">unique_handle</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">release</span><span class="p">())</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">unique_handle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_handle</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">reset</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">unique_handle</span><span class="p">()</span> <span class="p">{</span> <span class="n">close</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">T</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">reset</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Traits</span><span class="o">::</span><span class="n">invalid</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">value_</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">close</span><span class="p">();</span>
</span><span class='line'>      <span class="n">value_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">T</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value_</span><span class="p">;</span>
</span><span class='line'>    <span class="n">value_</span> <span class="o">=</span> <span class="n">Traits</span><span class="o">::</span><span class="n">invalid</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">operator</span> <span class="n">bool_type</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Traits</span><span class="o">::</span><span class="n">invalid</span><span class="p">()</span> <span class="o">!=</span> <span class="n">value_</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">bool_struct</span><span class="o">::</span><span class="n">member</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">unique_handle</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_handle</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">unique_handle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_handle</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_handle</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_handle</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">close</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">Traits</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">value_</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">handle_traits</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">HANDLE</span> <span class="n">invalid</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">void</span> <span class="n">close</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="n">unique_handle</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">handle_traits</span><span class="o">&gt;</span> <span class="n">handle</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用起来应该是这样的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">unique_handle</span><span class="o">&lt;</span><span class="n">SOCKET</span><span class="p">,</span> <span class="n">socket_traits</span><span class="o">&gt;</span> <span class="n">socket</span><span class="p">;</span>
</span><span class='line'><span class="n">unique_handle</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">handle_traits</span><span class="o">&gt;</span> <span class="n">event</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Are both valid?</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Is event invalid?</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">socket</span><span class="p">;</span> <span class="c1">// Compiler error!</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">==</span> <span class="n">event</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Compiler error!</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>int i = socket;</code> 这一句很有意思, 我们为了让它能够编译失败, 费了不少功夫. 内部类 <code>bool_struct</code> 就是完全为它而准备. 这也是为什么我们不直接提供 <code>operator bool</code> 的原因. 私有化 <code>operator==</code> 和 <code>operator!=</code> 是为了禁止两个资源进行比较. 而使用内部类成员指针就是为了提供 <code>operator bool</code> 类似功能的同时, 避免它能够提升为 <code>int</code> 等类型. 当然如果我们直接提供一个 <code>is_valid</code> 成员函数, 而不提供隐身转换, 那么就不会有这么多的问题了.</p>

<p>看起来还差错误处理的内容, 不过都到这个份上了, 错误处理就不是问题了吧. 我们可以写各种 <code>check</code> 函数的重载版本, 当 <code>check</code> 失败时抛出异常. 这样就大功告成了.</p>

<h2>参考</h2>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a></li>
<li><a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/">C++11（及现代C++风格）和快速迭代式开发</a></li>
<li><a href="http://msdn.microsoft.com/en-us/magazine/hh288076.aspx">C++ and the Windows API</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步编程和延续传递风格]]></title>
    <link href="http://bitdewy.github.com/blog/2013/12/23/cps-async/"/>
    <updated>2013-12-23T00:51:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/12/23/cps-async</id>
    <content type="html"><![CDATA[<h2>什么是延续传递风格(Continuation-passing Style)?</h2>

<p>Continuation-passing style(CPS) 是指将控制流 (Control flow) 显式的当做参数传递的编程风格. 函数的返回不在通过 return 语句, 而是将返回值当做参数, 调用控制流. 延续传递风格的函数都会有一个额外的参数k, 显式的表示了continuation (可以理解成控制流的流向, what comes next). 当延续传递风格函数需要返回的时候, 调用k, 并将返回值作为k的参数.</p>

<p>延续传递风格的函数都有一个额外的参数 k, 表示控制流. 函数需要返回, 必须显式的调用 k.
在函数的末尾调用了另外一个函数, 这种调用称为尾调用, tail call. 相应的在尾部递归调用, 称之为尾递归, tail recursion. 延续传递风格的所有函数都是尾调用.</p>

<p>看一个实际的例子, 假设我们有一个函数 <code>show</code> 可以用来打印一些东西, 通常的做法是我们调用一个函数然后存储或者修改它的返回值, 然后把它传给下一个函数,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">show</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">make_one</span> <span class="o">=</span> <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// prints 1</span>
</span><span class='line'><span class="n">show</span><span class="p">(</span><span class="n">make_one</span><span class="p">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>在延续传递风格中, 函数需要增加一个参数用来处理函数返回的结果, 它是这个函数处理完之后需要的后续处理,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">one_cont</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">k</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Also prints 1</span>
</span><span class='line'><span class="n">one_cont</span><span class="p">(</span><span class="n">show</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用延续传递风格最初主要用于编译高级语言时一种中间代码表示, 有了这种中间代码, 编译器的复杂度大大降低. 各种的控制流都能变为 CPS. 有很多办法可以将非 CPS 代码自动转换为 CPS 的代码. 有兴趣可以去研究下 <a href="http://book.douban.com/subject/1762126/">Compiling with Continuations</a> 这本书.</p>

<!-- more -->


<h2>函数式编程与延续传递风格</h2>

<p>函数式编程的控制流就是靠 CPS 实现的.</p>

<p>数学上的 “函数” 简而言之是 “集到集的映射”, 而指令式编程语言的 “函数” 与之有大不同. 数学关心返回集是什么, 而指令式编程语言根本不在乎有没有值返回, 它关心的是过程控制权的返回.其实, 指令式编程语言中 “函数” 本质是 “子过程”.</p>

<p>指令式编程语言本质上是 “子过程” 的 “函数” 是有状态的, 这就决定了它永远无法消除副作用 (side-effect), 这是多线程应用的巨大隐患. 而 CPS (函数式编程)在异步编程里, 分布式编程里大显身手.指令式编程语言对程序员的洗脑使计算机专业的学生的思维背离了人类应有的数学性和抽象性. 太多的人专注于前置自增与后置自增的区别, 专注于常指针与指针常量的区别, 专注于是用 if-else 还是用 switch-case 的问题, 等等. 这些本不应该是让程序员费心的问题却牵扯了程序员太多的心力. 虽然 C++ 引入了 lambda, 但依然把上述的问题留了下来.</p>

<h2>异步编程与延续传递风格</h2>

<p>多线程异步调用是 CPS 一展身手的地方. 闭包封闭处理过程, 却对线程开放. 闭包安排好线程间数据处理的顺序, 于是线程间便不用轮询等待, 就可以分步按序完成一系列操作. 目前比较火的 node.js 最大的优点就是 non-blocking programming. 在 node.js中, 所有原本可能阻塞的操作全部都接受一个 callback, 当请求完成的时候调用 callback. 这种通过 callback 进行异步编程的风格是不完全的 CPS, callback 可以看成 continuation.</p>

<p>当然 javascript 这种 callback 机制有一个很大的问题就是容易陷入 callback hell, 现在已经有很多异步的库可以帮助程序员远离 callback hell, 据说 coffeescript 也在这方面提供了支持.</p>

<p>在 C++11 引入 lambda 之后我们也可以这么干, 但我们有更好用的, 那就是 <code>std::future</code> 以及 <code>std::promise</code> 了 (不过 <code>future.then</code> 可能要等到 C++17 才能成为标准), 之所以说更好用是因为 promise 以一种全新的方式对问题建模, 它的作用不仅是给基于 callback 的异步实现找一个语法更清晰的写法. 它要比语法层面的变化更深入, 实际上是在语义层上改变了解决问题的方式. 有兴趣可以看看这篇 <a href="http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/">Promises are the monad of asynchronous programming</a>. 关于什么是 monad 可以看看这篇 <a href="http://zhuoqiang.me/what-is-monad.html">Monad 最简介绍</a>, 总之基于 callback 的函数接受一些输入和一个 callback, 然后用它的输出调用这个 callback 函数, 而基于 promise 的函数接受输入, 返回输出的 promise 值, 基于 callback 的函数返回的那些 null 值就是基于 callback 编程之所以艰难的源头, 基于 callback 的函数什么都不返回, 所以难以把它们组装到一起. 没有返回值的函数, 执行它仅仅是因为它的副作用&mdash;没有返回值或副作用的函数就是个黑洞. 所以用 callback 编程天生就是指令式的, 是编写以副作用为主的过程的执行顺序, 而不是像函数应用那样把输入映射到输出. 是手工编排控制流, 而不是通过定义值之间的关系来解决问题. 因此使编写正确的并发程序变得艰难.</p>

<p>而基于 promise 的函数与之相反, 你总能把函数的结果当作一个与时间无关的值. 在调用基于 callback 的函数时, 在你调用这个函数和它的 callback 被调用之间要经过一段时间, 而在这段时间里, 程序中的任何地方都找不到表示结果的值. 所以尽管 <code>then()</code> 这个方法的名字让人觉得它跟某种顺序化的操作有关, 并且那确实是它所承担的职责的副产品, 但你真的可以把它当作 unwrap 来看待. promise 是一个存放未知值的容器, 而 then 的任务就是把这个值从 promise 中提取出来, 把它交给另一个函数, 从 monad 的角度来看就是 bind 函数. 总之它才是更函数式的解决方案.</p>

<p>但是, 当到处充斥着 <code>.then()</code> 的时候我们的脑细胞肯定会死的非常快, 之前在这篇 <a href="http://bitdewy.github.io/blog/2013/08/20/async-and-await/">异步编程 async &amp; await</a> 中提到过, Sutter 在 <a href="http://channel9.msdn.com/Events/Build/2013/2-306">The future of C++</a>中提到了类似的问题, 我们可能会写出这样的代码, 貌似也进入了 callback hell 类似的情景,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'>   <span class="p">.</span><span class="n">then</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">fi</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span>
</span><span class='line'>         <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">task</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span>
</span><span class='line'>      <span class="p">[</span><span class="o">=</span><span class="p">]{</span>
</span><span class='line'>         <span class="n">fi</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
</span><span class='line'>         <span class="p">.</span><span class="n">then</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span> <span class="n">chunk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>               <span class="o">*</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
</span><span class='line'>               <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)();</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
</span><span class='line'>         <span class="p">});</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)();</span>
</span><span class='line'>   <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>好在我们有解决方案, 像写同步代码一样来写异步代码,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span> <span class="p">)</span> <span class="n">__async</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">__await</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">,</span> <span class="n">chunk</span><span class="p">;</span>
</span><span class='line'>   <span class="k">while</span><span class="p">((</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">__await</span> <span class="n">fi</span><span class="p">.</span><span class="n">read</span><span class="p">()).</span><span class="n">size</span><span class="p">())</span>
</span><span class='line'>      <span class="n">ret</span> <span class="o">+=</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a> 提案相信也会成为 C++17 的标准. 而本质上这只是把 CPS 变成了编译器要做的事情而已.</p>

<h2>参考</h2>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Continuation-passing_style">Continuation-passing style</a></li>
<li><a href="http://channel9.msdn.com/Events/Build/2013/2-306">The future of C++</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 std::tuple 和它的应用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/12/08/cpp11-tuple/"/>
    <updated>2013-12-08T17:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/12/08/cpp11-tuple</id>
    <content type="html"><![CDATA[<p>模板类 <code>std::tuple</code> 是一个固定大小, 存储元素类型不同的集合. 它是 <code>std::pair</code> 的泛化版本.</p>

<p>一个 tuple 可以显示的声明它每个元素的类型, 也可以用 <code>std::make_tuple</code> 模板函数来实现自动类型推导. 可以用 <code>std::get</code> 指定索引来访问 tuple 中的元素. 如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">(</span><span class="s">&quot;bitdewy&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;bitdewy&quot;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">);</span>   <span class="c1">// t will be of type tuple&lt;string, int, double&gt;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'><span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当编译期我们需要一个存放不同类型数据的集合, 但又不想定义一个具名的类时 tuple 是非常有用的. 例如 <code>std::function</code> 和 <code>std::bind</code> 就使用 tuple 来存放参数(我们都知道 <code>std::bind</code> 从第二个参数开始, 就是函数的参数了, 参数个数是不定的, 类型也是不定的, 这太适合用 <code>tuple</code> 来定义以及存储函数参数列表了). 尤其是 C++11 开始支持变长模板参数了, 这样一来 tuple 就变得更方便了.</p>

<h2>std::tie</h2>

<p>很多时候我们都希望函数能够返回两个或者更多个值, <code>std::tie</code> 可以帮助我们解决这个问题. <code>std::tie</code> 会构造一个每个元素都是左值引用的 <code>std::tuple</code>. 所以当一个函数返回一个 <code>std::tuple</code> 时, 我们可以使用 <code>std::tie</code> 构造一个 <code>std::tuple</code> 来接收这些返回值. 同时, 如果我们的类的每个元素都支持比较的话, 我们还可以直接使用它来构造一个 <code>std::tuple</code> 来使用 <code>std::tuple</code> 的比较函数. 如下:</p>

<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="cp">#include &lt;set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;tuple&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">n</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">s</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">d</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">set_of_s</span><span class="p">;</span> <span class="c1">// S is LessThanComparable</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">S</span> <span class="n">value</span><span class="p">{</span> <span class="mi">42</span><span class="p">,</span> <span class="s">&quot;Test&quot;</span><span class="p">,</span> <span class="mf">3.14</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">inserted</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// unpacks the return value of insert into iter and inserted</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">inserted</span><span class="p">)</span> <span class="o">=</span> <span class="n">set_of_s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">inserted</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Value was inserted successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>tuple_visitor</h2>

<p>visitor 模式是 GoF 书中描述的 23 种设计模式中最难懂的一个. 这个模式甚至让 <a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">Scott Meyers</a> 都困惑了一阵, 显然这个模式的名字没有取好, 而且例子中继承过来继承过去的绕了很多道弯很容易就让你搞不清楚它到底是在做什么的了.</p>

<p>回顾一下我们熟悉的虚函数, 本质上虚函数的作用是<strong>在不改变行为的基础上可以任意扩展类型</strong>, 也就是说我们可以在不更改原有代码的情况下, 将新的类型插入到我们原有的系统中而不需要更改原有系统的代码.</p>

<p>而 visitor 模式只是从另一个角度进行了解耦, 本质上 visitor 模式的作用是<strong>在不改变类型的基础上可以任意扩展对类型的操作</strong>.</p>

<p>不明白上面两句话的可以看看这两篇<a href="http://www.cnblogs.com/geniusvczh/archive/2013/05/25/3098496.html">如何设计一门语言（五）——面向对象和消息发送</a>, <a href="http://www.cnblogs.com/geniusvczh/p/3416833.html">如何设计一门语言（十二）——设计可扩展的类型</a>文章.</p>

<p>之前介绍过 <a href="http://bitdewy.github.io/blog/2013/07/15/static-visitor/">boost.variant.static_visitor</a>, 没有了一个一个的继承,写起来比原始的 visitor 模式简单很多, 如果写过 parser 生成过 AST 然后对它操作的话, 那么你可能对 visitor 有更深刻的理解, 本质上它就是函数式语言中含有<strong>模式匹配</strong>的递归函数.</p>

<p>模式匹配不是什么新玩意儿, 事实上, 它甚至和函数式编程的关系都不大. 把产生模式匹配归因于函数式编程的唯一的原因是函数式语言早就提供了模式匹配, 然而现在的命令式语言还大多做不到. C++ 中的模板特化实际上就是一种模式匹配(类型模式). 比如 <code>std::enable_if</code> 里面经常要用到的 type traits. 下面是一个最简单的模式匹配的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Factorial</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Base case via template specialization:</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这可能是每一个介绍模板元编程都要使用的一个例子, 它利用模式匹配成功的消灭了分支, 进行了编译期的运算, 当然这是个只能演示而没有什么实际意义的代码. 但是表达了模式匹配的意义,</p>

<p>回到正题, 继续我们的 visitor, 有时候我们有遍历 <code>tuple</code> 中存储元素的需求, 最简单的比如按顺序打印, 也许还有其他的针对每个元素的操作, 理论上这和 visitor 模式是类似的. 简单的实现如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;tuple&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">int_</span><span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Functor</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">tuple_visitor_impl</span><span class="p">(</span><span class="n">Functor</span><span class="o">&amp;&amp;</span> <span class="n">functor</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">int_</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">functor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Functor</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Pos</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">tuple_visitor_impl</span><span class="p">(</span><span class="n">Functor</span><span class="o">&amp;&amp;</span> <span class="n">functor</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">int_</span><span class="o">&lt;</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">functor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">-</span> <span class="n">Pos</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span><span class='line'>  <span class="n">tuple_visitor_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">functor</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">int_</span><span class="o">&lt;</span><span class="n">Pos</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Functor</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">tuple_visitor</span><span class="p">(</span><span class="n">Functor</span><span class="o">&amp;&amp;</span> <span class="n">functor</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">tuple_visitor_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">functor</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">int_</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">F</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;unexpect type: &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void F::operator()(int): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void F::operator()(double): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void F::operator()(const std::string&amp;): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">),</span> <span class="mf">3.14</span><span class="p">);</span>
</span><span class='line'>  <span class="n">F</span> <span class="n">f</span><span class="p">;</span>
</span><span class='line'>  <span class="n">tuple_visitor</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然 F 中要有针对每个类型的 <code>operator()</code>, 这样才能保证每个类型的 <code>tuple</code> 元素都能得到正确的处理, 当然由于我们有泛型版本的 <code>operator()</code> 所以任何类型都能正确接收, 只是行为不正确而已, 上面的代码中是打印出了数据类型, 更好的做法可能是抛出一个异常. 例子中的 <code>operator()</code> 都是重载, 实际上改为特化会更具通用性, 因为一旦改为特化, 那么 <code>struct F</code> 就可以变成框架内的细节, 可以做一些额外的工作. 当用户想要使用 <code>tuple_visitor</code> 的时候, 只需要针对 <code>tuple</code> 中的元素类型, 特化自己的 <code>F::operator()</code> 就可以了.</p>

<h2>tuple_expander</h2>

<p>还记得最上面介绍 <code>tuple</code> 的时候说的, <code>std::bind</code> 是用 <code>tuple</code> 来存储函数参数的吗? 那么由参数构造一个 <code>tuple</code> 是很显而易见的, 那么如何展开一个 <code>tuple</code> 呢?
这里有一个实现, 可以作为参考. <a href="https://github.com/bitdewy/snippet/blob/master/utility/expander.hpp">snippet/utility/expander.hpp</a></p>

<h2>参考</h2>

<ul>
<li>cppreference.com <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crypto++ 试用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/11/18/cryptopp-aes-rsa/"/>
    <updated>2013-11-18T00:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/11/18/cryptopp-aes-rsa</id>
    <content type="html"><![CDATA[<p>由于某些需求, 需要研究一下加密解密的相关内容, 于是找到了 crypto++, 常见的加密算法, 这里面差不多都有了, 但是想用的话, 还是需要先补一下密码学相关的基础知识.</p>

<h2>对等加密</h2>

<p>对等加密 (Reciprocal cipher) 又称为对称密钥加密 (Symmetric-key algorithm), 对称加密, 私钥加密, 共享密钥加密, 是密码学中的一类加密算法. 该类密码的加密算法是它自己本身的逆反函数, 所以其解密算法等同于加密算法, 也就是说, 要还原对等加密的密文, 套用加密同样的算法即可得到明文. 换句话说, 若参数 (或密钥) 合适的话, 两次连续的对等加密运算后会回复原始文字. 在数学上, 这有时称之为对合. 在实际应用中, 体现为加密和解密使用同一个密钥, 或者知道一方密钥能够轻易计算出另一方密钥.</p>

<p>常见的对称加密算法有 DES, 3DES, AES, Blowfish, IDEA, RC4, RC5, RC6.</p>

<p>在对称钥匙密码学中, 加密和解密使用相同的钥匙, 也许对不同的信息使用不同的钥匙, 但都面临钥匙管理的难题. 由于每对通讯方都必须使用异于他组的钥匙, 当网络成员的数量增加时, 钥匙数量成二次方增加. 更尴尬的难题是: 当安全的通道不存在于双方时, 如何建立一个共有的钥匙以利安全的通讯? 如果有通道可以安全地建立钥匙, 何不使用现有的通道. 这个 &ldquo;鸡生蛋, 蛋生鸡&rdquo; 的矛盾是长年以来密码学无法在真实世界应用的阻碍.</p>

<h2>公开密钥加密</h2>

<p>公开密钥加密 (英语: Public-key cryptography, 也称为非对称(密钥)加密), 该思想最早由雷夫·莫寇 (Ralph C. Merkle) 在 1974 年提出, 之后在 1976 年. 狄菲 (Whitfield Diffie) 与赫尔曼 (Martin Hellman) 两位学者以单向函数与单向暗门函数为基础, 为发讯与收讯的两方创建密钥.</p>

<p>非对称密钥, 是指一对加密密钥与解密密钥, 这两个密钥是数学相关, 用某用户密钥加密后所得的信息, 只能用该用户的解密密钥才能解密. 如果知道了其中一个, 并不能计算出另外一个. 因此如果公开了一对密钥中的一个, 并不会危害到另外一个的秘密性质. 称公开的密钥为公钥; 不公开的密钥为私钥.</p>

<!-- more -->


<p>如果加密密钥是公开的, 这用于客户给私钥所有者上传加密的数据, 这被称作为公开密钥加密 (狭义). 例如, 网络银行的客户发给银行网站的账户操作的加密数据.</p>

<p>如果解密密钥是公开的, 用私钥加密的信息, 可以用公钥对其解密, 用于客户验证持有私钥一方发布的数据或文件是完整准确的, 接收者由此可知这条信息确实来自于拥有私钥的某人, 这被称作数字签名, 公钥的形式就是数字证书. 例如, 从网上下载的安装程序, 一般都带有程序制作者的数字签名, 可以证明该程序的确是该作者 (公司) 发布的而不是第三方伪造的且未被篡改过 (身份认证/验证).</p>

<p>常见的公钥加密算法有: RSA, ElGamal, 背包算法, Rabin (RSA的特例), 迪菲－赫尔曼密钥交换协议中的公钥加密算法, 椭圆曲线加密算法 (英语: Elliptic Curve Cryptography, ECC). 使用最广泛的是 RSA 算法 (由发明者 Rivest, Shmir 和 Adleman 姓氏首字母缩写而来) 是著名的公开金钥加密算法, ElGamal 是另一种常用的非对称加密算法。</p>

<p>与对称密钥加密相比, 优点在于无需共享的通用密钥, 解密的私钥不发往任何用户. 即使公钥在网上被截获, 如果没有与其匹配的私钥, 也无法解密, 所截获的公钥是没有任何用处的.</p>

<p>由于公开密钥加密能加密的数据与密钥长度相关, 所以通常不会直接使用公开密钥加密的方式来加密数据, 在数字签名中, RSA 是用来加密/解密原始数据的散列值的(如 MD5, SHA1). 而在加密数据时, 公开密钥加密是用来加密对等加密的密钥的. 下面来看 crypto++ 中具体的加密算法的应用.</p>

<h2>AES</h2>

<p>AES, 高级加密标准 (Advanced Encryption Standard，AES), 在密码学中又称 Rijndael 加密法, 是美国联邦政府采用的一种区块加密标准. 这个标准用来替代原先的 DES, 已经被多方分析且广为全世界所使用. 经过五年的甄选流程, 高级加密标准由美国国家标准与技术研究院 (NIST) 于 2001 年 11 月 26 日发布于 FIPS PUB 197, 并在 2002 年 5 月 26 日成为有效的标准. 2006 年, 高级加密标准已然成为对称密钥加密中最流行的算法之一.</p>

<p>分组加密 (Block cipher, 又称分块加密), 是一种对称密钥算法. 它将明文分成多个等长的模块 (block), 使用确定的算法和对称密钥对每组分别加密解密.</p>

<p>分组加密就要涉及到块密码的工作模式, AES 有 5 种块密码的工作模式, 分别是: 电子密码本 (ECB), 密码块链接 (CBC), 密文反馈 (CFB), 输出反馈 (OFB), 计数器模式(CTR), 各种优缺点详见<a href="http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">块密码的工作模式</a>.</p>

<p>下面是利用 crypto++ 实现 CBC 模式的 AES 加密/解密测试程序</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &quot;aes.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;modes.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;filters.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;osrng.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;hex.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">CryptoPP</span><span class="p">;</span>
</span><span class='line'>  <span class="n">AutoSeededRandomPool</span> <span class="n">r</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">byte</span> <span class="n">key</span><span class="p">[</span><span class="n">AES</span><span class="o">::</span><span class="n">DEFAULT_KEYLENGTH</span><span class="p">];</span>
</span><span class='line'>  <span class="n">byte</span> <span class="n">iv</span><span class="p">[</span><span class="n">AES</span><span class="o">::</span><span class="n">BLOCKSIZE</span><span class="p">];</span>
</span><span class='line'>  <span class="n">r</span><span class="p">.</span><span class="n">GenerateBlock</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="o">::</span><span class="n">DEFAULT_KEYLENGTH</span><span class="p">);</span>
</span><span class='line'>  <span class="n">r</span><span class="p">.</span><span class="n">GenerateBlock</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">AES</span><span class="o">::</span><span class="n">BLOCKSIZE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">origin</span> <span class="o">=</span> <span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ciphertext</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">origin</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">AES</span><span class="o">::</span><span class="n">Encryption</span> <span class="n">aes_encryption</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="o">::</span><span class="n">DEFAULT_KEYLENGTH</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CBC_Mode_ExternalCipher</span><span class="o">::</span><span class="n">Encryption</span> <span class="n">cbc_encryption</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">,</span> <span class="n">iv</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">StreamTransformationFilter</span> <span class="n">encryptor</span><span class="p">(</span><span class="n">cbc_encryption</span><span class="p">,</span> <span class="k">new</span> <span class="n">StringSink</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">));</span>
</span><span class='line'>  <span class="n">encryptor</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="n">c_str</span><span class="p">()),</span> <span class="n">origin</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
</span><span class='line'>  <span class="n">encryptor</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">encoded</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HexEncoder</span> <span class="n">encoder</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">encoder</span><span class="p">.</span><span class="n">Put</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">ciphertext</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">ciphertext</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">encoder</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">word64</span> <span class="n">encoder_size</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">.</span><span class="n">MaxRetrievable</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">encoder_size</span> <span class="o">&amp;&amp;</span> <span class="n">encoder_size</span> <span class="o">&lt;=</span> <span class="n">SIZE_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">encoded</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">encoder_size</span><span class="p">);</span>
</span><span class='line'>      <span class="n">encoder</span><span class="p">.</span><span class="n">Get</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">encoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">encoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">encoded</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// send encoded to server</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">decoded</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HexDecoder</span> <span class="n">decoder</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">decoder</span><span class="p">.</span><span class="n">Put</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">encoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">encoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">decoder</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">word64</span> <span class="n">decoder_size</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">.</span><span class="n">MaxRetrievable</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">decoder_size</span> <span class="o">&amp;&amp;</span> <span class="n">decoder_size</span> <span class="o">&lt;=</span> <span class="n">SIZE_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">decoded</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">decoder_size</span><span class="p">);</span>
</span><span class='line'>      <span class="n">decoder</span><span class="p">.</span><span class="n">Get</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">decoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">decoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">decoded</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">AES</span><span class="o">::</span><span class="n">Decryption</span> <span class="n">aes_decryption</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="o">::</span><span class="n">DEFAULT_KEYLENGTH</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CBC_Mode_ExternalCipher</span><span class="o">::</span><span class="n">Decryption</span> <span class="n">cbc_decryption</span><span class="p">(</span><span class="n">aes_decryption</span><span class="p">,</span> <span class="n">iv</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">decrypted</span><span class="p">;</span>
</span><span class='line'>  <span class="n">StreamTransformationFilter</span> <span class="n">decryptor</span><span class="p">(</span><span class="n">cbc_decryption</span><span class="p">,</span> <span class="k">new</span> <span class="n">StringSink</span><span class="p">(</span><span class="n">decrypted</span><span class="p">));</span>
</span><span class='line'>  <span class="n">decryptor</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">decoded</span><span class="p">.</span><span class="n">c_str</span><span class="p">()),</span> <span class="n">decoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">decryptor</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">decrypted</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>RSA</h2>

<p>RSA 加密算法是一种非对称加密算法. 在公开密钥加密和电子商业中 RSA 被广泛使用. RSA 是 1977 年由罗纳德·李维斯特 (Ron Rivest), 阿迪·萨莫尔 (Adi Shamir) 和伦纳德·阿德曼 (Leonard Adleman) 一起提出的. 当时他们三人都在麻省理工学院工作. RSA 就是他们三人姓氏开头字母拼在一起组成的.</p>

<p>1973 年, 在英国政府通讯总部工作的数学家克利福德·柯克斯 (Clifford Cocks) 在一个内部文件中提出了一个相同的算法, 但他的发现被列入机密, 一直到1997年才被发表.</p>

<p>对极大整数做因数分解的难度决定了 RSA 算法的可靠性. 换言之, 对一极大整数做因数分解愈困难, RSA 算法愈可靠. 尽管如此, 只有一些 RSA 算法的变种被证明为其安全性依赖于因数分解. 假如有人找到一种快速因数分解的算法的话, 那么用 RSA 加密的信息的可靠性就肯定会极度下降. 但找到这样的算法的可能性是非常小的. 今天只有短的 RSA 钥匙才可能被强力方式解破. 到 2008 年为止, 世界上还没有任何可靠的攻击 RSA 算法的方式. 只要其钥匙的长度足够长, 用 RSA 加密的信息实际上是不能被解破的.</p>

<p>下面是利用 crypto++ 实现的 RSA 测试程序</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &quot;hex.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;osrng.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;rsa.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">CryptoPP</span><span class="p">;</span>
</span><span class='line'>  <span class="n">AutoSeededRandomPool</span> <span class="n">r</span><span class="p">;</span>
</span><span class='line'>  <span class="n">InvertibleRSAFunction</span> <span class="n">params</span><span class="p">;</span>
</span><span class='line'>  <span class="n">params</span><span class="p">.</span><span class="n">GenerateRandomWithKeySize</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">origin</span> <span class="o">=</span> <span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ciphertext</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">origin</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">RSA</span><span class="o">::</span><span class="n">PrivateKey</span> <span class="n">private_key</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
</span><span class='line'>  <span class="n">RSA</span><span class="o">::</span><span class="n">PublicKey</span> <span class="n">public_key</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">RSAES_OAEP_SHA_Encryptor</span> <span class="n">e</span><span class="p">(</span><span class="n">public_key</span><span class="p">);</span>
</span><span class='line'>  <span class="n">StringSource</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="k">new</span> <span class="n">CryptoPP</span><span class="o">::</span><span class="n">PK_EncryptorFilter</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="k">new</span> <span class="n">CryptoPP</span><span class="o">::</span><span class="n">StringSink</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">encoded</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HexEncoder</span> <span class="n">encoder</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">encoder</span><span class="p">.</span><span class="n">Put</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">ciphertext</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">ciphertext</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">encoder</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">word64</span> <span class="n">encoder_size</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">.</span><span class="n">MaxRetrievable</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">encoder_size</span> <span class="o">&amp;&amp;</span> <span class="n">encoder_size</span> <span class="o">&lt;=</span> <span class="n">SIZE_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">encoded</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">encoder_size</span><span class="p">);</span>
</span><span class='line'>      <span class="n">encoder</span><span class="p">.</span><span class="n">Get</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">encoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">encoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">encoded</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// send encoded to server</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">decoded</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HexDecoder</span> <span class="n">decoder</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">decoder</span><span class="p">.</span><span class="n">Put</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">encoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">encoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">decoder</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">word64</span> <span class="n">decoder_size</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">.</span><span class="n">MaxRetrievable</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">decoder_size</span> <span class="o">&amp;&amp;</span> <span class="n">decoder_size</span> <span class="o">&lt;=</span> <span class="n">SIZE_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">decoded</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">decoder_size</span><span class="p">);</span>
</span><span class='line'>      <span class="n">decoder</span><span class="p">.</span><span class="n">Get</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">decoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">decoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">decoded</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">decrypted</span><span class="p">;</span>
</span><span class='line'>  <span class="n">RSAES_OAEP_SHA_Decryptor</span> <span class="n">d</span><span class="p">(</span><span class="n">private_key</span><span class="p">);</span>
</span><span class='line'>  <span class="n">StringSource</span><span class="p">(</span><span class="n">decoded</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="k">new</span> <span class="n">CryptoPP</span><span class="o">::</span><span class="n">PK_DecryptorFilter</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="k">new</span> <span class="n">CryptoPP</span><span class="o">::</span><span class="n">StringSink</span><span class="p">(</span><span class="n">decrypted</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">decrypted</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://www.cryptopp.com/">Crypto++ HomePage</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a></li>
<li><a href="http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">Block cipher mode of operation</a></li>
<li><a href="http://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">RSA</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理(一)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理(二)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[返回值类型推导]]></title>
    <link href="http://bitdewy.github.com/blog/2013/11/11/return-type-resolver/"/>
    <updated>2013-11-11T10:21:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/11/11/return-type-resolver</id>
    <content type="html"><![CDATA[<p>模版函数的参数类型可以自动推导, 它可以让我们在调用函数的时候不必写丑陋的<code>&lt;&gt;</code>, 但如果是返回值类型需要自动推导, 似乎就没有那么容易了. 虽然语言本身不支持返回值的类型自动推导, 但我们可以尝试其他的办法来完成这项任务.</p>

<h2>目的</h2>

<p>在使用函数返回值初始化变量或给变量赋值时模版函数能够自动推导出类型.</p>

<h2>例子</h2>

<p>在某些情况下, 明确被初始化的变量类型是有用的. 考虑下面的例子, 我们使用随机数来初始化 STL 容器. 但是我们不知道用户会选择哪个具体的容器类型. 它可能是 <code>std::list</code>, <code>std::vector</code> 或者其他的行为像 STL 容器的自定义类型. 最直接的方法如下所示:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;random&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">Container</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>我们可以注意到, 代码中必须显示的指定返回值的类型, 很显然我们必须写两次返回值类型, 类型声明写一次, 函数调用又写了一次. 返回值类型推导可以帮助我们解决这个问题, 当然 C++11 中的 auto 类型也可以解决.</p>

<h2>解决方案 &amp; 示例代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'><span class="cp">#include &lt;set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;random&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">GetRandomN</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">GetRandomN</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">operator</span> <span class="n">Container</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">());</span> <span class="c1">// push_back is not supported by all standard containers.</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_s</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_v</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_l</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类 GetRandomN 有一个构造函数, 以及一个模版的类型隐式转换函数. 初始化的时候, 会产生一个 GetRandomN 类的临时对象, 当赋值给 STL 容器类型时, 编译器会去尝试将对象隐式转换. 而隐式转换的途径就是取寻找隐式转换函数, 这样就完成了返回值自动推导. 有了返回值类型自动推导, 我们就不必手写返回值类型参数了. 唔… 再注意一点, 为了支持 <code>std::set</code> 我们将原始的 <code>push_back</code> 函数改为了 <code>insert</code>.</p>

<p><em>注: 在 C++11 引入 <code>nullptr</code> 之前, 手工实现一个 <code>nullptr</code> 的惯用法就使用了返回值类型推导.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向切面编程(AOP)]]></title>
    <link href="http://bitdewy.github.com/blog/2013/10/20/aop/"/>
    <updated>2013-10-20T13:58:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/10/20/aop</id>
    <content type="html"><![CDATA[<p>上周同事问了个没法回答的问题, <em>“统计, 日志应该放到哪一层, 或者哪个模块中?”</em></p>

<p>首先, 所有的编程范式都不是万能的, 更不用说<a href="http://existentialtype.wordpress.com/2011/03/15/teaching-fp-to-freshmen/">反并发、反模块化</a>的面向对象范式了. 我们不能总是以同一种编程范式来思考问题. 类似日志, 权限验证, 事务管理等会横跨多个模块的东西, 我们需要新的思路来解决代码割裂的问题.</p>

<h2>面向切面编程</h2>

<p>面向切面编程 (AOP), 不是什么新玩意儿, 早在 199x 年开始, 研究人员就对面向对象思想的局限性进行了分析. 研究出了一种新的编程思想, 借助这一思想可以通过减少代码重复模块从而帮助开发人员提高工作效率. 随着研究的逐渐深入, AOP 也逐渐发展成一套完整的程序设计思想, 各种应用 AOP 的技术也应运而生. 比较著名的有 Java 阵营的 AspectJ 和 Spring AOP, C++ 中也有 AspectC++.</p>

<h3>AOP 中的概念</h3>

<ul>
<li>cross-cutting concerns, (横切关注点)指的是一些具有横越多个模块的行为, 使用传统的软件开发方法不能够达到有效的模块化的一类特殊关注点. 如日志, 权限验证等不属于业务逻辑, 但多个模块都需要插入的东西, 即属于横切关注点.</li>
<li>advice, (通知)指的是切面中的具体逻辑. 如打印日志, 验证权限.</li>
<li>pointcut, (切入点)指的是切面代码要插入的位置.</li>
<li>aspect, (切面)指的是通知以及切入点模块化之后的整体.</li>
</ul>


<p>上面的内容都属于动态横切, 基本上所作的工作就是方法拦截, 插入指定的代码. 还有一种静态横切, Mixin 它可以可以在不修改原有职责的基础上增加新的职责, 可以模拟多继承, 而不增加耦合性, 不过这就不是本文所要讨论的内容了.</p>

<p>看下面的伪代码来感受一下 AOP:</p>

<!-- more -->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function mainProgram()
</span><span class='line'>{
</span><span class='line'>  var x =  foo();
</span><span class='line'>  doSomethingWith(x);
</span><span class='line'>  return x;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>aspect logging
</span><span class='line'>{
</span><span class='line'>  before (mainProgram is called):
</span><span class='line'>  {
</span><span class='line'>    log.Write("entering mainProgram");
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  after (mainProgram is called):
</span><span class='line'>  {
</span><span class='line'>    log.Write("exiting mainProgram with return value of "
</span><span class='line'>              + mainProgram.returnValue);
</span><span class='line'>  }
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>aspect verification
</span><span class='line'>{
</span><span class='line'>  before (doSomethingWith is called):
</span><span class='line'>  {
</span><span class='line'>    if (doSomethingWith.arguments[0] == null) 
</span><span class='line'>    {
</span><span class='line'>      throw NullArgumentException();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (!doSomethingWith.caller.isAuthenticated)
</span><span class='line'>    {
</span><span class='line'>      throw Securityexception();
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>有了业务代码, 并且定义好了切面, 以及切入点等一切 AOP 所需的内容之后, 通过一些神奇的办法, 我们最终生成的代码看起来应该和下面的差不多:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function mainProgram()
</span><span class='line'>{
</span><span class='line'>  log.Write("entering mainProgram");
</span><span class='line'>
</span><span class='line'>  var x = foo();   
</span><span class='line'>
</span><span class='line'>  if (x == null) throw NullArgumentException();
</span><span class='line'>  if (!mainProgramIsAuthenticated()) throw Securityexception();
</span><span class='line'>  doSomethingWith(x);   
</span><span class='line'>
</span><span class='line'>  log.Write("exiting mainProgram with return value of "+ x);
</span><span class='line'>  return x;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样就解决了文中开头提的问题. 日志, 权限验证这些会分散在各个模块中的东西, 通过 AOP 避免了割裂, 保持了完整性.</p>

<p>在 C++ 中, 可以使用 template 来模拟切面, 类似《Modern C++ Design》中所讲述的基于 policy 的设计.</p>

<p>在纯函数式的编程语言中, 也许用高阶函数就可以直接模拟 AOP ?</p>

<h2>参考</h2>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-oriented programming</a></li>
<li>Java: <a href="http://docs.spring.io/spring/docs/2.5.x/reference/aop.html">Spring AOP</a></li>
<li><a href="http://www.lisha.ufsc.br/teaching/sce/aop_with_c++.pdf">Aspect-Oriented Programming with C++</a></li>
<li><a href="http://www.aspectc.org/">AspectC++</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
