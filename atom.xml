<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bitdewy]]></title>
  <link href="http://bitdewy.github.com/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2013-09-29T01:21:38+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Visitor 模式与 boost.variant.static_visitor]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/15/static-visitor/"/>
    <updated>2013-07-15T00:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/15/static-visitor</id>
    <content type="html"><![CDATA[<h2>visitor 模式</h2>

<p>visitor 模式是一种将算法与对象结构分离的软件设计模式.</p>

<p>这个模式的基本想法如下: 首先我们拥有一个由许多对象构成的对象结构, 这些对象的类都拥有一个 accept 方法用来接受访问者对象; 访问者是一个接口, 它拥有一个 visit 方法, 这个方法对访问到的对象结构中不同类型的元素作出不同的反应; 在对象结构的一次访问过程中, 我们遍历整个对象结构, 对每一个元素都实施 accept 方法, 在每一个元素的 accept 方法中回调访问者的 visit 方法, 从而使访问者得以处理对象结构的每一个元素. 我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作.</p>

<p>访问者模式使得我们可以在传统的单分派语言 (如 Smalltalk, Java 和 C++) 中模拟双分派技术.</p>

<!-- more -->


<h2>传统的 visitor 模式实现</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;memory&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;tuple&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// original visitor pattern</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Wheel</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Engine</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Body</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Car</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">CarElementVisitor</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">CarElement</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Wheel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElement</span><span class="p">,</span>
</span><span class='line'>              <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElement</span><span class="p">,</span>
</span><span class='line'>               <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Body</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElement</span><span class="p">,</span>
</span><span class='line'>             <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElement</span><span class="p">,</span>
</span><span class='line'>            <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Elements</span><span class="p">;</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Car</span><span class="p">()</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">elements_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elements_</span><span class="p">));</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elements_</span><span class="p">));</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elements_</span><span class="p">));</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Elements</span> <span class="n">elements_</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PrintVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElementVisitor</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintVisitor::visit(std::shared_ptr&lt;Wheel&gt; wheel) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintVisitor::visit(std::shared_ptr&lt;Engine&gt; engine) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintVisitor::visit(std::shared_ptr&lt;Body&gt; body) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintVisitor::visit(std::shared_ptr&lt;Car&gt; car) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">OtherVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElementVisitor</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherVisitor::visit(std::shared_ptr&lt;Wheel&gt; wheel) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherVisitor::visit(std::shared_ptr&lt;Engine&gt; engine) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherVisitor::visit(std::shared_ptr&lt;Body&gt; body) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherVisitor::visit(std::shared_ptr&lt;Car&gt; car) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElement</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'>  <span class="n">car</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">PrintVisitor</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'>  <span class="n">car</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">OtherVisitor</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>boost.variant.static_visitor 的实现</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/variant.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/variant/static_visitor.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/variant/apply_visitor.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Wheel</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Engine</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Body</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Car</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// boost static visitor</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="p">,</span> <span class="n">Engine</span><span class="p">,</span> <span class="n">Body</span><span class="p">,</span> <span class="n">Car</span><span class="o">&gt;</span> <span class="n">CarElement</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PrintVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">boost</span><span class="o">::</span><span class="n">static_visitor</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Wheel</span><span class="o">&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintStaticVisitor::operator()(const Wheel&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Engine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintStaticVisitor::operator()(const Engine&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Body</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintStaticVisitor::operator()(const Body&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Car</span><span class="o">&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// bla bla bla</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintStaticVisitor::operator()(const Car&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">OtherVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">boost</span><span class="o">::</span><span class="n">static_visitor</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Wheel</span><span class="o">&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherStaticVisitor::operator()(const Wheel&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Engine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherStaticVisitor::operator()(const Engine&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Body</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherStaticVisitor::operator()(const Body&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Car</span><span class="o">&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// bla bla bla</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherStaticVisitor::operator()(const Car&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CarElement</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Car</span><span class="p">();</span>
</span><span class='line'>  <span class="n">PrintVisitor</span> <span class="n">print_visitor</span><span class="p">;</span>
</span><span class='line'>  <span class="n">OtherVisitor</span> <span class="n">other_visitor</span><span class="p">;</span>
</span><span class='line'> <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">print_visitor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'>  <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">other_visitor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_54_0/doc/html/variant/reference.html#header.boost.variant.static_visitor_hpp">boost.variant.static_visitor</a></li>
<li><a href="http://en.wikipedia.org/wiki/Visitor_pattern">维基百科: visitor 模式</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 完美转发]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/08/cpp11-perfect-forward/"/>
    <updated>2013-07-08T22:09:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/08/cpp11-perfect-forward</id>
    <content type="html"><![CDATA[<h2>动机</h2>

<p>在泛型编码中经常出现的一个问题是: 如何将一组参数原封不动的转发给另一个函数? 这里的原封不动指的是: 保持参数的左值 (右值), const (non-const) 属性不变.</p>

<h2>C++03 中参数转发存在的问题</h2>

<p>下面来看一个例子, 对于表达式 <code>E(a, b, …, c)</code> 我们希望它与 <code>f(a, b, …, c)</code> 完全等价. 在 C++03 中这是不可能的. 下面是几种设计方案, 但所有的都会在某些条件下失效.</p>

<p>最简单的, 使用引用参数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">E</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很遗憾, 函数 f 无法处理临时变量, 例如 <code>f(1, 2, 3)</code>; 会编译失败. 这三个参数都无法绑定到引用.</p>

<p>再来看看 const 引用:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">E</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>这解决了上面的问题, 但是又引入了新的问题, 现在我们无法让 E 接收 non-const 参数了, 下面的代码也会产生一个编译失败.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">E</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// oops! E cannot modify these</span>
</span></code></pre></td></tr></table></div></figure>


<p>嗯, 再来个尝试, 解决上面的问题, 我们接收 const 引用, 然后使用 const_cast 来去掉 const 属性.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">E</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后来终极解决方案吧, 利用重载, 根据重载决议, 我们可以使用 const 引用和 non-const 引用来进行参数重载, 对于上面的例子, 我们的实现如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>n 个参数的函数, 就需要 2<sup>n</sup> 个重载版本, 这太恐怖了, 我们非常需要自动完成这些工作. 这个问题在 C++11 中的到了完美的解决.</p>

<h2>完美转发</h2>

<p>C++11 新标准给了我们修复这个问题的机会 (这里有一个破坏性的解决方案, 虽然解决了完美转发的问题, 但是破坏了现有的类型推导规则<a href="http://stackoverflow.com/questions/3591832/perfect-forwarding-in-c03/3591909#3591909">《Perfect Forwarding in C++03》</a>).</p>

<p>C++11 中引入了新的概念, 右值引用. 我们可以在不破坏现有代码的情况下, 定义右值引用的推导规则, 来解决完美转发的问题.</p>

<p>看下面的表格, (TR 表示 T 引用类型)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">TR</span>   <span class="n">R</span>
</span><span class='line'>
</span><span class='line'><span class="n">T</span><span class="o">&amp;</span>   <span class="o">&amp;</span>  <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;</span>  <span class="c1">// lvalue reference to cv TR -&gt; lvalue reference to T</span>
</span><span class='line'><span class="n">T</span><span class="o">&amp;</span>   <span class="o">&amp;&amp;</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;</span>  <span class="c1">// rvalue reference to cv TR -&gt; TR (lvalue reference to T)</span>
</span><span class='line'><span class="n">T</span><span class="o">&amp;&amp;</span>  <span class="o">&amp;</span>  <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;</span>  <span class="c1">// lvalue reference to cv TR -&gt; lvalue reference to T</span>
</span><span class='line'><span class="n">T</span><span class="o">&amp;&amp;</span>  <span class="o">&amp;&amp;</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="c1">// rvalue reference to cv TR -&gt; TR (rvalue reference to T)</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后, 模板参数推导时, 如果参数是左值, 那么就推导为左值引用. 否则使用正常的类型推导. 这里又引入了一个新的概念, “全局引用” (universal references), 具体细节详见: <a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11">C++ and Beyond 2012: Scott Meyers &ndash; Universal References in C++11</a></p>

<p>为什么这样就能解决问题? 因为我们保持了参数的类型: 如果参数是一个左值, 我们得到的是左值引用的参数, 否则我们得到的是右值引用类型的参数, 看下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">deduce</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="n">deduce</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// deduce&lt;int&amp;&gt;(int&amp; &amp;&amp;) -&gt; deduce&lt;int&amp;&gt;(int&amp;)</span>
</span><span class='line'><span class="n">deduce</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// deduce&lt;int&gt;(int&amp;&amp;)</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后就是要做“转发”了. 需要注意的是, 在函数内参数类型是一个左值类型.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">deduce</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">){</span>
</span><span class='line'>    <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// fine, foo can refer to x</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">deduce</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// okay, foo operates on x which has a value of 1</span>
</span></code></pre></td></tr></table></div></figure>


<p>这还不足够. foo 需要拿到和 deduce 一样的参数类型, 解决方案如下.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这行代码做了什么呢? 我们在 deduce 函数中, 且我们接收了一个左值类型的参数, 这意味着 T 是 A&amp; 类型, 经过静态类型转换 A&amp; &amp;&amp; 仍然是 A&amp; 类型. 因此, 加入 x 以及是一个 A&amp; 类型, 那么我们什么也没有做, 它仍然是一个左值引用类型.</p>

<p>当我们接收的是一个右值, T 就是 A 类型, 因此我们转换后的类型为 A&amp;&amp;. 转换后的类型是一个右值表达式, 这样就不会再作为左值参数了. 我们保持住了参数的类型. 将上面的组合到一起, 我们就得到了“完美转发”:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">E</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当 f 接收到一个左值, 那么 E 也接收一个左值, 当 f 接收的是一个右值, 那么 E 接受到的也是一个右值, 完美了.</p>

<p>当然, 上面的代码是有一点丑陋. <code>static_cast&lt;T&amp;&amp;&gt;</code> 古怪而且不容易记住. 标准库中提供了一个工具函数, 叫做 forward, 它所做的事情与类型转换完全一致.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'><span class="c1">// is the same as</span>
</span><span class='line'><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">C++标准提案(N1385)：The Forwarding Problem: Arguments</a></li>
<li><a href="http://blog.csdn.net/pongba/article/details/1697636">《C++0x漫谈》系列之：右值引用(或“move语意与完美转发”)(下)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 右值引用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/02/cpp11-rvalue-ref/"/>
    <updated>2013-07-02T22:49:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/02/cpp11-rvalue-ref</id>
    <content type="html"><![CDATA[<h2>什么是右值引用?</h2>

<p>在一般情况下, C++ 不把表达式的左值属性作为类型的一部分, 比如下面的变量声明:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么变量 n 的类型是 int. 另外常量 3 也是 int 类型. 虽然他们有相同的类型, 不过这并不是说 n 和 3 总是可以互换的. 比如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// OK</span>
</span><span class='line'><span class="kt">int</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// Error</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是因为标准中规定, 当定义一个引用时, 我们必须使用一个左值来初始化它. 在上面的代码中, n 是一个左值, 而 3 不是. 所以我们不能用 3 来初始化 s. 这个规定可以帮助编译器来捕捉错误, 比如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// equals std::cin.operator&gt;&gt;(3);</span>
</span></code></pre></td></tr></table></div></figure>


<p>简单的说, 上面的代码调用了 std::cin 的名为 operator>> 的成员函数, 并使用 3 作为参数. operator>> 是重载函数, 虽然它有接受一个 int&amp; 参数的重载版本, 但是没有能接受一个简单的 int 常量, 或者 int 右值作为参数的重载. 因此, 编译器会检查出我们无法使用 int 的右值作为参数来调用 operator>>.</p>

<!-- more -->


<p>C++11 扩展了引用的概念, 增加了右值引用. 右值引用也是一个引用, 但与普通的引用不同, 它只能绑定到右值上. 下面是一个右值引用的声明:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个普通的引用只能绑定左值, 一个右值引用只能绑定到右值, 也就是说如果我们写了下面的代码, 编译器会报一个错误.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">// Error: n is an lvalue</span>
</span></code></pre></td></tr></table></div></figure>


<p>右值引用是一个有趣的组合, 虽然你只能绑定右值到右值引用, 但是你使用时它却是一个左值.</p>

<p>例如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="o">++</span><span class="n">t</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通常情况下, 程序员不能修改右值. 但是通过右值引用, 获得了左值, 这样我们就能修改它的值了. 另外, 右值在通过右值引用绑定之后, 这个右值就不在可访问, 它使用了转移语义来代替拷贝操作.</p>

<p>定义一个接收右值引用参数的函数, 那么函数就会使用转移语义来替代拷贝操作. 但是这样会禁止接收左值参数.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</span><span class='line'><span class="n">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>        <span class="c1">// OK;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="n">foo</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>         <span class="c1">// Error: n is an lvalue</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们当然可以定义一个左值的版本来解决上面的问题:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'><span class="n">bar</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>             <span class="c1">// calls bar(int&amp;&amp;)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="n">bar</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>               <span class="c1">// calls bar(const int&amp;)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个技术有个值得记住的地方是, 通过 const 引用和右值引用的两个重载版本, 你告诉了编译器哪个修改参数是安全的, 哪个不是. 此外, 编译器在编译期就决定了使用哪个, 从而避免了运行时的开销.</p>

<h2>Move 语义</h2>

<p>右值引用的引入, 从语言层面提升了性能, 提高了内存与时间上的效率.</p>

<p>在 C++03 及之前的标准中, 临时对象 (称为右值 &ldquo;R-values&rdquo;, 位于赋值运算符之右) 无法被改变, 在 C 中亦同 (且被视为无法和 const T&amp; 做出区分). 虽然在某些情况下临时对象的确会被改变, 甚至也被视为是一个有用的漏洞.</p>

<p>C++11 增加一个新的非常数引用 (reference) 类型, 称作右值引用 (R-value reference), 标记为 <code>T&amp;&amp;</code>. 右值引用所引用的临时对象可以在该临时对象被初始化之后做修改, 这是为了允许 move 语义.</p>

<p>C++03 性能上被长期被诟病的其中之一, 就是其耗时且不必要的深度拷贝. 深度拷贝会发生在当对象是以传值的方式传递. 举例而言, <code>std::vector&lt;T&gt;</code> 是内部保存了 C-style 数组的一个包装, 如果一个 <code>std::vector&lt;T&gt;</code> 的临时对象被建构或是从函数返回, 要将其存储只能通过生成新的 <code>std::vector&lt;T&gt;</code>并且把该临时对象所有的数据复制进去. 该临时对象和其拥有的內存会被摧毁. (为了讨论上的方便，这里忽略返回值优化)</p>

<p>在 C++11 中, 一个 <code>std::vector</code> 的 &ldquo;move 构造函数&rdquo; 对某个 vector 的右值引用可以单纯地从右值复制其内部 C-style 数组的指针到新的 vector, 然后留下空的右值. 这个操作不需要数组的复制, 而且空的临时对象的析构也不会摧毁内存. 传回 vector 临时对象的函数不需要显式地传回 <code>std::vector&lt;T&gt;&amp;&amp;</code>. 如果 vector 没有 move 构造函数, 那么复制构造函数将被调用, 以 <code>const std::vector&lt;T&gt; &amp;</code> 的正常形式. 如果它确实有 move 构造函数, 那么就会调用 move 构造函数, 这能够免除大幅的内存配置.</p>

<p>基于安全的理由, 具名的参数将永远不被认定为右值, 即使它是被如此声明的; 为了获得右值必须使用 <code>std::move&lt;T&gt;()</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">bool</span> <span class="n">is_r_value</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">is_r_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">is_r_value</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// i 为具名变量，即使被声明成右值也不會被认为是右值。</span>
</span><span class='line'>    <span class="n">is_r_value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="c1">// 使用 std::move&lt;T&gt;() 取得右值。</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于右值引用的用语特性以及对于左值引用 (L-value references;regular references) 的某些用语修正, 右值引用允许开发者提供完美转发 (perfect function forwarding). 当与变长参数模板结合, 这项能力允许函数模板能够完美地转送引数给其他接受这些特定引数的函数. 最大的用处在于转发构造函数参数, 创造出能够自动为这些特定引数调用正确建构式的工厂函数 (factory function).</p>

<h2>参考</h2>

<ul>
<li><a href="http://blog.csdn.net/pongba/article/details/1684519">《C++0x漫谈》系列之：右值引用(或“move语意与完美转发”)(上)</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/C%2B%2B11#.E5.8F.B3.E5.80.BC.E5.BC.95.E7.94.A8.E5.92.8C_move_.E8.AA.9E.E6.84.8F">维基百科C++11: 右值引用和 move 语义</a></li>
<li><a href="http://stackoverflow.com/questions/3106110/what-are-move-semantics/3109981">Stackoverflow：What are move semantics？</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics">标准文档提案：Move Semantics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 泛型编程之 SFINAE]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/25/cpp-template-sfinae/"/>
    <updated>2013-06-25T23:01:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/25/cpp-template-sfinae</id>
    <content type="html"><![CDATA[<h2>什么是 SFINAE?</h2>

<p>(Substitution Failure Is Not An Error) 匹配失败不是错误. 它可以从一组重载函数中剪裁掉不需要的模板实例.</p>

<p>SFINAE 是 C++ 模板的一个特性, 这个特性在 std::enable_if 中使用的非常广泛. 模板参数推导过程中, C++ 编译器会试图实例化一些候选的函数签名, 以确保函数调用时模板的精确匹配, 当找到一个不合适的匹配时(例如无效的参数或范围值), 则会将这个不合适的匹配从重载决议中删除, 而不是产生一个编译错误. 如果有且只有一个函数的话, 才会产生一个编译错误.</p>

<p>考虑下面的简单的乘法计数器</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">long</span> <span class="n">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">multiplication_result</span> <span class="n">multiply</span><span class="p">(</span><span class="n">T</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T</span> <span class="n">t2</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">t2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">multiply</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 main 函数中的函数调用 multiply, 会导致编译器对模板参数的实例化, 虽然第一个非模板函数 multiply 明显是一个更佳的匹配. 在实例化的过程中, 会产生一个非法的类型 int::multiplication_result. 根据 SFINAE, 这个非法的实例化会被自动丢弃. 最终, 非模板的 multiply 会被调用. 编译通过.</p>

<!-- more -->


<h2>SFINAE 的应用</h2>

<p>SFINAE 通常被用作编译时期的类型属性检查. 比如下面的 is_pointer 元函数, 它可以在编译期检查参数类型是否是一个指针.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">is_pointer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">U</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">Y</span> <span class="n">X</span><span class="o">::*</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">U</span> <span class="p">(</span><span class="o">*</span><span class="p">)());</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">static</span> <span class="kt">double</span> <span class="n">is_ptr</span><span class="p">(...);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">static</span> <span class="n">T</span> <span class="n">t</span><span class="p">;</span>
</span><span class='line'>  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">is_ptr</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">bar</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">IntPtr</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">Foo</span><span class="o">::*</span> <span class="n">FooMemberPtr</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncPtr</span><span class="p">)();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">IntPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>         <span class="c1">// prints 1</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">FooMemberPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>  <span class="c1">// prints 1</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">FuncPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>        <span class="c1">// prints 1</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果没有 SFINAE 的话, 元函数 is_pointer 是无法正常工作的. 在 is_pointer 中, 有四个模板函数 is_ptr, 其中三个都会返回一个 char, 这是经过精心设计的. 这三个分别接收不同的参数类型, 一个接受指针变量, 一个接受一个成员指针, 以及一个简单的函数指针类型. 最后一个 is_ptr 是接收任意类型的(使用了省略号), 它的返回值类型是 double, 它的大小始终会大于 char 类型.</p>

<p>当传递一个指针类型(例如上面的 IntPtr)给 is_pointer 时, value 的值将会初始化为 true (因为 sizeof 两边是相等的). 第一个 sizeof 表达式调用 is_ptr, 如果它是一个指针类型, 那么只有一个模板的重载版本会匹配. 根据 SFINAE, 编译不会报错，因为至少有一个函数被匹配上了.  如果没有合适的实例化版本, 那么会选择那个省略号的版本. 不过那个版本会返回 double 类型, 会导致 value 值被初始化为 false (因为 sizeof(double) != sizeof(char)).</p>

<p>需要注意的是, is_ptr 只有声明, 没有定义. 因为声明足以引发 SFINAE 规则, 但是这些必须都是模板函数。一个模板类的非模板函数是不会参与 SFINAE 的, 只有模板函数才会遵循 SFINAE 规则.</p>

<p>在标准库中, 有大量的 SFINAE 应用, 比如 type traits. 有了 SFINAE 我们就可以根据自己的需求, 为我们所关心的特定类型, 写相应的函数重载函数版本, 也可以在编译期判断类型是否符合我们的需求.</p>

<h2>参考</h2>

<ul>
<li>Wikipedia：<a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">Substitution failure is not an error</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 多线程, std::future & std::promise]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/14/cpp11-multithread-promise-future/"/>
    <updated>2013-06-14T22:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/14/cpp11-multithread-promise-future</id>
    <content type="html"><![CDATA[<p>C++11 中最让人高兴的新特性中线程库的支持一定榜上有名. C++11 中提供了 future 和 promise 来简化任务线程间的返回值操作; 同时为启动任务线程提供了 <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">packaged_task</a> 以方便操作.</p>

<h2>std::packaged_task</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a> 可以包装任何可调用的对象(函数, lambda 表达式, std::bind, 或其他函数对象), 以便异步调用, 调用结果保存在 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中, 可以通过成员函数 get_future 访问. 需要注意的是, <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a> 是不可拷贝的(move only).</p>

<p>示例代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cmath&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">task_lambda</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">([](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span><span class='line'>    <span class="n">task</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;task_lambda:</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">task_bind</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">));</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span><span class='line'>    <span class="n">task</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;task_bind:</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">task_thread</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">task_td</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span><span class='line'>    <span class="n">task_td</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;task_thread:</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">task_lambda</span><span class="p">();</span>
</span><span class='line'>    <span class="n">task_bind</span><span class="p">();</span>
</span><span class='line'>    <span class="n">task_thread</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>仅仅有 packaged_task 还远远不够, 我们还需要更强大的 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 和 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a>.</p>

<p>基本思路很简单: 当一个任务需要向父线程(启动它的线程)返回值时, 它把这个值放到 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 中. 之后, 这个返回值会出现在和此 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 关联的 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 中.于是父线程就能读到返回值. 更简单点的方法, 参看 <a href="http://en.cppreference.com/w/cpp/thread/async">async()</a>.</p>

<p>如果我们有一个 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> f, 通过 get() 可以获得它的值:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">X</span> <span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>  <span class="c1">// if necessary wait for the value to get computed</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果它的返回值还没有到达, 调用线程会进行阻塞等待. 要是等啊等啊, 等到花儿也谢了的话, get() 会抛出异常的(从标准库或等待的线程那个线程中抛出).</p>

<p>如果我们不需要等待返回值(非阻塞方式), 可以简单询问一下 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a>, 看返回值是否已经到达:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">// there is a value to get()</span>
</span><span class='line'>    <span class="c1">// do something</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// do something else</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 最主要的用途是一个简单的获取返回值的方法: get().</p>

<p><a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 的主要用途是提供一个 &ldquo;put&#8221;（或&#8221;get&#8221;，随你）操作, 以和 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 的 get() 对应.</p>

<p><a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 为 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 传递的结果类型有 2 种: 传一个普通值或者抛出一个异常</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">X</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// compute a value for res</span>
</span><span class='line'>    <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>   <span class="c1">// oops: couldn&#39;t compute res </span>
</span><span class='line'>    <span class="n">p</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>到目前为止还不错, 不过我们如何匹配 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> / <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 对呢? 一个在我的线程, 另一个在别的啥线程中吗? 是这样: 既然 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 和 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 可以被到处移动(不是拷贝), 那么可能性就挺多的. 最普遍的情况是父子线程配对形式, 父线程用 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 获取子线程 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 返回的值. 在这种情况下, 使用 <a href="http://en.cppreference.com/w/cpp/thread/async">async()</a> 是很优雅的方法.</p>

<h2>std::promise</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 提供一个存储设施, 当一个异步任务通过 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 来获取结果时, <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 可以提供.</p>

<h2>std::future</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 提供了一种机制来访问异步操作的结果:
由 <a href="http://en.cppreference.com/w/cpp/thread/async">std::async</a>, <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a>, 或者 <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 创建的异步操作, 可以提供一个 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 对象, 给创建者, 用来访问异步操作的结果.</p>

<p>异步操作的创建者, 可以使用各种不同的操作来查询, 等待, 或者从 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中取到异步操作的结果. 如果异步操作还没有执行完的话, 这些操作有可能会阻塞.
当一个异步操作完成时可以通过更改(例如使用 <code>std::promise::set_value</code>) 共享状态(该状态保存在 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中) 将结果返回给异步操作的创建者.</p>

<p>示例代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// future from a packaged_task</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">([](){</span> <span class="k">return</span> <span class="mi">7</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// wrap the function</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>  <span class="c1">// get a future</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">)).</span><span class="n">detach</span><span class="p">();</span> <span class="c1">// launch on a thread</span>
</span><span class='line'>    <span class="c1">// future from an async()</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[](){</span> <span class="k">return</span> <span class="mi">8</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'>    <span class="c1">// future from a promise</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">){</span> <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span> <span class="p">},</span>
</span><span class='line'>                 <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">p</span><span class="p">)).</span><span class="n">detach</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Waiting...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
</span><span class='line'>    <span class="n">f1</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>   <span class="n">f2</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>    <span class="n">f3</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Done!</span><span class="se">\n</span><span class="s">Results are: &quot;</span>
</span><span class='line'>              <span class="o">&lt;&lt;</span> <span class="n">f1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">f2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">f3</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/thread">Cppreference：Thread support library</a></li>
<li><a href="http://en.wikipedia.org/wiki/Futures_and_promises">wikipedia: futures and promises</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++14 std::optional<T>]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/04/cpp14-optional/"/>
    <updated>2013-06-04T01:54:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/04/cpp14-optional</id>
    <content type="html"><![CDATA[<p>C++11已经发布将近2年时间, 各编译器也陆续有了较好的支持. C++14 也已经有相当多的提案被接受, 包括 std::optional, 泛型 lambda, make_unique, 动态数组等, 肯定会出现在下一个标准中. 关于新标准中的提案, 以及已经被接受的提案，详细信息可以参考, wikipedia：<a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14</a>, 以及 open-std 中的 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">C++ 标准草案</a>.</p>

<h2>“无意义”的值</h2>

<p>函数并不总能返回有效的返回值, 很多时候函数可能返回&#8221;无意义&#8221;的值, 这不意味着函数执行失败, 而是表明函数正确执行了, 但结果却不是有用的值.
表示返回值无意义最常用的做法是增加一个&#8221;哨兵&#8221;的角色, 它位于解空间之外, 比如 <code>NULL, -1, EOF, std::string::npos, vector::end()</code>等. 但这些做法不够通用, 而且很多时候不存在解空间之外的&#8221;哨兵&#8221;.</p>

<h2>std::optional<T></h2>

<p>optional 库使用&#8221;容器&#8221;语义, 包装了&#8221;可能产生无效值&#8221;的对象, 实现了&#8221;未初始化&#8221;的概念. (在新标准未正式发布之前，可以参考 <a href="http://www.boost.org/doc/libs/1_54_0/libs/optional/doc/html/index.html">boost::optional</a> 的实现.)</p>

<p>optional 使用&#8221;容器&#8221;语义, 为这种&#8221;无效值&#8221;的情形提供了一个较好的解决方案. 它很像一个仅能存放一个元素的容器, 它实现了&#8221;未初始化&#8221;的概念: 如果元素未初始化, 那么容器就是空的, 否则, 容器内就是有效的, 已经初始化的值.</p>

<!-- more  -->


<h2>操作函数</h2>

<p>optional 的模板类型参数 T 可以使任何类型， 就如同一个标准容器对元素的要求, 并不需要T具有缺省构造函数, 但必须是可拷贝构造的.
optional 采用了指针语义来访问内部保存的元素, 这使得 optional 未初始化时的行为就像一个空指针. 它重载了 <code>operator*</code> 和 <code>operator-&gt;</code> 以实现与指针相同的操作, <code>get()</code> 和 <code>get_ptr()</code> 可以以函数的操作形式获得元素的引用和指针. 成员函数 <code>get_value_or(default)</code> 是一个特别的访问函数, 可以保证返回一个有效的值, 如果 optional 已初始化, 那么返回内部的元素, 否则返回 default. optional 也可以用隐式类型转换进行 bool 测试(用于条件判断), 就像一个对指针的判断. optional 还全面支持比较运算，包括 <code>==, !=, &lt;, &lt;=, &gt;, &gt;=</code>. (详细接口参考 <a href="http://en.cppreference.com/w/cpp/utility/optional">cppreference: std::optional</a>)</p>

<h2>用法</h2>

<p>optional 的接口简单明了, 把它认为是一个大小为 1 并且行为类似指针的容器就可以了, 或者把它想象成是一个类似 scoped_ptr, shared_ptr 的智能指针(注意, optional 不是智能指针, 用法类似但用途不同).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="cp">#include &quot;boost/optional.hpp&quot;</span>
</span><span class='line'><span class="cp">#include &quot;boost/lexical_cast.hpp&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// converts int to string if possible</span>
</span><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">str2int</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">lexical_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bad_lexical_cast</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">get_int_form_user</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">o</span> <span class="o">=</span> <span class="n">str2int</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// &#39;o&#39; may or may not contain an int</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>                                 <span class="c1">// does optional contain a value?</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>                             <span class="c1">// use the value</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get_int_form_user</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上面的代码所示: 使用 optional, 非法的 int 类型, 就不需要定义一个特别的错误码作为无意义值了.</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/utility/optional">cppreference.com: optional</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">A proposal to add a utility class to represent optional objects (Revision 4)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模板方法模式]]></title>
    <link href="http://bitdewy.github.com/blog/2013/05/28/template-method-pattern/"/>
    <updated>2013-05-28T01:26:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/05/28/template-method-pattern</id>
    <content type="html"><![CDATA[<h2>意图</h2>

<ol>
<li>定义一个操作中的算法骨架, 将一些步骤延迟到子类中定义. 模板方法模式, 可以让子类不改变算法的结构重新定义算法的某些步骤.</li>
<li>基类声明算法的“占位符”, 子类来实现这个“占位符”.</li>
</ol>


<h2>讨论</h2>

<p>组件设计者决定哪些算法的步骤是不变的? 哪些是会变化的? 不变的步骤在抽象类中直接实现, 可能变化的步骤给出默认的实现, 或者完全不实现. 变化的部分代表“hooks”, 或占位符. 可以在使用组件时, 在派生类中实现.</p>

<p>组件设计者设计算法的步骤, 步骤的顺序, 但同时允许用户来扩展或替换算法中的某些步骤.</p>

<p>模板方法模式在框架中的使用非常广泛. 每个框架都会实现框架的主要结构, 然后定义一系列的“占位符”给用户, 让用户有机会来自定义一些操作.这么做时, 框架就变成了核心部分, 用户自定义的操作就会变得容易. 这使得控制结构发生反转, 这个方式有一个很好的名字, “好莱坞原则”——“不要给我们打电话, 我们会打电话给你.”</p>

<!-- more  -->


<h2>结构</h2>

<p><img src="https://qhphgq.bay.livefilestore.com/y2pBx_PXPtSilwtV5sYskGDPJkXjmpbdLnwAeT9H_7drKPs4-4_-pm3OfDw58eFEjaFRaa2LSKhbnJODUkyO8CpuQRq8iF306c3KF6Ix_M1zWA/image002.gif" alt="" /></p>

<p>template_method() 的实现如下: 调用 step_one(), 调用 step_two(), 然后调用 step_three(). step_two() 是一个 “hook” 方法——一个占位符. 它在基类中声明, 然后在派生类中实现. 框架中使用模板方法模式非常的频繁. 所有可重用的代码都定义在框架的基类中, 框架的用户可以通过派生类来定制一些想要的行为.</p>

<p><img src="https://qhphgq.bay.livefilestore.com/y2pMCc56J8x2oBUDmOTnSI3RIm-N5Gtpyj355-us-8Rj6CwVbNzQfiEJyprTSAXmCS8rG0MbCE-qwP-Y65dPUdVWyXU8V2FC4IWhzy_2WBvDZA/image003.gif" alt="" /></p>

<h2>做法</h2>

<ol>
<li>检测算法, 决定哪些步骤是标准的通用的, 哪些是特有的.</li>
<li>定义一个抽象类, 用来实现依赖的反转.</li>
<li>将算法的壳以及所有的标准（公共）的步骤移到基类中.</li>
<li>在基类中给那些需要不同实现的步骤定义一个占位符或者“hook”方法, 这些方法可以有默认实现, 也可以完全没有. (C++中的纯虚函数, Java中的抽象方法）</li>
<li>在模板方法中调用这些“占位符”.</li>
<li>所有现有的类都继承于现在的抽象类.</li>
<li>将基类中已经实现的现有的类中的细节全部移除.</li>
<li>那些不同的部分仍然留在这些派生类中，用来实现每个派生类中不同的操作.</li>
</ol>


<h2>经验</h2>

<p>除了粒度的区别之外, 策略模式与模板方法模式非常类似.
模板方法使用继承来改变算法的某个部分, 而策略模式改变整个算法.
策略模式改变单个对象的逻辑. 模板方法修改了整个类的逻辑.
工厂方法模式是一个特化的模板方法模式.</p>

<h2>例子</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">a</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;a  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">c</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;c  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">e</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;e  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 2. Steps requiring peculiar implementations are &quot;placeholders&quot; in base class</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ph1</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ph2</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// 1. Standardize the skeleton of an algorithm in a base class &quot;template method&quot;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">a</span><span class="p">();</span>
</span><span class='line'>        <span class="n">ph1</span><span class="p">();</span>
</span><span class='line'>        <span class="n">c</span><span class="p">();</span>
</span><span class='line'>        <span class="n">ph2</span><span class="p">();</span>
</span><span class='line'>        <span class="n">e</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">One</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 3. Derived classes implement placeholder methods</span>
</span><span class='line'>    <span class="cm">/*virtual*/</span><span class="kt">void</span> <span class="n">ph1</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;b  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="cm">/*virtual*/</span><span class="kt">void</span> <span class="n">ph2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;d  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Two</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/*virtual*/</span><span class="kt">void</span> <span class="n">ph1</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;2  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="cm">/*virtual*/</span><span class="kt">void</span> <span class="n">ph2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;4  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Base</span><span class="o">*</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">One</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Two</span><span class="p">()</span> <span class="p">};</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
</span><span class='line'>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 关键字 using]]></title>
    <link href="http://bitdewy.github.com/blog/2013/05/21/cpp11-keywords-using/"/>
    <updated>2013-05-21T00:45:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/05/21/cpp11-keywords-using</id>
    <content type="html"><![CDATA[<p><em>这个特性, 10年前就已经有提案了, 直到 C++11 中才正式加入标准. ⊙﹏⊙b汗</em></p>

<h2>使用小技巧来声明函数指针</h2>

<p>在 c++03 中, 函数指针要这么写:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">FunctionPtr</span><span class="p">)();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个声明读起来相当的费劲, C 语言的初学者会很难理解上面的 typedef 表达的意思.</p>

<p>在 C++11 中, 我们可以使用更易读懂的方式来表达, 利用 using 关键字:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">using</span> <span class="n">FunctionPtr</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)();</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你想去除丑陋的 * 号, 还可以利用类型特化这么来写:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;type_traits&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="n">FunctionPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">add_pointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>新关键字 using 当然不仅仅是为了这个简单的功能了, 最主要的目的是为了模板别名.</p>

<!-- more -->


<h2>模板别名</h2>

<p>在进入这个主题之前, 应该先弄清楚“模板类”和“类模板”本质上的不同. class template (类模板，是模板)是用来产生 template class (模板类, 是类型)的.
在标准 C++, typedef 可定义模板类一个新的类型名称, 但是不能够使用 typedef 来定义模板的别名. 举例来说:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">first</span><span class="p">,</span> <span class="k">typename</span> <span class="n">second</span><span class="p">,</span> <span class="kt">int</span> <span class="n">third</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">SomeType</span><span class="p">;</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">second</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">SomeType</span><span class="o">&lt;</span><span class="n">OtherType</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">TypedefName</span><span class="p">;</span> <span class="c1">// 在C++03是不合法的</span>
</span></code></pre></td></tr></table></div></figure>


<p>这不能够通过编译.
为了定义模板的别名, C++11 增加了以下的语法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">first</span><span class="p">,</span> <span class="k">typename</span> <span class="n">second</span><span class="p">,</span> <span class="kt">int</span> <span class="n">third</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">SomeType</span><span class="p">;</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">second</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="n">TypedefName</span> <span class="o">=</span> <span class="n">SomeType</span><span class="o">&lt;</span><span class="n">OtherType</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>using 紧跟着的标识, 用来表示后面的模板类型. 标准制定时尝试过使用旧的关键字 typedef 来实现该功能, 但是无法得到一个完整连贯的解决方案, 因此引入了新的关键字. (严格说来 using 并不是一个新的关键字, 在使用 namespace 时, 我们就已经见过它了, 但在 C++11 中它又有了新的语义.）</p>

<p>除了模板别名之外, using 关键字还可以用在一般的类型中, 就想文章一开始的地方一样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">PFD</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>            <span class="c1">// 传统语法</span>
</span><span class='line'><span class="k">using</span> <span class="n">PFD</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>           <span class="c1">// 新增与否</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li>C++ standard  14.6.7 Template aliases;  7.1.3 The typedef specifier</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1489.pdf">Templates aliases for C++</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">Templates Aliases (Revision 3)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] GotW #1 Solution: Variable Initialization – or Is It?]]></title>
    <link href="http://bitdewy.github.com/blog/2013/05/12/gotw1/"/>
    <updated>2013-05-12T02:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/05/12/gotw1</id>
    <content type="html"><![CDATA[<p>原文在这里 <a href="http://herbsutter.com/2013/05/09/gotw-1-solution/">GotW #1 Solution: Variable Initialization – or Is It?</a></p>

<p><em>第一个问题是用来强调理解你写的代码的含义的重要性. 下面是几行简单的代码 &ndash; 大部分都与其他的有一些区别, 即使只是语法略有变化.</em></p>

<h2>JG 问题</h2>

<p>1. 下面的代码有什么不同?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// (a)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">();</span>                 <span class="c1">// (b)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{};</span>                 <span class="c1">// (c)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                <span class="c1">// (d)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>                <span class="c1">// (e)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>               <span class="c1">// (f)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span>             <span class="c1">// (g)</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                 <span class="c1">// (h)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">widget</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>         <span class="c1">// (i)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Guru 问题</h2>

<p>2. 下面的每一行代码做了什么?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">);</span>   <span class="c1">// (a)</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>   <span class="c1">// (b)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3. 除了上面的情况以外, 使用 <code>{ }</code> 初始化对象还有什么其他的好处?</p>

<p>4. 什么时候使用 <code>( )</code> 以及 <code>{ }</code> 来初始化对象? 为什么?</p>

<!-- more -->


<h2>解决方案</h2>

<p>这几个问题展示了几件事:</p>

<ul>
<li>默认初始化, 显式初始化, 拷贝初始化, 以及初始化列表之间的区别.</li>
<li>初始化时 <code>( )</code> 与 <code>{ }</code> 之间的差异.</li>
<li>在现代 C++ 中要避免的, 看起来像初始化, 但完全和初始化无关的东西</li>
</ul>


<p>不过, 最重要的是: 如果你坚持问题 #4 中的两个简单的指导的话, 就可以忽略这些情况, 规则相当的简单, 而且默认情况下可以获得高效的性能.</p>

<h3>1. 下面的代码有什么不同?</h3>

<p>让我们一条一条的来看.</p>

<p><strong>情况 (a) 是默认初始化</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// (a)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这一行代码声明了一个 <code>widget</code> 类型的变量 <code>w</code>, 假定 <code>widget</code> 是一个 <code>class</code> 类型, 它会使用默认构造函数 <code>widget::widget()</code> 来初始化.</p>

<p><strong>情况 (b) 是一个 &ldquo;恼人&rdquo; 的无关转移, 是历史遗留问题</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">();</span>                 <span class="c1">// (b)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是 C++ 的一个陷阱: 第一眼看上去, 它看上去像另一个调用默认构造函数 <code>widget::widget()</code> 的变量声明. 事实上, 感谢语法二义性, 这是一个函数声明. 一个名为 <code>w</code>, 无参, 返回值是 <code>widget</code> 类型的函数声明. (如果你无法一眼看出的话, 考虑下上面的代码其实与 <code>int f()</code> 没有任何的差别, 而这个函数声明是显而易见的对吧.)</p>

<p>避免你认为 &ldquo;吖, 但是那些 <code>()</code> 是多于的, 这是程序员自己的错误, 因为他们没有直接写 <code>widget w;</code>&rdquo;, 注意, 这个的问题也会出现在你以为你正在使用临时对象初始化变量的时候:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// same problem (gadget and doodad are types)</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span> <span class="n">gadget</span><span class="p">(),</span> <span class="n">doodad</span><span class="p">()</span> <span class="p">);</span>  <span class="c1">// pitfall: not a variable declaration</span>
</span></code></pre></td></tr></table></div></figure>


<p>Scott Meyers 很多年前就称这个是 &ldquo;C++ 中最恼人的语法解析&rdquo;, 因为标准中解决语法二义性是这么说的: &ldquo;如果能够被解析为函数声明, 那么它就是一个函数声明.&rdquo;</p>

<p>好消息是, 这个问题将要成为历史, 在新的代码中你将不会遇到它, 因为 C++11 移除了这个陷阱. 注意 C++11 并没有修改语义 &ndash; C++11 的向后兼容 C++98 做的非常好, 包括这个语法二义性, 仍然是它原有的含义. 但是, C++11 通过提供新的语法取代情况 (b), 因此我们再也不会掉到这个陷阱中了.</p>

<p><strong>情况 (c) 干净明确</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{};</span>                 <span class="c1">// (c)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这儿我们有了第一个使用 <code>{ }</code> 而不使用 <code>()</code> 的理由: 对于任意的 class 类型 <code>widget</code>, 情况 (c) 做的事情像 (a) 一样的明确 &ndash; 无二义性, 干净, 明确.</p>

<p>&ldquo;哈哈, 但是等等, 它可没有那么简单!&rdquo; 有些人可能会反对. &ldquo;如果 <code>widget</code> 有一个接受 <code>std::initializer_list</code> 的构造函数那会怎么样呢? 他们都是被优先选择的, 所以, 如果 <code>widget</code> 有这么一个构造函数, 这个写法不会调用它吗?&rdquo;</p>

<p>答案是不会, 这个真的像你看到的一样简单, 因为标准中明确了, 如果可以的话, 空的 <code>{ }</code> 列表意味着调用默认构造函数. 不过, 能意识到 <code>initializer_list</code> 是好的, 让我们在后面再讨论它.</p>

<p><strong>情况 (d) 和 情况 (e) 是直接初始化</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                <span class="c1">// (d)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>                <span class="c1">// (e)</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设 <code>x</code> 不是一个类型名, 这两个都是直接初始化. 因为变量 <code>w</code> 是由 <code>x</code> 直接调用 <code>widget::widget(x)</code> 初始化的. 如果 <code>x</code> 也是 <code>widget</code> 类型, 它会调用拷贝构造函数. 否则的话, 调用一个转换构造函数.</p>

<p>但是, 注意 <code>{x}</code>, 它会创建一个 <code>initializer_list</code>. 如果 <code>widget</code> 有接受 <code>initializer_list</code> 的构造函数的话, 这个构造函数是被优先选择的; 否则, 如果 <code>widget</code> 有接受任意 <code>x</code> 的类型的构造函数的话(包括类型转换), 这个构造函数将会被调用.</p>

<p>情况 (e) 有两个优于 (d) 的地方: 一, 与 (c) 一样, (e) 是明确, 无二义性的. 如果 <code>x</code> 是一个类型名, 那么 (d) 就是一个函数声明, 即使在作用域内有一个名为 <code>x</code> 的变量 (看下文), 而 (e) 不可能是一个函数声明.</p>

<p>第二: (e) 更安全, 因为它不允许有损转换, 一些内建类型是允许的. 考虑下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">i1</span><span class="p">(</span> <span class="mf">12.345</span> <span class="p">);</span>           <span class="c1">// ok: loss .345, we didn&#39;t like it anyway</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i2</span><span class="p">{</span> <span class="mf">12.345</span> <span class="p">};</span>           <span class="c1">// error: would be lossy implicit narrowing</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>情况 (f) 与 (g) 是拷贝初始化和拷贝类表初始化</strong></p>

<p>这是最后两个 non-auto 的情况:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>               <span class="c1">// (f)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是所谓的拷贝初始化. <em>从概念上来讲</em>, 变量 <code>w</code> 是由 <code>widget</code> 的转移构造函数或者拷贝构造函数初始化的. 有可能是在调用一个隐式转换函数之后(显式转换不会调用).</p>

<blockquote><p><strong>通常的错误:</strong> 这个绝对是初始化; 绝不是赋值, 所以绝对不会调用 <code>T::operator=()</code>. 是的, 我知道这有一个<code>=</code>赋值符号, 但是不要让这个符号影响到你 &ndash; 这仅仅是从 C 继承而来的符号, 不是赋值操作符.</p></blockquote>

<p>下面是语义:</p>

<ul>
<li>如果 <code>x</code> 的类型是 <code>widget</code>, (f) 与 (d) <code>widget w(x);</code> 的含义完全一致, 除非明确的构造函数不能使用. 他保证了只有一个构造函数被调用.</li>
<li>如果 <code>x</code> 是其他类型, <em>从概念上来讲</em>编译器首先将 <code>x</code> 隐式转换为 <code>widget</code> 类型的临时对象, 然后对临时右值使用转移构造函数, 如果没有好的转移构造函数, 那么会使用拷贝构造函数 &ndash; &ldquo;低效的转移&#8221;作为备选. 假设存在可用的隐式转换, (f) 就与 <code>widget w(widget(x))</code> 一致了.</li>
</ul>


<p>注意, 上面说了几次<em>从概念上来讲</em>. 这是因为通常编译器都会做优化, 优化掉临时变量, 如果存在隐式转换, 从 (f) 转换为 (d), 那么就优化掉了额外的转移操作. 但是, 尽管编译器这么做了, <code>widget</code> 的拷贝构造函数也必须是可访问的, 即使没有调用 &ndash; 拷贝构造函数的副作用可能发生也可能不发生, 就这些.</p>

<p>现在来注意一下增加的符号 <code>=</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span>             <span class="c1">// (g)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个是所谓的拷贝列表初始化. 它与 <code>widget w{x};</code> 的含义一致 除非显示的构造函数无法使用. 它保证了只有咦个的构造函数被调用.</p>

<p><strong>情况 (h) 和 (i) 也是拷贝初始化, 但是更简单</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                 <span class="c1">// (h)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">widget</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>         <span class="c1">// (i)</span>
</span></code></pre></td></tr></table></div></figure>


<p>语义与 (f) 和 (g) 一样, 但是学习起来更简单, 因为使用了 <code>auto</code> 保证了右侧表达式类型推导的准确性. 需要注意的是 (i) 在隐式转换与显式转换的情况下都能正常工作.</p>

<p>(h) 与 (d) 的含义一致, <code>type_of_x w(x);</code>. 只有一个拷贝构造函数被调用. 它可以保证类型发生变化时, 程序还总是正确的: 因为 (h) 没有明确特性的类型, 它有两个有效的保证, 因为这不会存在类型的转换, 以及更好的维护性, 因为当程序中 <code>x</code> 的类型变更时, &lsquo;w&rsquo; 会自动变更类型与 <code>x</code> 保持一致.</p>

<p>当你想要明确类型或者需要显式的类型转换时, (i) 是最风格一致的, 而且一旦使用了 <code>{ }</code> 就可以避免有损的类型转换了. 大部分的编译器实现, 只会有一个构造函数调用 &ndash; 和我们看到的 (f) 与 (g) 相似, 概念上来讲会有两个构造函数调用, 一个转换构造函数或者拷贝构造函数用来创建临时的 <code>widget{x}</code> 然后紧接着一个转移构造函数来构造 <code>w</code>, 但是编译器会把后一个优化掉.</p>

<p>通常情况下, 我推荐你尝试这两种用法, 并倾向于使用它来伴随你舒服的成长. 现在几乎所有我写的局部变量声明都采用这种方式. (我知道会有一些人怀疑这种方式 &ndash; 更多的关于关键字 <code>auto</code> 的问题在其他的 GotW 中讨论.)</p>

<h3>2. 下面的每一行代码做了什么?</h3>

<p>在第二个问题的代码中, 我们创建了一个 <code>vector&lt;int&gt;</code> 并将参数 <code>10</code> 和 <code>20</code> 传给它的构造函数 &ndash; 第一种情况是 <code>(10, 20)</code>, 第二种情况是 <code>{10, 20}</code>.</p>

<p>两个都会调用构造函数, 但是会调用哪个呢? 嗯, <code>vector&lt;int&gt;</code> 有很多接受两个参数的构造函数, 但是只有下面两个能够正确的接受参数 <code>10</code> 和 <code>20</code>. 为了简单, 忽略掉默认的分配器参数, 两个构造函数应该是下面的样子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="p">(</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">);</span>    <span class="c1">// A: n copies of value</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="p">(</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span> <span class="p">);</span>  <span class="c1">// B: copy of values</span>
</span></code></pre></td></tr></table></div></figure>


<p>有两个简单的规则可以帮助我们确定哪个函数将被调用:</p>

<ul>
<li>在表达式的上下文中使用 <code>{ }</code> 你会得到一个 <code>initializer_list</code>.</li>
<li>接受 <code>initializer_list</code> 参数的构造函数会优于其他构造函数被选择, 同时会隐藏其他构造函数, 否则可能是可行的.</li>
</ul>


<p>有了这两条, 答案就很简单了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">);</span>    <span class="c1">// (a) calls A: 10 copies of the value 20</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span> <span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>    <span class="c1">// (b) calls B: the values 10 and 20</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. 除了上面的情况以外, 使用 <code>{ }</code> 初始化对象还有什么其他的好处?</h3>

<p>首先, 这叫做统一初始化, 因为它统一 &ndash; 所有的类型, 包括 <code>structs</code>, 数组, 标准库容器, 而且也不存在恼人的语法解析问题.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">mystruct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// C++98 </span>
</span><span class='line'><span class="n">rectangle</span>       <span class="n">w</span><span class="p">(</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">);</span>       <span class="c1">// oops, vexing parse </span>
</span><span class='line'><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">(</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">);</span>
</span><span class='line'><span class="n">mystruct</span>        <span class="n">m</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span>             <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>     <span class="n">v</span><span class="p">;</span>                              <span class="c1">// urk, need more code</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">//   to initialize this</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// C++11 (note: &quot;=&quot; is optional)</span>
</span><span class='line'><span class="n">rectangle</span>       <span class="n">w</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">};</span>
</span><span class='line'><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span>   <span class="o">=</span> <span class="p">{</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">};</span>
</span><span class='line'><span class="n">mystruct</span>        <span class="n">m</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span>             <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>     <span class="n">v</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意, 这不仅仅是个审美的问题. 考虑编写通用的能够初始化任何类型的代码&hellip; 我们正在做的, 让我们使用完美转发做为例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">forwarder</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">local</span> <span class="o">=</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">};</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>            <span class="p">(</span> <span class="mi">42</span> <span class="p">);</span>                  <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">rectangle</span><span class="o">&gt;</span>      <span class="p">(</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">);</span>    <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">mystruct</span><span class="o">&gt;</span>       <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>                <span class="c1">// ok because of {}</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span>          <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>          <span class="c1">// ok because of {}</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span>    <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>          <span class="c1">// ok because of {}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果 <code>forwarder</code> 内部使用了 <code>( )</code> 做初始化符号的话, 那么最后三条是不合法的.</p>

<p>新的符号 <code>{ }</code> 在任何地方都能完美的工作, 包括类成员的初始化:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span><span class="o">::</span><span class="n">widget</span><span class="p">(</span> <span class="cm">/*...*/</span> <span class="p">)</span> <span class="o">:</span> <span class="n">mem1</span><span class="p">{</span><span class="n">init1</span><span class="p">},</span> <span class="n">mem2</span><span class="p">{</span><span class="n">init2</span><span class="p">,</span> <span class="n">init3</span><span class="p">}</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外, 它还能简单清晰的表达传递函数参数, 返回值, 而不需要一个具名的临时对象:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">draw_rect</span><span class="p">(</span> <span class="n">rectangle</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">draw_rect</span><span class="p">(</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">)</span> <span class="p">);</span>         <span class="c1">// C++98</span>
</span><span class='line'><span class="n">draw_rect</span><span class="p">({</span> <span class="n">origin</span><span class="p">,</span> <span class="n">selection</span> <span class="p">});</span>                  <span class="c1">// C++11</span>
</span><span class='line'>
</span><span class='line'><span class="n">rectangle</span> <span class="n">compute_rect</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>   <span class="c1">// ...</span>
</span><span class='line'>   <span class="k">if</span><span class="p">(</span><span class="n">cpp98</span><span class="p">)</span> <span class="k">return</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">);</span>  <span class="c1">// C++98</span>
</span><span class='line'>   <span class="k">else</span>      <span class="k">return</span> <span class="p">{</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">};</span>           <span class="c1">// C++11</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. 什么时候使用 <code>( )</code> 以及 <code>{ }</code> 来初始化对象? 为什么?</h3>

<p>下面是简单的指导:</p>

<blockquote><p><strong>准则:</strong> 尽量在初始化时使用 <code>{ }</code>, 比如 <code>vector&lt;int&gt; v = { 1, 2, 3, 4 };</code> 或者 <code>auto v = vector&lt;int&gt;{ 1, 2, 3, 4 };</code>, 因为它有更好的一致性, 更正确, 可以避免去了解过去的陷阱. 在单参数的情况下你可能会仅仅看到一个赋值符号 <code>=</code>, 就像 <code>int i = 42;</code> 一样, 这种情况下, 省略括号是好的&hellip;</p></blockquote>

<p>上面的准则可以覆盖绝大部分情况, 但是也有一个例外:</p>

<blockquote><p>&hellip; 在极端情况下, 比如 <code>vector&lt;int&gt; v(10,20);</code> 或者 <code>auto v = vector&lt;int&gt;(10,20);</code> 时, 使用 <code>( )</code> 明确的调用会被 <code>initializer_list</code> 构造函数隐藏的构造函数.</p></blockquote>

<p>但是, 这个仅仅是在极端情况下, 因为默认构造函数以及拷贝构造函数已经很特别, 并且能与括号 <code>{ }</code> 很好的工作, 现在一个好的类的设计会避免用到 <code>()</code> 来提供用户定义的构造函数, 因为下面的设计准则:</p>

<blockquote><p><strong>准则</strong>: 当你设计一个类时, 避免提供一个与 <code>initializer_list</code> 构造函数会产生二义性的构造函数, 这样用户就不需要使用 <code>()</code> 来访问会被隐藏掉的构造函数.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用静态多态辅助动态多态]]></title>
    <link href="http://bitdewy.github.com/blog/2013/04/09/staitc-and-dynamic-polymorphism/"/>
    <updated>2013-04-09T23:13:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/04/09/staitc-and-dynamic-polymorphism</id>
    <content type="html"><![CDATA[<h2>静态多态 (编译期多态) 与动态多态 (运行期多态)</h2>

<p>关键字: 重载/模版和虚函数</p>

<p>类型: 编译期多态 (静态多态, 早绑定) 和运行期多态 (晚绑定)
编译期多态 (重载/模版), 运行期多态 (虚函数)</p>

<p>应用形式上:
静多态是发散式的, 让相同的实现代码应用于不同的场合.
动多态是收敛式的, 让不同的实现代码应用于相同的场合.</p>

<p>思维方式上:
静多态是泛型式编程风格, 它看重的是算法的普适性.
动多态是对象式编程风格, 它看重的是接口和实现的分离度.</p>

<h2>std::shared_ptr 中的 deleter 是如何工作的?</h2>

<p>标准库中的引用计数智能指针 shared_ptr 很有趣——你可以向其构造器传递一个函数或者仿函数 (function object, 或 functor), 当引用计数归零的时候, 它将在被引用对象上调用删除器 (deleter). 乍一看, 似乎没啥了不起啊, 但请看代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">shared_ptr</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">explicit</span> <span class="n">shared_ptr</span><span class="p">(</span><span class="n">U</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">D</span> <span class="n">deleter</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>注意 <code>shared_ptr&lt;T&gt;</code> 必然在析构时调用类型为 D 的删除器, 然而它根本不知道 D 为何物. 这个对象不能包含类型为 D 的数据成员, 也不能指向类型为 D 的对象, 因为声明其数据成员时, D 对它而言还是未知的. 那么, shared_ptr 对象如何跟踪删除器 (它在构造阶段传入: 当 T 对象将被销毁时, 还得使用它) 呢? 更通俗地说, 构造器如何将未知类型的信息传递给它正在构造的对象, 而这个对象本身对信息类型完全无知? 答案很简单: 让此对象包含一个指向已知类型基类的指针 (标准库中叫它 sp_counted_base), 然后让构造器以 D 为参数实例化一个派生于上述基类的模板 (标准库中叫 sp_counted_impl_p 和 sp_counted_impl_pd), 最后用声明于基类, 实现于派生类的虚函数 (标准库中使用 dispose) 去调用删除器. 关于这个问题, Scott Meyers 在 06 年 9 月份的一篇文章中已经有阐述, 详见: <a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">My Most Important C++ Aha! Moments</a>.</p>

<h2>结合静态多态和动态多态实现类型无关的容器</h2>

<p>使用 std::shared_ptr 中 deleter 的实现方式, 可以实现类型无关的容器. 代码主干如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">any</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">any</span><span class="p">()</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">any</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="k">new</span> <span class="n">holder</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">any</span><span class="p">(</span><span class="k">const</span> <span class="n">any</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">content</span> <span class="o">?</span> <span class="n">other</span><span class="p">.</span><span class="n">content</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">any</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">content</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="n">swap</span><span class="p">(</span><span class="n">any</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">content</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">any</span><span class="p">(</span><span class="n">rhs</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">any</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">rhs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">content</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">content</span> <span class="o">?</span> <span class="n">content</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">:</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">placeholder</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="o">~</span><span class="n">placeholder</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">placeholder</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">holder</span> <span class="o">:</span> <span class="k">public</span> <span class="n">placeholder</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">holder</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">held</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">typeid</span><span class="p">(</span><span class="n">ValueType</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">placeholder</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">holder</span><span class="p">(</span><span class="n">held</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">ValueType</span> <span class="n">held</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">holder</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">holder</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">placeholder</span><span class="o">*</span> <span class="n">content</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中, any 类持有一个 placeholder 的基类指针, 在构造 any 对象时, 通过 any 的模板构造函数, 根据具体类型创建具体的 placeholder 子类类型, any 类提供 type() 接口, 用于查询 any 类中存储的实际类型.boost::any 中有类似的实现.</p>

<p>使用方式如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">bitdewy</span><span class="o">::</span><span class="n">any</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">any_array</span><span class="p">;</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">.1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">any_array</span><span class="p">),</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">any_array</span><span class="p">),</span>
</span><span class='line'>                <span class="p">[](</span><span class="k">const</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">double</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//LOG ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考</h3>

<ul>
<li><a href="http://svn.boost.org/svn/boost/trunk/boost/any.hpp">boost::any</a></li>
<li><a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">My Most Important C++ Aha! Moments</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QtScript 与信号槽]]></title>
    <link href="http://bitdewy.github.com/blog/2013/03/21/qtscript/"/>
    <updated>2013-03-21T14:53:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/03/21/qtscript</id>
    <content type="html"><![CDATA[<p>Qt从4.3开始, 提供了 <a href="http://zh.wikipedia.org/wiki/ECMAScript">ECMAScript</a> 支持，QtScript 模块提供了一些让 Qt 应用程序脚本化的类. 在 Qt4 中 Webkit 与 QtScript 使用了相同的 javascript 引擎实现.（Qt5 中, javascript 引擎使用了 google 的 V8）</p>

<h2>在 QtScript 中使用信号槽</h2>

<p>Qt Script 可以使用Qt的核心特性: 信号槽. 信号只能存在于 C++ 的代码中, 但槽函数，以及连接的动作可以放到 javascript 中来做</p>

<ol>
<li>C++ 调用 script: 连接 C++ 代码中的信号到 script 函数上. 这个 script 函数可以是 C++ 代码中包含的 script 字符串, 也可以是从文件中读进来的. 如果不想将 QObject 对象泄露到脚本的运行环境中时, 这个方法是非常有用的. 仅仅需要在 script 代码中定义信号需要怎么被响应, 剩下的就是把连接工作放到 C++ 代码里就可以了.</li>
<li>Script 调用 C++: script 可以连接注入到脚本环境中的 C++ 对象的信号和槽, 在这种情况下, 槽函数还是定义在 C++ 代码中, 但是信号和槽的连接完全是动态的（在 script 中完成）</li>
<li>纯script: script 可以定义信号的响应函数句柄, 然后使用句柄建立信号与槽的连接. 比如： script 可以定义一个函数用来响应 <code>QLineEdit::returnPressed()</code> 信号, 然后连接信号与 script 函数.</li>
</ol>


<!-- more -->


<p>使用 <code>qScriptConnect()</code> 函数连接 C++ 信号到 script 函数上. 下面的例子中, handler 用来处理 <code>QLineEdit::textChanged()</code> 信号:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">QScriptEngine</span> <span class="n">eng</span><span class="p">;</span>
</span><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span>
</span><span class='line'><span class="s">&quot;(function(text) { print(&#39;text was changed to&#39;, text); })&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">textChanged</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="p">)),</span> <span class="n">QScriptValue</span><span class="p">(),</span> <span class="n">handler</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>qScriptConnect()</code> 的前两个参数与 <code>QObject::connect()</code> 的完全一致. 第三个参数是 script 对象, 当 signal handler 被调用时, 它充当 <code>this</code> 的角色. 在上面的代码中, 我们传入了一个不可用的值, 此时 <code>this</code> 是全局对象. 第四个参数是 script 函数, 相当于槽函数.
下面的代码展示如何使用 <code>this</code> 参数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s">&quot;(function() { print(&#39;I am&#39;, this.name); })&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">obj1</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">newObject</span><span class="p">();</span>
</span><span class='line'><span class="n">obj1</span><span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;the walrus&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">obj2</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">newObject</span><span class="p">();</span>
</span><span class='line'><span class="n">obj2</span><span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;Sam&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit1</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">returnPressed</span><span class="p">()),</span> <span class="n">obj1</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit2</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">returnPressed</span><span class="p">()),</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建了两个 <code>QLineEdit</code> 对象, 然后定义了信号响应函数. 信号槽链接使用了相同的响应函数, 但是使用不同的 <code>this</code> 对象, 具体使用哪个, 取决于哪个对象发出信号, 因此 <code>print()</code> 语句输出的内容将会有所不同.</p>

<p>在某个项目中,设计之初曾经考虑过以下的交互方式: javascript 传入 json 对象, 其中某个 value 是匿名 function, 来实现异步调用. 这种方式看起来很美, 也与第一种方式类似, 但是存在问题. C++ 无法获得当前 webkit 的 javascript 运行环境. QtScript 曾考虑过提供 API 来访问 webkit 的 javascript 运行环境, 详细信息可以参考：<a href="https://bugreports.qt-project.org/browse/QTWEBKIT-2">https://bugreports.qt-project.org/browse/QTWEBKIT-2</a>, 但由于种种原因最终放弃了, 不得不说这是个遗憾.</p>

<h2>参考</h2>

<ul>
<li><a href="http://qt-project.org/doc/qt-4.8/qtscript.html">http://qt-project.org/doc/qt-4.8/qtscript.html</a></li>
<li><a href="http://qt-project.org/doc/qt-4.8/scripting.html">http://qt-project.org/doc/qt-4.8/scripting.html</a></li>
<li><a href="http://qt-project.org/doc/qt-4.8/qtwebkit-bridge.html">http://qt-project.org/doc/qt-4.8/qtwebkit-bridge.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[空基类优化]]></title>
    <link href="http://bitdewy.github.com/blog/2013/02/25/empty-base-optimization/"/>
    <updated>2013-02-25T07:50:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/02/25/empty-base-optimization</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>优化空类数据成员的存储空间</p>

<h2>别名</h2>

<p>EBCO: Empty Base Class Optimization
Empty Member Optimization</p>

<h2>动机</h2>

<p>大小为 0 的类在 C++ 中是不存在的. C++ 需要空类大小不为 0 以确保对象的标识. 例如下面的 <code>EmptyClass</code> 的大小就是非 0 的, 因为数组中每一个对象的标识都是唯一的. 如果 <code>sizeof(EmptyClass)</code> 的大小为 0, 指针算数就会失效. 一般情况下, 类似 <code>EmptyClass</code> 的类大小通常为 1.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">EmptyClass</span> <span class="p">{};</span>
</span><span class='line'><span class="n">EmptyClass</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// Size of this array can’t be zero.</span>
</span></code></pre></td></tr></table></div></figure>


<p>当类似的类作为另一个类的数据成员时, 它的大小一般比 1 字节要大. 编译器通常 4 字节对齐来避免切割. 4 字节的空类对象只是占位符, 毫无用处. 避免浪费空间, 节省内存, 帮助对象更适应 CPU 缓存是非常有好处的.</p>

<!-- more -->


<h2>解决方案&amp;示例代码</h2>

<p>在 C++ 中, 如果一个空类作为基类被继承时, 情况会和上面的有些区别. 编译器允许继承层次结构扁平化, 被继承的空基类不占用空间. 例如下面的代码中 <code>sizeof(AnInt)</code> 在 32 位架构中是 4 字节, <code>sizeof(AnotherEmpty)</code> 是 1 字节, 虽然这两个类都继承自 <code>EmptyClass</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">AnInt</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EmptyClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>   <span class="c1">// size = sizeof(int)</span>
</span><span class='line'><span class="k">class</span> <span class="nc">AnotherEmpty</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EmptyClass</span> <span class="p">{};</span>  <span class="c1">// size =  1</span>
</span></code></pre></td></tr></table></div></figure>


<p>EBCO 有效的利用了这个特性. 这并不是说简单, 天真的将数据成员的空类变成基类是可取的, 因为这可能会暴露原本需要对用户隐藏的接口. 例如下面的 EBCO 实现方式, 可能会有副作用: 类 <code>Foo</code> 的用户现在可以看到一些方法 (如果在 E1, E2 中存在的话), 虽然他们是私有继承而来的, 不可访问.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">E1</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">E2</span> <span class="p">{};</span>
</span><span class='line'><span class="c1">// **** before EBCO ****</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">E1</span> <span class="n">e1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">E2</span> <span class="n">e2</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span> <span class="c1">// sizeof(Foo) = 8</span>
</span><span class='line'><span class="c1">// **** after EBCO ****</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="k">private</span> <span class="n">E1</span><span class="p">,</span> <span class="k">private</span> <span class="n">E2</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span> <span class="c1">// sizeof(Foo) = 4</span>
</span></code></pre></td></tr></table></div></figure>


<p>一种实现 EBCO 的实用方法是: 将空的类成员组合到单一的存储结构扁平的成员中. 下面的模板 <code>BaseOptimization</code> 的前两个模板参数是用来实现 EBCO的. 使用 <code>BaseOptimization</code> 改写类 <code>Foo</code> 如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Base1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Base2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Member</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">BaseOptimization</span> <span class="o">:</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">Member</span> <span class="n">member</span><span class="p">;</span>
</span><span class='line'>   <span class="n">BaseOptimization</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>   <span class="n">BaseOptimization</span><span class="p">(</span><span class="n">Base1</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b1</span><span class="p">,</span> <span class="n">Base2</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">b2</span><span class="p">,</span> <span class="n">Member</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">mem</span><span class="p">)</span>
</span><span class='line'>       <span class="o">:</span> <span class="n">Base1</span><span class="p">(</span><span class="n">b1</span><span class="p">),</span> <span class="n">Base2</span><span class="p">(</span><span class="n">b2</span><span class="p">),</span> <span class="n">member</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>   <span class="n">Base1</span> <span class="o">*</span> <span class="n">first</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>   <span class="n">Base2</span> <span class="o">*</span> <span class="n">second</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">BaseOptimization</span><span class="o">&lt;</span><span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span> <span class="c1">// sizeof(Foo) = 4</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 EBCO 并没有改变类 Foo 的继承体系. 保证基类不会互相冲突, 这是至关重要的. 也就是说 Base1 与 Base2 是独立的集成体系中的一部分.</p>

<p><strong>注意</strong>: 对象身份标识的问题, 不同的编译器处理起来是不相同的. 空对象的地址可能是相同的, 也可能是不同的. 例如: BaseOptimization 的成员函数 first 和 second 返回的指针, 在有些编译器上可能是相同的, 而有些编译器上可能是不同的. 更多的讨论请看这里：<a href="http://stackoverflow.com/questions/7694158/boost-compressed-pair-and-addresses-of-empty-objects">stackoverflow</a></p>

<h2>已知的用途</h2>

<p><a href="http://www.boost.org/doc/libs/1_53_0/libs/utility/compressed_pair.htm">boost::compressed_pair</a> 使用了该惯用法, 来优化 pair 的存储空间
C++03 模拟实现 <a href="http://home.roadrunner.com/~hinnant/unique_ptr03.html">unique­_ptr</a> 也使用了该惯用法</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.informit.com/articles/article.aspx?p=31473&amp;seqNum=2">The Empty Base Class Optimization (EBCO)</a></li>
<li><a href="http://www.cantrip.org/emptyopt.html">The &ldquo;Empty Member&rdquo; C++ Optimization</a></li>
<li><a href="http://www.ibm.com/developerworks/aix/library/au-boostutilities/index.html">Internals of boost::compressed_pair</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 C++03 中实现强类型安全的枚举类型]]></title>
    <link href="http://bitdewy.github.com/blog/2013/02/05/strongly-type-safe-enum-in-cpp03/"/>
    <updated>2013-02-05T21:53:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/02/05/strongly-type-safe-enum-in-cpp03</id>
    <content type="html"><![CDATA[<h2>意图</h2>

<p>改进 C++ 枚举的类型安全性</p>

<h2>动机</h2>

<p>在 C++03 中枚举类型的类型安全性不够强, 有可能导致意想不到的错误. 虽然枚举是语言内置的特性, 但也可能由于编译器的不同, 而存在可移植性的问题. 枚举的问题基本上可以分为3类:</p>

<ul>
<li>隐式转换</li>
<li>无法指定类型</li>
<li>作用域问题</li>
</ul>


<p>C++03 中枚举类型是部分类型安全的, 比如你将一个枚举类型的值直接赋值给另一个枚举类型, 而且无法从整形隐式转换到枚举类型. 但是, 最常见的枚举类型错误是: 它可以自动提升成整形. 例如下面的代码, 只有少数几个的编译器（比如 GNU 的 g++）会发出警告, 而 VC++ 不会有任何的提示.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">enum</span> <span class="n">color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
</span><span class='line'><span class="k">enum</span> <span class="n">shape</span> <span class="p">{</span> <span class="n">circle</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="n">triangle</span> <span class="p">};</span>
</span><span class='line'><span class="n">color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="n">triangle</span><span class="p">);</span> <span class="c1">// Unintended!</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>C++03 中枚举类型另外的问题是无法指定枚举存储时的类型. 这可能导致数据大小以及符号问题在各个编译器上表现不同而导致不可移植的问题. 最后, 是作用域问题, 在相同的作用域内不能有两个相同名称的枚举值.</p>

<p>强类型的枚举已经进入 C++11 标准中. 详细内容参考: <a href="http://www.stroustrup.com/C++11FAQ.html#enum">C++11 FAQ: enum class</a>
下面是 C++03 强类型安全的枚举实现。</p>

<h2>解决方案&amp;示例代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">def</span><span class="p">,</span> <span class="k">typename</span> <span class="n">inner</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">def</span><span class="o">::</span><span class="n">type</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">safe_enum</span> <span class="o">:</span> <span class="k">public</span> <span class="n">def</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">def</span><span class="o">::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
</span><span class='line'>  <span class="n">inner</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">safe_enum</span><span class="p">(</span><span class="n">type</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">inner</span> <span class="n">underlying</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">!=</span> <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span>  <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span>  <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&gt;</span>  <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span>  <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">color_def</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">type</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">safe_enum</span><span class="o">&lt;</span><span class="n">color_def</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">shape_def</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">type</span> <span class="p">{</span> <span class="n">circle</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="n">triangle</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">safe_enum</span><span class="o">&lt;</span><span class="n">shape_def</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">shape</span><span class="p">;</span> <span class="c1">// unsigned char representation</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="n">shape</span><span class="o">::</span><span class="n">triangle</span><span class="p">);</span> <span class="c1">// Compiler error.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上述解决方案的代码中, 实际的枚举类型包裹在 <code>color_def</code> 和 <code>shape_def</code> 结构体中. <code>safe_enum</code> 模板帮我们实现了一个类型安全的枚举. <code>safe_enum</code> 使用了 <a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Parameterized_Base_Class">Parameterized Base Class</a> 惯用法. 它继承了模板参数 <code>color_def</code> 以及 <code>shape_def</code>, 使得 color 以及 shape 变成了强类型安全的枚举.</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">Strongly Typed Enums (revision 3)</a></li>
<li><a href="http://scottmeyers.blogspot.hk/2013/01/effective-c11-content-and-status.html">Effective C++11: Content and Status -Prefer enum classes to enums.</a></li>
<li><a href="http://www.stroustrup.com/C++11FAQ.html#enum">C++11 FAQ: enum class &mdash; scoped and strongly typed enums</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你确定你懂 const 和 mutable ?]]></title>
    <link href="http://bitdewy.github.com/blog/2013/01/03/you-dont-know-const-and-mutable/"/>
    <updated>2013-01-03T14:38:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/01/03/you-dont-know-const-and-mutable</id>
    <content type="html"><![CDATA[<p>const 和 mutable 是 C++ 中两个关键字，你确定你懂 const 和 mutable 吗？</p>

<p>下面是一段完整的 C++11 代码;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;utility&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">async</span><span class="p">([]{</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">z</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">};</span> <span class="p">});</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">async</span><span class="p">([]{</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">z</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="p">};</span> <span class="p">});</span>
</span><span class='line'>  <span class="n">x</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="n">y</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的程序能正确同步么? 有线程安全的问题吗?</p>

<p>嗯, vector 是标准库的内置容器, 如果换成我们自己写的类呢? 比如下面的代码;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;utility&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">async</span><span class="p">([]{</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">widget</span><span class="p">,</span> <span class="n">widget</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">{</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="p">};</span> <span class="p">});</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">async</span><span class="p">([]{</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">widget</span><span class="p">,</span> <span class="n">widget</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">{</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="p">};</span> <span class="p">});</span>
</span><span class='line'>  <span class="n">x</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="n">y</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>widget</code> 的线程安全性如何?</p>

<!-- more -->


<p>上面的问题先放一放, 我们来看一个基础的问题.</p>

<p>在 C++98 中, <code>const</code> 表示什么含义?</p>

<p>嗯, <code>const</code> 表示不可更改, 不过它是 logically const, 而不是 physically 或者 bitwise 的 const.</p>

<p>如果你对 const 的认识仅限于此, 那么可以说你不懂 const, 在 C++11 中, 你需要重新认识 const.</p>

<p><strong>C++11 中增加了一直空白的对于多线程的描述.</strong></p>

<p>看一下 C++11 标准中是怎么说的吧, C++11 标准文档, 语言核心部分 1.10 第4条和第21条:</p>

<p><em>两个表达式, 如果其中一个正在<strong>修改</strong>内存, 而另一个去访问或<strong>修改</strong>相同的内存, 那么两个表达式会发生<strong>冲突</strong>.</em></p>

<p><em>如果一个程序在不同的线程中包含了两个会<strong>冲突</strong>的动作, 至少其中一个不是原子操作, 且不会在另一个动作发生之前发生, 那么程序运行时会产生<strong>数据竞争</strong>. 任何的数据竞争都会导致未定义的行为.</em></p>

<p>再来看看关于标准库部分 17.6.5.9 的第1条和第3条:</p>

<p><em>这一节的指定要求是防止<strong>数据竞争</strong>.</em></p>

<p><em>C++ 标准库函数除在当前线程外, 不能直接或间接的修改对象, 除非这个对象是通过函数的非 const 参数直接或间接的访问的, 包括 <code>this</code> 指针.</em></p>

<p>这样一来, const 的含义就变为了 只读 或 线程安全.</p>

<p>下面来看一下标准中 20.2 的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span><span class='line'><span class="k">namespace</span> <span class="n">rel_ops</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">[...]</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>  <span class="p">[...]</span> <span class="nl">Returns:</span> <span class="o">!</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>返回值 <code>!(x == y)</code> 意味着什么?</p>

<p>这意味着, 使用 std::rel_ops 的任何类型都需要提供线程安全的 <code>operator==</code> 和 <code>operator&lt;</code>. 比如, 在不同的线程中, 比较同一个对象时, 不需要串行化访问.</p>

<p>再来看看 20.3.2 的 <code>std::pair</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">pair</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">pair</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>构造函数的参数 <code>const T1&amp; x, const T2&amp; y</code> 这意味着什么?</p>

<p>这意味着, 任何支持拷贝, 会作为 <code>std::pair</code> 类型参数的类型 T, 都需要支持线程安全的拷贝. 比如, 多个线程同时拷贝同一个对象时, 不需要显式的串行化访问.</p>

<p>上面说的这些是什么意思?</p>

<p>线程安全:</p>

<ul>
<li>bitwise const, 或者</li>
<li>类似 leaf-level locking(像 std::atomics) 的内部串行化 (非 leaf level 的 locking 可能会导致死锁)</li>
</ul>


<p>标准库保证了 const == 线程安全:</p>

<ul>
<li>所有的标准库中的类, 以及</li>
<li>所有能作用到用户自定义类型的操作符</li>
</ul>


<p>所以就照着标准库的方式来做吧.</p>

<p>任何一个标准库中定义的类, 如果声明一个该类型的 const 对象, 那么它就是线程安全的. (完全不可更改, 或者有内部的串行化访问)</p>

<p>在 C++98 中, const 意味着逻辑上不可更改. 而在 C++11 中, const 意味着线程安全(内存完全不可改, 或者内部实现了串行化访问).</p>

<p>明白了 const, 接下来看看下面的代码有什么问题:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>  <span class="c1">// protects internal data</span>
</span><span class='line'>  <span class="c1">//...     // more data</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">info</span> <span class="n">get_info</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">hold</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="cm">/* use &#39;more data&#39;*/</span><span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>是的, 上面的代码编译不过. <code>lock_guard</code> 需要的是 <code>mutex&amp;</code> 类型, 而现在的类型是 <code>const mutex&amp;</code>.</p>

<p>那么该如何修改呢? 像下面这样么?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>  <span class="c1">// protects internal data</span>
</span><span class='line'>  <span class="c1">//...     // more data</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">info</span> <span class="n">get_info</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">hold</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">m_</span><span class="p">));</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="cm">/* use &#39;more data&#39;*/</span><span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这么改, 没有任何问题, 程序可以正确的运行, 但是, 我们需要在使用了 m_ 的地方都用一下 <code>const_cast</code>. 包括以后新增的代码也需要, 这显然不是个好办法.</p>

<p>改成下面这样呢?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">mutable</span> <span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>  <span class="c1">// protects internal data</span>
</span><span class='line'>  <span class="c1">//...             // more data</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">info</span> <span class="n">get_info</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">hold</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="cm">/* use &#39;more data&#39;*/</span><span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>回顾一下, <code>mutable</code> 在 C++98 中的含义: “mutable 表示不会被观察到的非 const.”</p>

<p>如果你对 mutable 的认识仅限于此, 那么可以说你不懂 mutable, 在 C++11 中, 你需要重新认识 mutable.</p>

<p><strong>一个类内部的 mutex 对象想要成为 mutable 类型. 为什么?</strong></p>

<p><strong>因为 mutex 自己已经是串行化访问的了</strong>.</p>

<p>在 C++98 中, mutable 意味着不会被观察到的非 const, 而在 C++11 中, mutable 意味着线程安全.</p>

<p>现在再看上面的代码, mutable表达了什么?</p>

<p>没错，线程安全, 而且是自然而且完美的表达, 因为 mutable 通常就是意味着 “as good as const/ logically const”.</p>

<p>再来看一个例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter_</span><span class="p">;</span>            <span class="c1">// protects internal data</span>
</span><span class='line'>  <span class="c1">//...                            // more data</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">info</span> <span class="n">get_info</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">++</span><span class="n">counter_</span><span class="p">;</span>                    <span class="c1">// oops, const</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="cm">/* use &#39;more data&#39;*/</span><span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>与最开始 mutex 的例子一样, 这段代码编译不过. 我们要做的就是把 <code>counter_</code> 声明为 <code>mutable</code>. 因为counter_ 本身就是线程安全的.</p>

<p>C++11 中增加了关于多线程的内容，<code>const</code> 与 <code>mutable</code> 关键字有了新的语义.</p>

<h3>参考</h3>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">C++ 标准草案 n3242</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2669.htm">Thread-Safety in the Standard Library (Rev 2)</a></li>
<li><a href="http://channel9.msdn.com/posts/C-and-Beyond-2012-Herb-Sutter-You-dont-know-blank-and-blank">C++ and Beyond 2012: Herb Sutter &ndash; You don&rsquo;t know [blank] and [blank]</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 lambda in Qt5]]></title>
    <link href="http://bitdewy.github.com/blog/2012/12/23/c-plus-plus-11-lambda-in-qt5/"/>
    <updated>2012-12-23T22:32:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2012/12/23/c-plus-plus-11-lambda-in-qt5</id>
    <content type="html"><![CDATA[<p>C++11 发布已经1年多，各家编译器也都有了很好的支持，新特性中有非常多值得关注的东西，比如：右值引用、类型推导、匿名函数等等。</p>

<h2>lambda 函数与表达式</h2>

<p>C++11 引入了 lambda 函数，在函数是 first class 的语言中，匿名函数是最基础的设施，可以方便的运用闭包造出高阶函数。现在 C++11 引入了 lambda 表达式（是不是可以在 C++ 中玩 Functional Programming 了，嘿嘿)，和标准库算法配合起来就不会像以前那么别扭了。在没有 lambda 的时候使用 <code>std::sort</code> 或者 <code>std::find</code> 时，需要一个具名函数，原本一个很简单的，用完就丢掉的代码段必须声明为一个函数或仿函数，割裂了逻辑不说，还占用了一个标识符(取名，在写代码的时候时很让人头疼的一件事，你懂的)，现在一切都变的简单了。</p>

<!-- more -->


<p>假设你想计算某个字符串包含多少个大写字母，使用 for_each() 遍历一个 char 数组，下面的 lambda 表达式确定每个字母是否是大写字母，每当它发现一个大写字母，lambda 表达式给 Uppercase 加 1：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello World!&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">Uppercase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//modified by the lambda  </span>
</span><span class='line'>    <span class="n">for_each</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">Uppercase</span><span class="p">]</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">isupper</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
</span><span class='line'>            <span class="n">Uppercase</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Uppercase</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; uppercase letters in: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>匿名函数的威力当然不是只有这么一点，不过这不是本文的重点，关于匿名函数和闭包可以向会 javascript 的同学学习。</p>

<h2>Qt5</h2>

<h3>old signal &amp; slot</h3>

<p>Qt5 终于在末日前一天——12月20日正式发布了，信号槽有了新的用法。</p>

<p>在 Qt5 之前，信号槽连接要这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">valueChanged</span><span class="p">(</span><span class="n">QString</span><span class="p">,</span><span class="n">QString</span><span class="p">)),</span>
</span><span class='line'>             <span class="n">receiver</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">updateValue</span><span class="p">(</span><span class="n">QString</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>Qt 利用 SIGNAL 和 SLOT 这两个宏，把函数名转换成一个字符串。然后后，moc 将会扫描全部文件，将所有的 signal 和 slot 提取出来做成一个映射表。QObject::connect() 函数会从这个映射表里面找到该字符串，从 signal 的名字就可以找到 slot 的名字，就知道了在 signal emit 的时候，该去调用哪一个 slot 函数。</p>

<p>但是，由于信号槽都被处理成了字符串，所以编译期间是无法检查的，所有检查都是在运行时完成的。而且，由于是字符串，所以 slot 中的参数类型名必须与 signal 的完全一致。</p>

<h3>new signal &amp; slot</h3>

<p>在 Qt5 中我们有了更好的选择（原来的语法仍然支持）：使用函数指针</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span>
</span><span class='line'>        <span class="n">receiver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Receiver</span><span class="o">::</span><span class="n">updateValue</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来和之前的版本很类似，但新的用法有很多好处：</p>

<ul>
<li>编译期类型检查，以及 <code>Q_OBJECT</code> 宏检查</li>
<li>可以随意使用 typedef 和 namespace 了</li>
<li>支持参数类型的隐式转换，比如(QString 转换为 QVariant)</li>
<li>可以连接任何成员函数，不仅仅是槽函数</li>
</ul>


<p>坏处是，槽函数从此以后不能用默认参数了。(也没那么坏，是吧)</p>

<p>更有威力的是，connect 可以连接简单函数了，不仅仅是 QObject 对象的成员函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span> <span class="n">someFunction</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>看到这儿，就能想到最开始的 lambda 了吧，没错，<code>someFunction</code> 可以是个 function 也可以是一个 lambda 表达式，新的连接方式可以和 <code>tr1::bind(std::bind)</code> 以及 lambda 表达式完美的配合。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span>
</span><span class='line'>    <span class="n">tr1</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Receiver</span><span class="o">::</span><span class="n">updateValue</span><span class="p">,</span> <span class="s">&quot;senderValue&quot;</span><span class="p">,</span> <span class="n">tr1</span><span class="o">::</span><span class="n">placeholder</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">newValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">receiver</span><span class="o">-&gt;</span><span class="n">updateValue</span><span class="p">(</span><span class="s">&quot;senderValue&quot;</span><span class="p">,</span> <span class="n">newValue</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>唯一的坏处就是： <code>receiver</code> 在销毁的时候，无法自动断开连接</p>

<h3>异步操作变的更简单</h3>

<p>有了 C++11 的 lambda 表达式，与 STL 的算法一样，关于网络的一些异步操作同样变的非常简单了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">doYourStuff</span><span class="p">(</span><span class="k">const</span> <span class="n">QByteArray</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTcpSocket</span><span class="p">;</span>
</span><span class='line'>    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">connectToHost</span><span class="p">(</span><span class="s">&quot;qt.nokia.com&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
</span><span class='line'>    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QTcpSocket</span><span class="o">::</span><span class="n">connected</span><span class="p">,</span> <span class="p">[</span><span class="n">socket</span><span class="p">,</span> <span class="n">page</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">socket</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">QByteArray</span><span class="p">(</span><span class="s">&quot;GET &quot;</span> <span class="o">+</span> <span class="n">page</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">));</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QTcpSocket</span><span class="o">::</span><span class="n">readyRead</span><span class="p">,</span> <span class="p">[</span><span class="n">socket</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">qDebug</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&quot;GOT DATA &quot;</span><span class="o">&lt;&lt;</span> <span class="n">socket</span><span class="o">-&gt;</span><span class="n">readAll</span><span class="p">();</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是一个 <code>QDialog</code> 的例子，代码没有被割裂，也没有重入消息循环，看起来干净多了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">Doc</span><span class="o">::</span><span class="n">saveDocument</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">QFileDialog</span> <span class="o">*</span><span class="n">dlg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFileDialog</span><span class="p">();</span>
</span><span class='line'>    <span class="n">dlg</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">();</span>
</span><span class='line'>    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">dlg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QDialog</span><span class="o">::</span><span class="n">finished</span><span class="p">,</span> <span class="p">[</span><span class="n">dlg</span><span class="p">,</span> <span class="k">this</span><span class="p">](</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">QFile</span> <span class="n">file</span><span class="p">(</span><span class="n">dlg</span><span class="o">-&gt;</span><span class="n">selectedFiles</span><span class="p">().</span><span class="n">first</span><span class="p">());</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">dlg</span><span class="o">-&gt;</span><span class="n">deleteLater</span><span class="p">();</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然 C++ 不推崇函数式，但 lambda 的引入绝对是一大进步，据说 Java 8 也会引入 lambda，不过 Java 8 什么时候发布都还没谱呢……</p>

<h3>参考</h3>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11</a></li>
<li><a href="http://qt-project.org/wiki/New_Signal_Slot_Syntax">New Signal Slot Syntax Coming in Qt 5</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] why c++ is not back]]></title>
    <link href="http://bitdewy.github.com/blog/2012/12/16/why-c-plus-plus-is-not-back/"/>
    <updated>2012-12-16T17:42:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2012/12/16/why-c-plus-plus-is-not-back</id>
    <content type="html"><![CDATA[<p>前言：这个月初，<a href="http://herbsutter.com/">Herb Sutter</a> 发了一篇名为 <a href="http://simpleprogrammer.com/2012/12/01/why-c-is-not-back/">Perspective: “Why C++ Is Not ‘Back’”</a>，的文章，虽然 <a href="http://herbsutter.com/">Sutter</a> 不同意原文中的全部细节，但也推荐读一读原文和评论。语言之争，由来已久，每次一有这种文章就会引发激烈的讨论，比如<a href="http://coolshell.cn/articles/7992.html">这里</a>。</p>

<p>本译文中不会发表任何观点，尽量表达原作者的意图，如有翻译不当的地方欢迎大家积极指出，我会做出修改。</p>

<p>原文在这里： <a href="http://simpleprogrammer.com/2012/12/01/why-c-is-not-back/">Why C++ Is Not “Back”</a></p>

<p><strong>下面是译文：</strong></p>

<p>我喜爱 C++。</p>

<p>C++ 真正教会了我如何写代码。</p>

<p>以前，我会学习语言本身的复杂性，<a href="http://www.cplusplus.com/reference/stl/">STL</a>，以及内存管理和指针运算中的所有细节。</p>

<p>这些都是很美好的时光。我还记得一遍又一遍的读 <a href="http://www.aristeia.com/">Scott Meyers</a> 的 <a href="http://www.amazon.com/gp/product/B008E30L9A/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B008E30L9A&amp;linkCode=as2&amp;tag=makithecompsi-20">Effective C++</a> 系列。每一次都能从中学到一些新的东西，或者更理解如何使用 C++。</p>

<p>我说上面这些只是想让你知道，<strong>我不讨厌 C++</strong>。我喜欢 C++。</p>

<p>我知道，有很多优秀现在仍然在使用 C++ 并教别人如何使用，这一点也没有错。</p>

<p>但问题是什么？</p>

<!-- more -->


<h2>新消息是不正确的</h2>

<p><a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11</a> 发布了，最近大家对使用 C++ 开发又提起了兴趣。</p>

<p>不要误会我的意思，C++11非常棒！我100%的同意新标准中所做的一切。C++ 无疑已经变得更易用也更强大。</p>

<p>但有一件事，它并没有做到，这是最重要的——更简单。</p>

<p><strong>看来，许多经验丰富的开发人员已经忘记了当初为什么抛弃 C++ 而转到 Java，C# 以及其他的开发语言中。</strong></p>

<p>许多年轻的或者新入行的开发者不知道这些历史，被现在 C++ 的新消息和复兴所迷惑。</p>

<p>每个人都在问我，是否需要学习 C++，就像几年前一样，我现在的答案还是一样——<strong>不</strong>！</p>

<p>好吧，大写的 “不” 是有点苛刻。一个更好的答案是 “为什么？”</p>

<h2>你为什么想要学习 C++？</h2>

<p>我所能想到的今天去学习 C++ 的理由只有下面三个。</p>

<ul>
<li>你绝对的需要每一 bit 都发挥出最大的性能，并且想要用一个支持面向对象抽象的语言</li>
<li>你写的代码将跑在原生的硬件上。（比如：你正在写一个底层驱动程序）</li>
<li>当内存控制和时间绝对重要的时候，你需要系统有确定性的行为以及手动管理内存的能力。（想想实时嵌入式操作系统正在控制的一个移动的机械装置）</li>
</ul>


<p>虽然我可能少考虑了其他的情况，但是其他的情况基本上也无法逃出上面所说的三个范围。</p>

<p>等等，等等，可移植性呢？</p>

<p>不需要！<strong>不要想着学习 C++ 然后构建任何地方都能跑起来的软件。</strong> 今天我们还有大量的其他选择，而且 C++ 根本没有人们以为的那样有多好的可移植性。每个操作系统或者平台的底层抽象是非常不同的。</p>

<p>另外，请不要告诉我 C++正好可以给你你所需要的更多的权利和可控性。</p>

<p><strong>大多数软件开发是解决实际问题，管理复杂性，而不是在玩底层的细节。</strong>在几乎所有的现代大型软件开发中，我们需要的都是更高级的抽象，而不是低级别的抽象。</p>

<h2>但是，我就是想学 C++</h2>

<p>好了，听着，我知道你认为 Windows 8 非常酷，并且有很多人都在学习 C++ 来开发他们的 Windows 8 应用，但是在你喝 “Kool-Aid” 之前，你应该知道它里面有些什么。</p>

<p>写 C++ 代码不是去野餐。</p>

<p>即使 C++11 做了一些改变，C++ 仍然是一个非常难学习，也非常难掌握的语言。</p>

<p>你也许听说过下面这个关于 C++ 的说法：</p>

<blockquote><p>C makes it easy to shoot yourself in the foot. C++ makes it harder, but when you do, you blow away your whole leg!</p>

<p>— Bjarne Stroustrup</p></blockquote>

<p>你不知道 Bjarne 是谁？好吧，他是 C++ 之父。我想你能从他的话里面得到自己的结论。</p>

<p>我不断的听到 C++11 相对于 C++98 的改进，我一点也不怀疑。</p>

<p><strong>但它没有改进的是语言的规模大小——事实上反而增加了。</strong></p>

<p>当然，你可以使用 C++ 的一个子集。当然，你也可以使用新的<a href="http://en.wikipedia.org/wiki/Smart_pointer">智能指针</a>，把你从手工管理内存的情况中解救出来。你可以使用 <a href="http://msdn.microsoft.com/en-us/library/dd293608.aspx">lambda</a> 来避免使用函数指针。当然类型自动推导也是非常必要的新鲜空气。</p>

<p><strong>问题是，你仍然需要知道底层的东西，以了解当你调试一个有内存问题的 C++ 程序时，究竟问题在哪儿。</strong>（如果你生在脱管代码的时代，这些可能是你从来都没有听说过的东西。）</p>

<p>你也可能会遇到 20 年前的 C++ 代码，它看起来就像一个完全不同的语言。</p>

<p>下面是一个 C++ 开发人员的面试问题列表：</p>

<ol>
<li>C++ 中有多少种方式初始化一个基本类型数据，它们分别是什么？</li>
<li>为什么析构函数要声明为虚函数？</li>
<li>C++ 支持重载，是什么意思？</li>
<li>C++ 重载的例子有哪些？</li>
<li>什么是 name mangling，为什么要用它？</li>
<li>什么是抽象基类？</li>
<li>什么是 RTTI？</li>
<li>如何访问一个同名但是被”隐藏“的变量？</li>
<li>namespace 是什么，如何使用？</li>
<li>struct 与 class 有什么区别，与 C 比又有什么区别？</li>
<li>template 是什么，如何使用？</li>
<li>什么是拷贝构造函数，什么时候需要拷贝构造函数，与赋值操作符相比有哪些不同？</li>
<li>深拷贝和浅拷贝有什么不同？</li>
<li>const 的作用是什么，如何使用？</li>
<li>在 C++ 中，传值，传引用和传递指针的区别是什么？</li>
<li>什么时候应该返回一个值的引用，什么时候不应该返回一个值的引用？</li>
<li>在堆和栈上创建一个变量有什么不同？</li>
<li>如何释放一个数组动态分配的内存？只使用 delete 的含义是什么？</li>
<li>什么是多继承？ 什么时候使用多继成？</li>
<li>什么是纯虚函数？</li>
<li>关键字 mutable 是做什么的？</li>
<li>关键字 volatile 是做什么的？</li>
<li>STL 是什么？</li>
<li>什么是 vector ？</li>
<li>头文件 algorithms 中包含哪些内容？</li>
<li><code>#include&lt;iostream.h&gt;</code> 和 <code>#include&lt;iostream&gt;</code> 有什么区别？</li>
<li><code>++i</code> 和 <code>i++</code> 有什么区别？</li>
<li>什么是短路计算？怎样才能使用它？它为什么是危险的？</li>
<li>什么是逗号表达式？</li>
<li>唯一的三目运算符是什么？如何使用？</li>
<li>const 成员函数有什么作用？如何使用？</li>
<li>在 C++ 中使用 try/catch 好不好？</li>
<li>为什么不能在析构函数中抛异常？</li>
<li>关键字 explicit 是做什么的？</li>
<li>C++ 中类型转换的正确方式是什么？</li>
<li>内联函数是什么，都做了什么？</li>
</ol>


<p>上面一些问题，在 C# 或 Java 中，有相同的答案，但是你可以从这个问题列表看出来，C++ 水非常非常深。需要花费大量的精力来了解语言本身。</p>

<p>C# 或 Java 开发会有些关于语言本身的学习，但更多的是学习库的使用。</p>

<p>C++ 开发更多的是学习语言的每一个角落。</p>

<h2>C++ 不是未来的方向</h2>

<p>最大的问题，编程语言真正需要的是简单和增加它的抽象能力，而不是降低。</p>

<p>底层的代码总会有需求，但是今天大部分的代码都是更高层次的。</p>

<p>很多年前，当我无法再说 C++ 比 C# 开发效率更高的时候，我第一次跳下了 C++ 这条船。</p>

<p>我很长时间都试图相信曾经在 C++ 上耗费的精力时没有白费的，但是<strong>事实证明，C# 把事情简化到了伟大的程度，它有 C++ 一样的能力，却不需要额外的责任。</strong></p>

<p>当我想休息一下再写这篇博客的时候，我碰巧发现了微软研究院的一个叫做 <a href="https://www.touchdevelop.com/">touchdevelop</a> 的项目。这才是我们的方向。我们需要编程语言越来越简单，而不是越来越复杂。</p>

<p>不要误会我的意思，<a href="https://www.touchdevelop.com/">touchdevelop</a> 会有非常多的限制，但是我相信像这样的东西才是未来。</p>

<p>似乎微软正在努力推动让 C++ 回归主流，让 Windows 8 支持 C++ 开发，并试图干掉 XNA，但我觉得这是一个扭曲的看法，这似乎是 Windows 系统的开发人员根深蒂固的想法——开发人员想要使用 C++。</p>

<p>我只是不想看到自己再回到以前，在能使用 C# 在各个平台写代码的时候，还使用那么复杂的语言。C# 不是完美的语言，但是它非常优雅，简单。</p>

<h2>关于 C++ 的只言片语</h2>

<p>虽然我说了上面那些话，但我还是相信学习 C++ 是值得的。</p>

<p>不，我不是在自相矛盾，请允许我解释。</p>

<p>如果你能写 C++，那么你能用其他任何语言写代码。如果你了解堆、栈、内存，引用和指针以及让 C++ 如此复杂的其他底层细节，它会在你使用高级别抽象语言时给你帮助，让你能够明白计算机是如何工作的。</p>

<p><strong>这篇文章，我的观点不是抨击 C++，或抨击 C++ 使用者，和教别人 C++ 的人，只是说出我的观点，这貌似是热心的 C++ 社区所鼓励的。</strong></p>

<p>每个人都不会成为 C++ 开发人员，而且也不需要。也许 C++ 有能力让你的程序更高效（在某些情况下），它几乎绝对不可能让你开发过程更高效（除非极少数的极端情况下。）</p>

<p>我很高兴，C++ 有了很大的改进，但是我不认为它能很快的东山再起，而且这是一个好事情。</p>

<p><strong>译文完。</strong></p>

<h3>参考</h3>

<ul>
<li><a href="http://channel9.msdn.com/posts/C-and-Beyond-2011-Herb-Sutter-Why-C">Herb Sutter &ndash; Why C++?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CMake lua 5.2]]></title>
    <link href="http://bitdewy.github.com/blog/2012/12/15/cmake-lua5-dot-2/"/>
    <updated>2012-12-15T18:09:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2012/12/15/cmake-lua5-dot-2</id>
    <content type="html"><![CDATA[<p>不知道从什么时候开始，lua 源码不再提供 visual studio 工程文件了。windows 用户只能自己动手了，无奈 visual studio 版本太多，工程文件也不是人能读懂，简直不可维护。所以下面用 <a href="http://www.cmake.org/">CMake</a> 来生成 vcproj，这样维护起来更方便。</p>

<h2>什么是 CMake？</h2>

<p><a href="http://www.cmake.org/">CMake</a> 是个开源的跨平台自动化建构系统，它用组态档控制建构过程（build process）的方式和 Unix 的 Make 相似，只是 <a href="http://www.cmake.org/">CMake</a> 的组态档取名为 CMakeLists.txt。<a href="http://www.cmake.org/">CMake</a> 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 <a href="http://www.cmake.org/">CMake</a> 和 SCons 等其他类似系统的区别之处。</p>

<p>有了 <a href="http://www.cmake.org/">CMake</a> 就不用在 vcproj 的各个版本之前来回的切换了，每次用 <a href="http://www.cmake.org/">CMake</a> 生成相应的工程文件就一切 OK 了。</p>

<h2>Windows 下用 CMake 安装 lua 5.2.1</h2>

<h3>安装 CMake</h3>

<p>从<a href="http://cmake.org/cmake/resources/software.html">官方下载</a>相应的安装包，安装完成后，别忘了把 <a href="http://www.cmake.org/">CMake</a> 加入 <code>PATH</code> 中。</p>

<h3>使用 CMake 生成 vcproj</h3>

<p>lua官方不提供带 CMake 的源码，会的朋友可以手工写几个 CMakeList.txt 就 OK，不会的直接下载 bitdewy 写好的 <a href="http://sdrv.ms/TTp5Y6">cmake-lua-5.2.1.tar.gz</a> 吧。解压后用 visual studio 的命令行进入 <code>lua-5.2.1/build</code> 目录，然后输入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>cmake -DCMAKE_INSTALL_PREFIX<span class="o">=</span><span class="s2">&quot;C:\lua52&quot;</span> ..
</span></code></pre></td></tr></table></div></figure>


<p>完成之后就可以打开 build 目录下的 lua.sln 文件直接编译了，编译 INSTALL 工程，会在上面设置的 <code>C:\lua52</code> 目录中安装 lua，luac，静态链接库，动态链接库，头文件、源代码以及文档，如果不想安装，不编译 INSTALL 工程就好。如果不设置安装目录，那么 windows 下默认的安装目录就是 <code>%ProgramFiles%</code> 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[COM、ABI与引用计数]]></title>
    <link href="http://bitdewy.github.com/blog/2012/12/09/com-and-reference-counting/"/>
    <updated>2012-12-09T18:18:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2012/12/09/com-and-reference-counting</id>
    <content type="html"><![CDATA[<h2>什么是 COM ？</h2>

<p>Component Object Model (COM) 组件对象模型，是微软 1993 年引入的软件组件的二进制接口标准。它可以让多种编程语言之间可以相互通信，动态的创建对象。详细内容请看 <a href="http://en.wikipedia.org/wiki/Component_Object_Model">Component Object Model</a>。</p>

<h2>什么是 ABI ？</h2>

<p>Application Binary Interface (ABI) 应用二进制接口，描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低层接口。</p>

<p>ABI涵盖了各种细节，例如：</p>

<ul>
<li>数据类型、大小以及内存布局</li>
<li>调用约定（控制着函数的参数如何传送以及如何接受返回值）</li>
<li>系统调用的编码和一个应用如何向操作系统进行系统调用</li>
<li>在一个完整的操作系统ABI中，目标文件、程序库的二进制格式等等。</li>
</ul>


<p>一个完整的ABI，像Intel二进制兼容标准(<a href="http://www.everything2.com/index.pl?node=iBCS">iBCS</a>)，允许支持它的操作系统上的程序不经修改在其他支持此ABI的操作体统上运行。</p>

<p>其他的ABI标准化细节包括<a href="http://en.wikipedia.org/wiki/Name_mangling#Name_mangling_in_C.2B.2B">C++ name mangling</a>、异常传播，同一个平台上的编译器之间的调用约定，但是不包括跨平台的兼容性。详细内容请看 <a href="http://en.wikipedia.org/wiki/Application_binary_interface">Application binary interface</a></p>

<!-- more -->


<h2>什么是引用计数？</h2>

<p>引用计数是一种资源管理的方式，经常和垃圾回收在一起讨论，引用计数策略和<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">垃圾回收</a>策略都属于资源的自动化管理 ，在引用计数中，每一个对象负责维护对象所有引用的计数值。当一个新的引用指向对象时，引用计数器就递增，当去掉一个引用时，引用计数就递减。当引用计数到零时，该对象就将释放占有的资源。COM 是使用引用计数的典型例子之一。详细内容请看 <a href="http://en.wikipedia.org/wiki/Reference_counting#COM">Reference counting</a></p>

<h2>为毛 COM 中的接口都没有虚析构函数？</h2>

<p>这是个违反直觉的设计：</p>

<ol>
<li>《Effective C++》 第三版，item 7：为多态基类声明 virtual 析构函数</li>
<li>《C++ Coding Standards &mdash; 101 Rules, Guidelines, and Best Practices》第 50 条，将基类析构函数设为公用且虚拟的，或者保护且非虚拟的</li>
</ol>


<p>学过 C++ 的人应该都知道，基类的析构函数需要声明为 virtual 或者禁止直接调用基类的析构函数，否则使用派生类初始化基类指针，当调用 delete 释放时，由于基类的析构函数不是虚函数，那么派生类的析构函数将不会被调用，造成对象的切割，派生类特有的部分将不会得到释放，造成内存或资源的泄漏。</p>

<p>COM 的核心在于：接口，它解决了二进制级复用的两个主要问题：</p>

<ol>
<li>不同的编译器对具体技术的不同实现问题和<a href="http://en.wikipedia.org/wiki/Name_mangling">name mangling</a>问题。首先，客户程序源代码中仅仅需要引入接口定义，而不同的编译器对同一接口的VTBL的结构安排是一样的，所有的组件功能的调用都通过同样的VTBL来中转。其次，由于用户通过接口来调用组件的功能，而不需要其它导出函数，所以没有<a href="http://en.wikipedia.org/wiki/Name_mangling">name mangling</a>的问题了。</li>
<li>组件仅仅导出接口，而不是导出类，避免了因组件中的类的大小发生变化(破坏了二进制兼容性)而客户程序不重新编译而继续运行时产生运行错误的问题。</li>
</ol>


<p>不同的编译器对一个接口的vptr和vtbl是一致的，但纯虚析构函数不满足，因为不同的编译器对纯虚析构函数指针在vtbl中安放的位置是不一样的，因此 COM 要实现二进制级的复用，就不能有虚析构函数。COM 使用这种方式实现了 ABI，满足了二进制兼容的问题。</p>

<p>但为了实现二进制兼容，COM 没有办法原地更新而不影响现有代码，只能每次发布新版本都引入新的 interface class，然后就有了一堆带版本号的 interface：</p>

<ul>
<li>IDocHostUIHandler，IDocHostUIHandler2</li>
<li>IDirect3D7, IDirect3D8, IDirect3D9</li>
<li>IXMLDOMDocument, IXMLDOMDocument2, IXMLDOMDocument3</li>
</ul>


<p>对于追求代码好看的人来说，这很难接受，<strong>实在是太难看了</strong>。不过这的确解决了二进制兼容的问题。</p>

<h2>为毛 COM 需要使用引用计数？</h2>

<p>首先 windows 跨 dll 释放内存会存在严重问题，因此资源的申请以及释放都要在组建内部完成。 其次，COM 组件的生命周期不能由客户来管理，因为用户可以得到指向同一个实体的多个接口型的指针，这样对多个指针执行 delete 操作，将会导致运行时错误，并且用户必须记住哪个指针对应哪个对象，并保证对每个对象仅仅调用一次 delete 操作。为了解决这个问题，COM 将这种操作从用户移到组件内部，使用了引用计数机制，同时保证了二进制兼容性。</p>

<p>COM 使用引用计数的最主要动机是在不同的语言和运行时系统中都能正常使用，用户只使用相应的接口(addRef, Release)来管理对象的生命周期，而不必知道 COM 对象的内存分配细节到底如何实现。</p>

<p>为了实现跨语言，COM 将大量的工作都放到了组件内部来做，例如指针在继承链中转换时，会使用 RTTI，但是 RTTI 是与编译器相关的，所以这种转换的动作只能放到 COM 内部，导出一个 QueryInterface 函数来执行这种转换并返回适当的指针。</p>

<p>但 COM 的引用计数代价不小，使用 COM 时最容易出现的 bug 就是引用计数不正确。而引用计数的不正确有可能是在某个不透明的第三方组件中。因此， 保证引用计数的正确性不是个容易的问题。</p>

<p>在 .Net 中，微软抛弃了<a href="http://en.wikipedia.org/wiki/Reference_counting">引用计数</a>，而引入了[垃圾回收][GC]。</p>

<h4>参考</h4>

<ul>
<li>陈硕：<a href="http://www.cnblogs.com/Solstice/archive/2011/03/09/1978024.html">C++ 工程实践(4)：二进制兼容性</a></li>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Component_Object_Model">Component Object Model</a></li>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Application_binary_interface">Application binary interface</a></li>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Reference_counting">Reference counting</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 配置 Qt 开发环境手记]]></title>
    <link href="http://bitdewy.github.com/blog/2012/12/09/qt-xcode-hello/"/>
    <updated>2012-12-09T13:10:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2012/12/09/qt-xcode-hello</id>
    <content type="html"><![CDATA[<p>首先，这是一个奇葩的需求，不要问为什么不用 Qt Creator，为什么不用 qmake + make，没有那么多为什么。</p>

<p>其次，准备好 Xcode 先。正文开始：</p>

<h2>安装Qt library</h2>

<p>Qt5 已经发布 RC1 版本，不过还没到不影响正常使用的程度，所以还是先用 4.8.4，下载链接点<a href="http://qt-project.org/downloads">这里</a>，MAC 版的 release 和 debug 库是分开的，可以自由选择。一路安装，下一步就 OK。</p>

<!-- more -->


<h2>生成 xcodeproj</h2>

<p>生成 xcodeproj 文件(夹)，(它是文件还是文件夹？)，先创建目录，然后进入，使用 <code>qmake -project</code> 生成 pro 文件，如果找不到 <code>qmake</code>，那就需要手工找，或者重新安装 Qt library 了，生成 pro 文件之后，就可以用 <code>qmake -spec macx-xcode</code> 生成 xcodeproj 了，然后，就没有然后了，直接用 Xcode 打开就 OK。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>localhost:~ bitdewy<span class="nv">$ </span>mkdir Projects/qt_xcode_hello  <span class="c">#建个文件夹先</span>
</span><span class='line'>localhost:~ bitdewy<span class="nv">$ </span><span class="nb">cd </span>Projects/qt_xcode_hello/    <span class="c">#进入新建的文件夹</span>
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>qmake -project    <span class="c">#生成pro文件 </span>
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>ls                <span class="c">#看看生成了啥玩意儿</span>
</span><span class='line'>qt_xcode_hello.pro
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>qmake -spec macx-xcode  <span class="c">#生成xcodeproj</span>
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>ls                      <span class="c">#再看看</span>
</span><span class='line'>qt_xcode_hello.pro        qt_xcode_hello.xcodeproj
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>open qt_xcode_hello.xcodeproj/  <span class="c">#用 Xcode 打开</span>
</span></code></pre></td></tr></table></div></figure>


<h2>配置 Xcode 工程</h2>

<p>打开个空工程，自然是毛也没有，首先工程中新建个文件，然后新建 target 选 other &ndash;> External Build System ，Product Name 就叫 qmake，Build Tool 指定到 qmake 的路径，Finish 之后，删除 Arguments 中的 <code>$(ACTION)</code>。Command + D，Duplicate 出来个 qmake copy，改名 <code>qmake -project</code>，Arguments 填上 <code>-project</code>，先run <code>qmake -project</code>，再run <code>qmake</code>，xcode 工程就和谐了，现在可以写代码跑了。</p>

<p>明白人一看就知道上面是在干什么了，新建文件，然后 <code>qmake -project</code> 更新pro文件，再 <code>qmake</code> 生成 makefile。整个过程实际上就三行 shell 搞定。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>touch qt_xcode_hello.cpp
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>qmake -project
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>qmake
</span></code></pre></td></tr></table></div></figure>


<h2>为毛不直接生成能用的 Xcode 工程</h2>

<p>更明白的人可能要说脏话了，你妹的搞这么麻烦，生成 xcodeproj 之前补上一句 <code>touch qt_xcode_hello.cpp</code> 不就不用配置 XCode 工程了么？ bitdewy 也不是二货，为毛要配置 Xcode 工程？ 因为 Qt 的 Meta Object Compile，用到 signal 和 slot 的时候，都需要 qmake 生成 moc 文件，所以先配置一下没什么坏处这样。</p>

<h4>参考</h4>

<ol>
<li><a href="http://qtnode.net/wiki/Qt4_with_Xcode">Qt4 with Xcode</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello All]]></title>
    <link href="http://bitdewy.github.com/blog/2012/11/25/hello-world/"/>
    <updated>2012-11-25T22:18:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2012/11/25/hello-world</id>
    <content type="html"><![CDATA[<p>Hello world, new github blog;</p>

<h1>一级标题</h1>

<h2>二级标题</h2>

<h3>三级标题</h3>

<h4>四级标题</h4>

<h5>五级标题</h5>

<h6>六级标题</h6>

<blockquote><p>这是一个引用</p>

<blockquote><p>引用中的引用</p></blockquote></blockquote>

<p><a href="http://bitdewy.github.com">这是一个超链接</a></p>

<p>下面是一个list：</p>

<ul>
<li>第一条</li>
<li>第二条</li>
<li>第三条</li>
</ul>


<p><em>斜体</em>、<em>还是斜体</em>、<strong><em>粗+斜</em></strong>、<strong>粗体</strong></p>

<p>后面是代码-> <code>something.excute();</code> &lt;&ndash; 前面是代码</p>

<p>下面是一段代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># Fibonacci series:</span>
</span><span class='line'><span class="c"># the sum of two elements defines the next</span>
</span><span class='line'><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'><span class="k">while</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后来一张八爪萌猫大图：</p>

<!-- more -->


<p><img src="http://octodex.github.com/images/snowoctocat.jpg" alt="" /></p>

<p>全文完整代 markdown 代码如下：</p>

<pre><code>Hello world, new github blog;

#一级标题
##二级标题
###三级标题
####四级标题
#####五级标题
######六级标题

&gt; 这是一个引用
&gt;&gt; 引用中的引用

[这是一个超链接](http://bitdewy.github.com)

下面是一个list：

- 第一条
- 第二条
- 第三条

_斜体_、*还是斜体*、***粗+斜***、**粗体**

后面是代码-&gt; `something.excute();` &lt;- 前面是代码

下面是一段代码：

``` python
# Fibonacci series:
# the sum of two elements defines the next
a, b = 0, 1
while b &lt; 10:
    print b
    a, b = b, a+b
```

最后来一张八爪萌猫大图：

&lt;!-- more --&gt;
![](http://octodex.github.com/images/snowoctocat.jpg)
</code></pre>
]]></content>
  </entry>
  
</feed>
