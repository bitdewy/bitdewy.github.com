<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bitdewy]]></title>
  <link href="http://bitdewy.github.io/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.io/"/>
  <updated>2013-05-12T23:39:09+08:00</updated>
  <id>http://bitdewy.github.io/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译] GotW #1 Solution: Variable Initialization – or Is It?]]></title>
    <link href="http://bitdewy.github.io/blog/2013/05/12/gotw1/"/>
    <updated>2013-05-12T02:55:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2013/05/12/gotw1</id>
    <content type="html"><![CDATA[<p>原文在这里 <a href="http://herbsutter.com/2013/05/09/gotw-1-solution/">GotW #1 Solution: Variable Initialization – or Is It?</a></p>

<p><em>第一个问题是用来强调理解你写的代码的含义的重要性. 下面是几行简单的代码 &ndash; 大部分都与其他的有一些区别, 即使只是语法略有变化.</em></p>

<h2>JG 问题</h2>

<p>1. 下面的代码有什么不同?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// (a)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">();</span>                 <span class="c1">// (b)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{};</span>                 <span class="c1">// (c)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                <span class="c1">// (d)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>                <span class="c1">// (e)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>               <span class="c1">// (f)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span>             <span class="c1">// (g)</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                 <span class="c1">// (h)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">widget</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>         <span class="c1">// (i)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Guru 问题</h2>

<p>2. 下面的每一行代码做了什么?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">);</span>   <span class="c1">// (a)</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>   <span class="c1">// (b)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3. 除了上面的情况以外, 使用 <code>{ }</code> 初始化对象还有什么其他的好处?</p>

<p>4. 什么时候使用 <code>( )</code> 以及 <code>{ }</code> 来初始化对象? 为什么?</p>

<!-- more -->


<h2>解决方案</h2>

<p>这几个问题展示了几件事:</p>

<ul>
<li>默认初始化, 显式初始化, 拷贝初始化, 以及初始化列表之间的区别.</li>
<li>初始化时 <code>( )</code> 与 <code>{ }</code> 之间的差异.</li>
<li>在现代 C++ 中要避免的, 看起来像初始化, 但完全和初始化无关的东西</li>
</ul>


<p>不过, 最重要的是: 如果你坚持问题 #4 中的两个简单的指导的话, 就可以忽略这些情况, 规则相当的简单, 而且默认情况下可以获得高效的性能.</p>

<h3>1. 下面的代码有什么不同?</h3>

<p>让我们一条一条的来看.</p>

<p><strong>情况 (a) 是默认初始化</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// (a)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这一行代码声明了一个 <code>widget</code> 类型的变量 <code>w</code>, 假定 <code>widget</code> 是一个 <code>class</code> 类型, 它会使用默认构造函数 <code>widget::widget()</code> 来初始化.</p>

<p><strong>情况 (b) 是一个 &ldquo;恼人&rdquo; 的无关转移, 是历史遗留问题</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">();</span>                 <span class="c1">// (b)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是 C++ 的一个陷阱: 第一眼看上去, 它看上去像另一个调用默认构造函数 <code>widget::widget()</code> 的变量声明. 事实上, 感谢语法二义性, 这是一个函数声明. 一个名为 <code>w</code>, 无参, 返回值是 <code>widget</code> 类型的函数声明. (如果你无法一眼看出的话, 考虑下上面的代码其实与 <code>int f()</code> 没有任何的差别, 而这个函数声明是显而易见的对吧.)</p>

<p>避免你认为 &ldquo;吖, 但是那些 <code>()</code> 是多于的, 这是程序员自己的错误, 因为他们没有直接写 <code>widget w;</code>&rdquo;, 注意, 这个的问题也会出现在你以为你正在使用临时对象初始化变量的时候:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// same problem (gadget and doodad are types)</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span> <span class="n">gadget</span><span class="p">(),</span> <span class="n">doodad</span><span class="p">()</span> <span class="p">);</span>  <span class="c1">// pitfall: not a variable declaration</span>
</span></code></pre></td></tr></table></div></figure>


<p>Scott Meyers 很多年前就称这个是 &ldquo;C++ 中最恼人的语法解析&rdquo;, 因为标准中解决语法二义性是这么说的: &ldquo;如果能够被解析为函数声明, 那么它就是一个函数声明.&rdquo;</p>

<p>好消息是, 这个问题将要成为历史, 在新的代码中你将不会遇到它, 因为 C++11 移除了这个陷阱. 注意 C++11 并没有修改语义 &ndash; C++11 的向后兼容 C++98 做的非常好, 包括这个语法二义性, 仍然是它原有的含义. 但是, C++11 通过提供新的语法取代情况 (b), 因此我们再也不会掉到这个陷阱中了.</p>

<p><strong>情况 (c) 干净明确</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{};</span>                 <span class="c1">// (c)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这儿我们有了第一个使用 <code>{ }</code> 而不使用 <code>()</code> 的理由: 对于任意的 class 类型 <code>widget</code>, 情况 (c) 做的事情像 (a) 一样的明确 &ndash; 无二义性, 干净, 明确.</p>

<p>&ldquo;哈哈, 但是等等, 它可没有那么简单!&rdquo; 有些人可能会反对. &ldquo;如果 <code>widget</code> 有一个接受 <code>std::initializer_list</code> 的构造函数那会怎么样呢? 他们都是被优先选择的, 所以, 如果 <code>widget</code> 有这么一个构造函数, 这个写法不会调用它吗?&rdquo;</p>

<p>答案是不会, 这个真的像你看到的一样简单, 因为标准中明确了, 如果可以的话, 空的 <code>{ }</code> 列表意味着调用默认构造函数. 不过, 能意识到 <code>initializer_list</code> 是好的, 让我们在后面再讨论它.</p>

<p><strong>情况 (d) 和 情况 (e) 是直接初始化</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                <span class="c1">// (d)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>                <span class="c1">// (e)</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设 <code>x</code> 不是一个类型名, 这两个都是直接初始化. 因为变量 <code>w</code> 是由 <code>x</code> 直接调用 <code>widget::widget(x)</code> 初始化的. 如果 <code>x</code> 也是 <code>widget</code> 类型, 它会调用拷贝构造函数. 否则的话, 调用一个转换构造函数.</p>

<p>但是, 注意 <code>{x}</code>, 它会创建一个 <code>initializer_list</code>. 如果 <code>widget</code> 有接受 <code>initializer_list</code> 的构造函数的话, 这个构造函数是被优先选择的; 否则, 如果 <code>widget</code> 有接受任意 <code>x</code> 的类型的构造函数的话(包括类型转换), 这个构造函数将会被调用.</p>

<p>情况 (e) 有两个优于 (d) 的地方: 一, 与 (c) 一样, (e) 是明确, 无二义性的. 如果 <code>x</code> 是一个类型名, 那么 (d) 就是一个函数声明, 即使在作用域内有一个名为 <code>x</code> 的变量 (看下文), 而 (e) 不可能是一个函数声明.</p>

<p>第二: (e) 更安全, 因为它不允许有损转换, 一些内建类型是允许的. 考虑下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">i1</span><span class="p">(</span> <span class="mf">12.345</span> <span class="p">);</span>           <span class="c1">// ok: loss .345, we didn&#39;t like it anyway</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i2</span><span class="p">{</span> <span class="mf">12.345</span> <span class="p">};</span>           <span class="c1">// error: would be lossy implicit narrowing</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>情况 (f) 与 (g) 是拷贝初始化和拷贝类表初始化</strong></p>

<p>这是最后两个 non-auto 的情况:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>               <span class="c1">// (f)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是所谓的拷贝初始化. <em>从概念上来讲</em>, 变量 <code>w</code> 是由 <code>widget</code> 的转移构造函数或者拷贝构造函数初始化的. 有可能是在调用一个隐式转换函数之后(显式转换不会调用).</p>

<blockquote><p><strong>通常的错误:</strong> 这个绝对是初始化; 绝不是赋值, 所以绝对不会调用 <code>T::operator=()</code>. 是的, 我知道这有一个<code>=</code>赋值符号, 但是不要让这个符号影响到你 &ndash; 这仅仅是从 C 继承而来的符号, 不是赋值操作符.</p></blockquote>

<p>下面是语义:</p>

<ul>
<li>如果 <code>x</code> 的类型是 <code>widget</code>, (f) 与 (d) <code>widget w(x);</code> 的含义完全一致, 除非明确的构造函数不能使用. 他保证了只有一个构造函数被调用.</li>
<li>如果 <code>x</code> 是其他类型, <em>从概念上来讲</em>编译器首先将 <code>x</code> 隐式转换为 <code>widget</code> 类型的临时对象, 然后对临时右值使用转移构造函数, 如果没有好的转移构造函数, 那么会使用拷贝构造函数 &ndash; &ldquo;低效的转移&#8221;作为备选. 假设存在可用的隐式转换, (f) 就与 <code>widget w(widget(x))</code> 一致了.</li>
</ul>


<p>注意, 上面说了几次<em>从概念上来讲</em>. 这是因为通常编译器都会做优化, 优化掉临时变量, 如果存在隐式转换, 从 (f) 转换为 (d), 那么就优化掉了额外的转移操作. 但是, 尽管编译器这么做了, <code>widget</code> 的拷贝构造函数也必须是可访问的, 即使没有调用 &ndash; 拷贝构造函数的副作用可能发生也可能不发生, 就这些.</p>

<p>现在来注意一下增加的符号 <code>=</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span>             <span class="c1">// (g)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个是所谓的拷贝列表初始化. 它与 <code>widget w{x};</code> 的含义一致 除非显示的构造函数无法使用. 它保证了只有咦个的构造函数被调用.</p>

<p><strong>情况 (h) 和 (i) 也是拷贝初始化, 但是更简单</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                 <span class="c1">// (h)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">widget</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>         <span class="c1">// (i)</span>
</span></code></pre></td></tr></table></div></figure>


<p>语义与 (f) 和 (g) 一样, 但是学习起来更简单, 因为使用了 <code>auto</code> 保证了右侧表达式类型推导的准确性. 需要注意的是 (i) 在隐式转换与显式转换的情况下都能正常工作.</p>

<p>(h) 与 (d) 的含义一致, <code>type_of_x w(x);</code>. 只有一个拷贝构造函数被调用. 它可以保证类型发生变化时, 程序还总是正确的: 因为 (h) 没有明确特性的类型, 它有两个有效的保证, 因为这不会存在类型的转换, 以及更好的维护性, 因为当程序中 <code>x</code> 的类型变更时, &lsquo;w&rsquo; 会自动变更类型与 <code>x</code> 保持一致.</p>

<p>当你想要明确类型或者需要显式的类型转换时, (i) 是最风格一致的, 而且一旦使用了 <code>{ }</code> 就可以避免有损的类型转换了. 大部分的编译器实现, 只会有一个构造函数调用 &ndash; 和我们看到的 (f) 与 (g) 相似, 概念上来讲会有两个构造函数调用, 一个转换构造函数或者拷贝构造函数用来创建临时的 <code>widget{x}</code> 然后紧接着一个转移构造函数来构造 <code>w</code>, 但是编译器会把后一个优化掉.</p>

<p>通常情况下, 我推荐你尝试这两种用法, 并倾向于使用它来伴随你舒服的成长. 现在几乎所有我写的局部变量声明都采用这种方式. (我知道会有一些人怀疑这种方式 &ndash; 更多的关于关键字 <code>auto</code> 的问题在其他的 GotW 中讨论.)</p>

<h3>2. 下面的每一行代码做了什么?</h3>

<p>在第二个问题的代码中, 我们创建了一个 <code>vector&lt;int&gt;</code> 并将参数 <code>10</code> 和 <code>20</code> 传给它的构造函数 &ndash; 第一种情况是 <code>(10, 20)</code>, 第二种情况是 <code>{10, 20}</code>.</p>

<p>两个都会调用构造函数, 但是会调用哪个呢? 嗯, <code>vector&lt;int&gt;</code> 有很多接受两个参数的构造函数, 但是只有下面两个能够正确的接受参数 <code>10</code> 和 <code>20</code>. 为了简单, 忽略掉默认的分配器参数, 两个构造函数应该是下面的样子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="p">(</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">);</span>    <span class="c1">// A: n copies of value</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="p">(</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span> <span class="p">);</span>  <span class="c1">// B: copy of values</span>
</span></code></pre></td></tr></table></div></figure>


<p>有两个简单的规则可以帮助我们确定哪个函数将被调用:</p>

<ul>
<li>在表达式的上下文中使用 <code>{ }</code> 你会得到一个 <code>initializer_list</code>.</li>
<li>接受 <code>initializer_list</code> 参数的构造函数会优于其他构造函数被选择, 同时会隐藏其他构造函数, 否则可能是可行的.</li>
</ul>


<p>有了这两条, 答案就很简单了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">);</span>    <span class="c1">// (a) calls A: 10 copies of the value 20</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span> <span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>    <span class="c1">// (b) calls B: the values 10 and 20</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. 除了上面的情况以外, 使用 <code>{ }</code> 初始化对象还有什么其他的好处?</h3>

<p>首先, 这叫做统一初始化, 因为它统一 &ndash; 所有的类型, 包括 <code>structs</code>, 数组, 标准库容器, 而且也不存在恼人的语法解析问题.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">mystruct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// C++98 </span>
</span><span class='line'><span class="n">rectangle</span>       <span class="n">w</span><span class="p">(</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">);</span>       <span class="c1">// oops, vexing parse </span>
</span><span class='line'><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">(</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">);</span>
</span><span class='line'><span class="n">mystruct</span>        <span class="n">m</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span>             <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>     <span class="n">v</span><span class="p">;</span>                              <span class="c1">// urk, need more code</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">//   to initialize this</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// C++11 (note: &quot;=&quot; is optional)</span>
</span><span class='line'><span class="n">rectangle</span>       <span class="n">w</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">};</span>
</span><span class='line'><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span>   <span class="o">=</span> <span class="p">{</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">};</span>
</span><span class='line'><span class="n">mystruct</span>        <span class="n">m</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span>             <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>     <span class="n">v</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意, 这不仅仅是个审美的问题. 考虑编写通用的能够初始化任何类型的代码&hellip; 我们正在做的, 让我们使用完美转发做为例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">forwarder</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">local</span> <span class="o">=</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">};</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>            <span class="p">(</span> <span class="mi">42</span> <span class="p">);</span>                  <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">rectangle</span><span class="o">&gt;</span>      <span class="p">(</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">);</span>    <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">mystruct</span><span class="o">&gt;</span>       <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>                <span class="c1">// ok because of {}</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span>          <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>          <span class="c1">// ok because of {}</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span>    <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>          <span class="c1">// ok because of {}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果 <code>forwarder</code> 内部使用了 <code>( )</code> 做初始化符号的话, 那么最后三条是不合法的.</p>

<p>新的符号 <code>{ }</code> 在任何地方都能完美的工作, 包括类成员的初始化:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span><span class="o">::</span><span class="n">widget</span><span class="p">(</span> <span class="cm">/*...*/</span> <span class="p">)</span> <span class="o">:</span> <span class="n">mem1</span><span class="p">{</span><span class="n">init1</span><span class="p">},</span> <span class="n">mem2</span><span class="p">{</span><span class="n">init2</span><span class="p">,</span> <span class="n">init3</span><span class="p">}</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外, 它还能简单清晰的表达传递函数参数, 返回值, 而不需要一个具名的临时对象:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">draw_rect</span><span class="p">(</span> <span class="n">rectangle</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">draw_rect</span><span class="p">(</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">)</span> <span class="p">);</span>         <span class="c1">// C++98</span>
</span><span class='line'><span class="n">draw_rect</span><span class="p">({</span> <span class="n">origin</span><span class="p">,</span> <span class="n">selection</span> <span class="p">});</span>                  <span class="c1">// C++11</span>
</span><span class='line'>
</span><span class='line'><span class="n">rectangle</span> <span class="n">compute_rect</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>   <span class="c1">// ...</span>
</span><span class='line'>   <span class="k">if</span><span class="p">(</span><span class="n">cpp98</span><span class="p">)</span> <span class="k">return</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">);</span>  <span class="c1">// C++98</span>
</span><span class='line'>   <span class="k">else</span>      <span class="k">return</span> <span class="p">{</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">};</span>           <span class="c1">// C++11</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. 什么时候使用 <code>( )</code> 以及 <code>{ }</code> 来初始化对象? 为什么?</h3>

<p>下面是简单的指导:</p>

<blockquote><p><strong>准则:</strong> 尽量在初始化时使用 <code>{ }</code>, 比如 <code>vector&lt;int&gt; v = { 1, 2, 3, 4 };</code> 或者 <code>auto v = vector&lt;int&gt;{ 1, 2, 3, 4 };</code>, 因为它有更好的一致性, 更正确, 可以避免去了解过去的陷阱. 在单参数的情况下你可能会仅仅看到一个赋值符号 <code>=</code>, 就像 <code>int i = 42;</code> 一样, 这种情况下, 省略括号是好的&hellip;</p></blockquote>

<p>上面的准则可以覆盖绝大部分情况, 但是也有一个例外:</p>

<blockquote><p>&hellip; 在极端情况下, 比如 <code>vector&lt;int&gt; v(10,20);</code> 或者 <code>auto v = vector&lt;int&gt;(10,20);</code> 时, 使用 <code>( )</code> 明确的调用会被 <code>initializer_list</code> 构造函数隐藏的构造函数.</p></blockquote>

<p>但是, 这个仅仅是在极端情况下, 因为默认构造函数以及拷贝构造函数已经很特别, 并且能与括号 <code>{ }</code> 很好的工作, 现在一个好的类的设计会避免用到 <code>()</code> 来提供用户定义的构造函数, 因为下面的设计准则:</p>

<blockquote><p><strong>准则</strong>: 当你设计一个类时, 避免提供一个与 <code>initializer_list</code> 构造函数会产生二义性的构造函数, 这样用户就不需要使用 <code>()</code> 来访问会被隐藏掉的构造函数.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用静态多态辅助动态多态]]></title>
    <link href="http://bitdewy.github.io/blog/2013/04/09/staitc-and-dynamic-polymorphism/"/>
    <updated>2013-04-09T23:13:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2013/04/09/staitc-and-dynamic-polymorphism</id>
    <content type="html"><![CDATA[<h2>静态多态 (编译期多态) 与动态多态 (运行期多态)</h2>

<p>关键字: 重载/模版和虚函数</p>

<p>类型: 编译期多态 (静态多态, 早绑定) 和运行期多态 (晚绑定)
编译期多态 (重载/模版), 运行期多态 (虚函数)</p>

<p>应用形式上:
静多态是发散式的, 让相同的实现代码应用于不同的场合.
动多态是收敛式的, 让不同的实现代码应用于相同的场合.</p>

<p>思维方式上:
静多态是泛型式编程风格, 它看重的是算法的普适性.
动多态是对象式编程风格, 它看重的是接口和实现的分离度.</p>

<h2>std::shared_ptr 中的 deleter 是如何工作的?</h2>

<p>标准库中的引用计数智能指针 shared_ptr 很有趣——你可以向其构造器传递一个函数或者仿函数 (function object, 或 functor), 当引用计数归零的时候, 它将在被引用对象上调用删除器 (deleter). 乍一看, 似乎没啥了不起啊, 但请看代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">shared_ptr</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">explicit</span> <span class="n">shared_ptr</span><span class="p">(</span><span class="n">U</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">D</span> <span class="n">deleter</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>注意 <code>shared_ptr&lt;T&gt;</code> 必然在析构时调用类型为 D 的删除器, 然而它根本不知道 D 为何物. 这个对象不能包含类型为 D 的数据成员, 也不能指向类型为 D 的对象, 因为声明其数据成员时, D 对它而言还是未知的. 那么, shared_ptr 对象如何跟踪删除器 (它在构造阶段传入: 当 T 对象将被销毁时, 还得使用它) 呢? 更通俗地说, 构造器如何将未知类型的信息传递给它正在构造的对象, 而这个对象本身对信息类型完全无知? 答案很简单: 让此对象包含一个指向已知类型基类的指针 (标准库中叫它 sp_counted_base), 然后让构造器以 D 为参数实例化一个派生于上述基类的模板 (标准库中叫 sp_counted_impl_p 和 sp_counted_impl_pd), 最后用声明于基类, 实现于派生类的虚函数 (标准库中使用 dispose) 去调用删除器. 关于这个问题, Scott Meyers 在 06 年 9 月份的一篇文章中已经有阐述, 详见: <a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">My Most Important C++ Aha! Moments</a>.</p>

<h2>结合静态多态和动态多态实现类型无关的容器</h2>

<p>使用 std::shared_ptr 中 deleter 的实现方式, 可以实现类型无关的容器. 代码主干如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">any</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">any</span><span class="p">()</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">any</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="k">new</span> <span class="n">holder</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">any</span><span class="p">(</span><span class="k">const</span> <span class="n">any</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">content</span> <span class="o">?</span> <span class="n">other</span><span class="p">.</span><span class="n">content</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">any</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">content</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="n">swap</span><span class="p">(</span><span class="n">any</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">content</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">any</span><span class="p">(</span><span class="n">rhs</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">any</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">rhs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">content</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">content</span> <span class="o">?</span> <span class="n">content</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">:</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">placeholder</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="o">~</span><span class="n">placeholder</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">placeholder</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">holder</span> <span class="o">:</span> <span class="k">public</span> <span class="n">placeholder</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">holder</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">held</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">typeid</span><span class="p">(</span><span class="n">ValueType</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">placeholder</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">holder</span><span class="p">(</span><span class="n">held</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">ValueType</span> <span class="n">held</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">holder</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">holder</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">placeholder</span><span class="o">*</span> <span class="n">content</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中, any 类持有一个 placeholder 的基类指针, 在构造 any 对象时, 通过 any 的模板构造函数, 根据具体类型创建具体的 placeholder 子类类型, any 类提供 type() 接口, 用于查询 any 类中存储的实际类型.boost::any 中有类似的实现.</p>

<p>使用方式如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">bitdewy</span><span class="o">::</span><span class="n">any</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">any_array</span><span class="p">;</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">.1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">any_array</span><span class="p">),</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">any_array</span><span class="p">),</span>
</span><span class='line'>                <span class="p">[](</span><span class="k">const</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">double</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//LOG ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考</h3>

<ul>
<li><a href="http://svn.boost.org/svn/boost/trunk/boost/any.hpp">boost::any</a></li>
<li><a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">My Most Important C++ Aha! Moments</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QtScript 与信号槽]]></title>
    <link href="http://bitdewy.github.io/blog/2013/03/21/qtscript/"/>
    <updated>2013-03-21T14:53:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2013/03/21/qtscript</id>
    <content type="html"><![CDATA[<p>Qt从4.3开始, 提供了 <a href="http://zh.wikipedia.org/wiki/ECMAScript">ECMAScript</a> 支持，QtScript 模块提供了一些让 Qt 应用程序脚本化的类. 在 Qt4 中 Webkit 与 QtScript 使用了相同的 javascript 引擎实现.（Qt5 中, javascript 引擎使用了 google 的 V8）</p>

<h2>在 QtScript 中使用信号槽</h2>

<p>Qt Script 可以使用Qt的核心特性: 信号槽. 信号只能存在于 C++ 的代码中, 但槽函数，以及连接的动作可以放到 javascript 中来做</p>

<ol>
<li>C++ 调用 script: 连接 C++ 代码中的信号到 script 函数上. 这个 script 函数可以是 C++ 代码中包含的 script 字符串, 也可以是从文件中读进来的. 如果不想将 QObject 对象泄露到脚本的运行环境中时, 这个方法是非常有用的. 仅仅需要在 script 代码中定义信号需要怎么被响应, 剩下的就是把连接工作放到 C++ 代码里就可以了.</li>
<li>Script 调用 C++: script 可以连接注入到脚本环境中的 C++ 对象的信号和槽, 在这种情况下, 槽函数还是定义在 C++ 代码中, 但是信号和槽的连接完全是动态的（在 script 中完成）</li>
<li>纯script: script 可以定义信号的响应函数句柄, 然后使用句柄建立信号与槽的连接. 比如： script 可以定义一个函数用来响应 <code>QLineEdit::returnPressed()</code> 信号, 然后连接信号与 script 函数.</li>
</ol>


<!-- more -->


<p>使用 <code>qScriptConnect()</code> 函数连接 C++ 信号到 script 函数上. 下面的例子中, handler 用来处理 <code>QLineEdit::textChanged()</code> 信号:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">QScriptEngine</span> <span class="n">eng</span><span class="p">;</span>
</span><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span>
</span><span class='line'><span class="s">&quot;(function(text) { print(&#39;text was changed to&#39;, text); })&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">textChanged</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="p">)),</span> <span class="n">QScriptValue</span><span class="p">(),</span> <span class="n">handler</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>qScriptConnect()</code> 的前两个参数与 <code>QObject::connect()</code> 的完全一致. 第三个参数是 script 对象, 当 signal handler 被调用时, 它充当 <code>this</code> 的角色. 在上面的代码中, 我们传入了一个不可用的值, 此时 <code>this</code> 是全局对象. 第四个参数是 script 函数, 相当于槽函数.
下面的代码展示如何使用 <code>this</code> 参数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s">&quot;(function() { print(&#39;I am&#39;, this.name); })&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">obj1</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">newObject</span><span class="p">();</span>
</span><span class='line'><span class="n">obj1</span><span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;the walrus&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">obj2</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">newObject</span><span class="p">();</span>
</span><span class='line'><span class="n">obj2</span><span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;Sam&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit1</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">returnPressed</span><span class="p">()),</span> <span class="n">obj1</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit2</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">returnPressed</span><span class="p">()),</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建了两个 <code>QLineEdit</code> 对象, 然后定义了信号响应函数. 信号槽链接使用了相同的响应函数, 但是使用不同的 <code>this</code> 对象, 具体使用哪个, 取决于哪个对象发出信号, 因此 <code>print()</code> 语句输出的内容将会有所不同.</p>

<p>在某个项目中,设计之初曾经考虑过以下的交互方式: javascript 传入 json 对象, 其中某个 value 是匿名 function, 来实现异步调用. 这种方式看起来很美, 也与第一种方式类似, 但是存在问题. C++ 无法获得当前 webkit 的 javascript 运行环境. QtScript 曾考虑过提供 API 来访问 webkit 的 javascript 运行环境, 详细信息可以参考：<a href="https://bugreports.qt-project.org/browse/QTWEBKIT-2">https://bugreports.qt-project.org/browse/QTWEBKIT-2</a>, 但由于种种原因最终放弃了, 不得不说这是个遗憾.</p>

<h2>参考</h2>

<ul>
<li><a href="http://qt-project.org/doc/qt-4.8/qtscript.html">http://qt-project.org/doc/qt-4.8/qtscript.html</a></li>
<li><a href="http://qt-project.org/doc/qt-4.8/scripting.html">http://qt-project.org/doc/qt-4.8/scripting.html</a></li>
<li><a href="http://qt-project.org/doc/qt-4.8/qtwebkit-bridge.html">http://qt-project.org/doc/qt-4.8/qtwebkit-bridge.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[空基类优化]]></title>
    <link href="http://bitdewy.github.io/blog/2013/02/25/empty-base-optimization/"/>
    <updated>2013-02-25T07:50:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2013/02/25/empty-base-optimization</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>优化空类数据成员的存储空间</p>

<h2>别名</h2>

<p>EBCO: Empty Base Class Optimization
Empty Member Optimization</p>

<h2>动机</h2>

<p>大小为 0 的类在 C++ 中是不存在的. C++ 需要空类大小不为 0 以确保对象的标识. 例如下面的 <code>EmptyClass</code> 的大小就是非 0 的, 因为数组中每一个对象的标识都是唯一的. 如果 <code>sizeof(EmptyClass)</code> 的大小为 0, 指针算数就会失效. 一般情况下, 类似 <code>EmptyClass</code> 的类大小通常为 1.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">EmptyClass</span> <span class="p">{};</span>
</span><span class='line'><span class="n">EmptyClass</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// Size of this array can’t be zero.</span>
</span></code></pre></td></tr></table></div></figure>


<p>当类似的类作为另一个类的数据成员时, 它的大小一般比 1 字节要大. 编译器通常 4 字节对齐来避免切割. 4 字节的空类对象只是占位符, 毫无用处. 避免浪费空间, 节省内存, 帮助对象更适应 CPU 缓存是非常有好处的.</p>

<!-- more -->


<h2>解决方案&amp;示例代码</h2>

<p>在 C++ 中, 如果一个空类作为基类被继承时, 情况会和上面的有些区别. 编译器允许继承层次结构扁平化, 被继承的空基类不占用空间. 例如下面的代码中 <code>sizeof(AnInt)</code> 在 32 位架构中是 4 字节, <code>sizeof(AnotherEmpty)</code> 是 1 字节, 虽然这两个类都继承自 <code>EmptyClass</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">AnInt</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EmptyClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>   <span class="c1">// size = sizeof(int)</span>
</span><span class='line'><span class="k">class</span> <span class="nc">AnotherEmpty</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EmptyClass</span> <span class="p">{};</span>  <span class="c1">// size =  1</span>
</span></code></pre></td></tr></table></div></figure>


<p>EBCO 有效的利用了这个特性. 这并不是说简单, 天真的将数据成员的空类变成基类是可取的, 因为这可能会暴露原本需要对用户隐藏的接口. 例如下面的 EBCO 实现方式, 可能会有副作用: 类 <code>Foo</code> 的用户现在可以看到一些方法 (如果在 E1, E2 中存在的话), 虽然他们是私有继承而来的, 不可访问.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">E1</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">E2</span> <span class="p">{};</span>
</span><span class='line'><span class="c1">// **** before EBCO ****</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">E1</span> <span class="n">e1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">E2</span> <span class="n">e2</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span> <span class="c1">// sizeof(Foo) = 8</span>
</span><span class='line'><span class="c1">// **** after EBCO ****</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="k">private</span> <span class="n">E1</span><span class="p">,</span> <span class="k">private</span> <span class="n">E2</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span> <span class="c1">// sizeof(Foo) = 4</span>
</span></code></pre></td></tr></table></div></figure>


<p>一种实现 EBCO 的实用方法是: 将空的类成员组合到单一的存储结构扁平的成员中. 下面的模板 <code>BaseOptimization</code> 的前两个模板参数是用来实现 EBCO的. 使用 <code>BaseOptimization</code> 改写类 <code>Foo</code> 如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Base1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Base2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Member</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">BaseOptimization</span> <span class="o">:</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">Member</span> <span class="n">member</span><span class="p">;</span>
</span><span class='line'>   <span class="n">BaseOptimization</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>   <span class="n">BaseOptimization</span><span class="p">(</span><span class="n">Base1</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b1</span><span class="p">,</span> <span class="n">Base2</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">b2</span><span class="p">,</span> <span class="n">Member</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">mem</span><span class="p">)</span>
</span><span class='line'>       <span class="o">:</span> <span class="n">Base1</span><span class="p">(</span><span class="n">b1</span><span class="p">),</span> <span class="n">Base2</span><span class="p">(</span><span class="n">b2</span><span class="p">),</span> <span class="n">member</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>   <span class="n">Base1</span> <span class="o">*</span> <span class="n">first</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>   <span class="n">Base2</span> <span class="o">*</span> <span class="n">second</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">BaseOptimization</span><span class="o">&lt;</span><span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span> <span class="c1">// sizeof(Foo) = 4</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 EBCO 并没有改变类 Foo 的继承体系. 保证基类不会互相冲突, 这是至关重要的. 也就是说 Base1 与 Base2 是独立的集成体系中的一部分.</p>

<p><strong>注意</strong>: 对象身份标识的问题, 不同的编译器处理起来是不相同的. 空对象的地址可能是相同的, 也可能是不同的. 例如: BaseOptimization 的成员函数 first 和 second 返回的指针, 在有些编译器上可能是相同的, 而有些编译器上可能是不同的. 更多的讨论请看这里：<a href="http://stackoverflow.com/questions/7694158/boost-compressed-pair-and-addresses-of-empty-objects">stackoverflow</a></p>

<h2>已知的用途</h2>

<p><a href="http://www.boost.org/doc/libs/1_53_0/libs/utility/compressed_pair.htm">boost::compressed_pair</a> 使用了该惯用法, 来优化 pair 的存储空间
C++03 模拟实现 <a href="http://home.roadrunner.com/~hinnant/unique_ptr03.html">unique­_ptr</a> 也使用了该惯用法</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.informit.com/articles/article.aspx?p=31473&amp;seqNum=2">The Empty Base Class Optimization (EBCO)</a></li>
<li><a href="http://www.cantrip.org/emptyopt.html">The &ldquo;Empty Member&rdquo; C++ Optimization</a></li>
<li><a href="http://www.ibm.com/developerworks/aix/library/au-boostutilities/index.html">Internals of boost::compressed_pair</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 C++03 中实现强类型安全的枚举类型]]></title>
    <link href="http://bitdewy.github.io/blog/2013/02/05/strongly-type-safe-enum-in-cpp03/"/>
    <updated>2013-02-05T21:53:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2013/02/05/strongly-type-safe-enum-in-cpp03</id>
    <content type="html"><![CDATA[<h2>意图</h2>

<p>改进 C++ 枚举的类型安全性</p>

<h2>动机</h2>

<p>在 C++03 中枚举类型的类型安全性不够强, 有可能导致意想不到的错误. 虽然枚举是语言内置的特性, 但也可能由于编译器的不同, 而存在可移植性的问题. 枚举的问题基本上可以分为3类:</p>

<ul>
<li>隐式转换</li>
<li>无法指定类型</li>
<li>作用域问题</li>
</ul>


<p>C++03 中枚举类型是部分类型安全的, 比如你将一个枚举类型的值直接赋值给另一个枚举类型, 而且无法从整形隐式转换到枚举类型. 但是, 最常见的枚举类型错误是: 它可以自动提升成整形. 例如下面的代码, 只有少数几个的编译器（比如 GNU 的 g++）会发出警告, 而 VC++ 不会有任何的提示.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">enum</span> <span class="n">color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
</span><span class='line'><span class="k">enum</span> <span class="n">shape</span> <span class="p">{</span> <span class="n">circle</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="n">triangle</span> <span class="p">};</span>
</span><span class='line'><span class="n">color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="n">triangle</span><span class="p">);</span> <span class="c1">// Unintended!</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>C++03 中枚举类型另外的问题是无法指定枚举存储时的类型. 这可能导致数据大小以及符号问题在各个编译器上表现不同而导致不可移植的问题. 最后, 是作用域问题, 在相同的作用域内不能有两个相同名称的枚举值.</p>

<p>强类型的枚举已经进入 C++11 标准中. 详细内容参考: <a href="http://www.stroustrup.com/C++11FAQ.html#enum">C++11 FAQ: enum class</a>
下面是 C++03 强类型安全的枚举实现。</p>

<h2>解决方案&amp;示例代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">def</span><span class="p">,</span> <span class="k">typename</span> <span class="n">inner</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">def</span><span class="o">::</span><span class="n">type</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">safe_enum</span> <span class="o">:</span> <span class="k">public</span> <span class="n">def</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">def</span><span class="o">::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
</span><span class='line'>  <span class="n">inner</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">safe_enum</span><span class="p">(</span><span class="n">type</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">inner</span> <span class="n">underlying</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">!=</span> <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span>  <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span>  <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&gt;</span>  <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span>  <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="k">const</span> <span class="n">safe_enum</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">color_def</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">type</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">safe_enum</span><span class="o">&lt;</span><span class="n">color_def</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">shape_def</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">type</span> <span class="p">{</span> <span class="n">circle</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="n">triangle</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">safe_enum</span><span class="o">&lt;</span><span class="n">shape_def</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">shape</span><span class="p">;</span> <span class="c1">// unsigned char representation</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="n">shape</span><span class="o">::</span><span class="n">triangle</span><span class="p">);</span> <span class="c1">// Compiler error.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上述解决方案的代码中, 实际的枚举类型包裹在 <code>color_def</code> 和 <code>shape_def</code> 结构体中. <code>safe_enum</code> 模板帮我们实现了一个类型安全的枚举. <code>safe_enum</code> 使用了 <a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Parameterized_Base_Class">Parameterized Base Class</a> 惯用法. 它继承了模板参数 <code>color_def</code> 以及 <code>shape_def</code>, 使得 color 以及 shape 变成了强类型安全的枚举.</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">Strongly Typed Enums (revision 3)</a></li>
<li><a href="http://scottmeyers.blogspot.hk/2013/01/effective-c11-content-and-status.html">Effective C++11: Content and Status -Prefer enum classes to enums.</a></li>
<li><a href="http://www.stroustrup.com/C++11FAQ.html#enum">C++11 FAQ: enum class &mdash; scoped and strongly typed enums</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你确定你懂 const 和 mutable ?]]></title>
    <link href="http://bitdewy.github.io/blog/2013/01/03/you-dont-know-const-and-mutable/"/>
    <updated>2013-01-03T14:38:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2013/01/03/you-dont-know-const-and-mutable</id>
    <content type="html"><![CDATA[<p>const 和 mutable 是 C++ 中两个关键字，你确定你懂 const 和 mutable 吗？</p>

<p>下面是一段完整的 C++11 代码;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;utility&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">async</span><span class="p">([]{</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">z</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">};</span> <span class="p">});</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">async</span><span class="p">([]{</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">z</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="p">};</span> <span class="p">});</span>
</span><span class='line'>  <span class="n">x</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="n">y</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的程序能正确同步么? 有线程安全的问题吗?</p>

<p>嗯, vector 是标准库的内置容器, 如果换成我们自己写的类呢? 比如下面的代码;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;utility&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">async</span><span class="p">([]{</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">widget</span><span class="p">,</span> <span class="n">widget</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">{</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="p">};</span> <span class="p">});</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">async</span><span class="p">([]{</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">widget</span><span class="p">,</span> <span class="n">widget</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">{</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="p">};</span> <span class="p">});</span>
</span><span class='line'>  <span class="n">x</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="n">y</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>widget</code> 的线程安全性如何?</p>

<!-- more -->


<p>上面的问题先放一放, 我们来看一个基础的问题.</p>

<p>在 C++98 中, <code>const</code> 表示什么含义?</p>

<p>嗯, <code>const</code> 表示不可更改, 不过它是 logically const, 而不是 physically 或者 bitwise 的 const.</p>

<p>如果你对 const 的认识仅限于此, 那么可以说你不懂 const, 在 C++11 中, 你需要重新认识 const.</p>

<p><strong>C++11 中增加了一直空白的对于多线程的描述.</strong></p>

<p>看一下 C++11 标准中是怎么说的吧, C++11 标准文档, 语言核心部分 1.10 第4条和第21条:</p>

<p><em>两个表达式, 如果其中一个正在<strong>修改</strong>内存, 而另一个去访问或<strong>修改</strong>相同的内存, 那么两个表达式会发生<strong>冲突</strong>.</em></p>

<p><em>如果一个程序在不同的线程中包含了两个会<strong>冲突</strong>的动作, 至少其中一个不是原子操作, 且不会在另一个动作发生之前发生, 那么程序运行时会产生<strong>数据竞争</strong>. 任何的数据竞争都会导致未定义的行为.</em></p>

<p>再来看看关于标准库部分 17.6.5.9 的第1条和第3条:</p>

<p><em>这一节的指定要求是防止<strong>数据竞争</strong>.</em></p>

<p><em>C++ 标准库函数除在当前线程外, 不能直接或间接的修改对象, 除非这个对象是通过函数的非 const 参数直接或间接的访问的, 包括 <code>this</code> 指针.</em></p>

<p>这样一来, const 的含义就变为了 只读 或 线程安全.</p>

<p>下面来看一下标准中 20.2 的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span><span class='line'><span class="k">namespace</span> <span class="n">rel_ops</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">[...]</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>  <span class="p">[...]</span> <span class="nl">Returns:</span> <span class="o">!</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>返回值 <code>!(x == y)</code> 意味着什么?</p>

<p>这意味着, 使用 std::rel_ops 的任何类型都需要提供线程安全的 <code>operator==</code> 和 <code>operator&lt;</code>. 比如, 在不同的线程中, 比较同一个对象时, 不需要串行化访问.</p>

<p>再来看看 20.3.2 的 <code>std::pair</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">pair</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">pair</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>构造函数的参数 <code>const T1&amp; x, const T2&amp; y</code> 这意味着什么?</p>

<p>这意味着, 任何支持拷贝, 会作为 <code>std::pair</code> 类型参数的类型 T, 都需要支持线程安全的拷贝. 比如, 多个线程同时拷贝同一个对象时, 不需要显式的串行化访问.</p>

<p>上面说的这些是什么意思?</p>

<p>线程安全:</p>

<ul>
<li>bitwise const, 或者</li>
<li>类似 leaf-level locking(像 std::atomics) 的内部串行化 (非 leaf level 的 locking 可能会导致死锁)</li>
</ul>


<p>标准库保证了 const == 线程安全:</p>

<ul>
<li>所有的标准库中的类, 以及</li>
<li>所有能作用到用户自定义类型的操作符</li>
</ul>


<p>所以就照着标准库的方式来做吧.</p>

<p>任何一个标准库中定义的类, 如果声明一个该类型的 const 对象, 那么它就是线程安全的. (完全不可更改, 或者有内部的串行化访问)</p>

<p>在 C++98 中, const 意味着逻辑上不可更改. 而在 C++11 中, const 意味着线程安全(内存完全不可改, 或者内部实现了串行化访问).</p>

<p>明白了 const, 接下来看看下面的代码有什么问题:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>  <span class="c1">// protects internal data</span>
</span><span class='line'>  <span class="c1">//...     // more data</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">info</span> <span class="n">get_info</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">hold</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="cm">/* use &#39;more data&#39;*/</span><span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>是的, 上面的代码编译不过. <code>lock_guard</code> 需要的是 <code>mutex&amp;</code> 类型, 而现在的类型是 <code>const mutex&amp;</code>.</p>

<p>那么该如何修改呢? 像下面这样么?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>  <span class="c1">// protects internal data</span>
</span><span class='line'>  <span class="c1">//...     // more data</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">info</span> <span class="n">get_info</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">hold</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">m_</span><span class="p">));</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="cm">/* use &#39;more data&#39;*/</span><span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这么改, 没有任何问题, 程序可以正确的运行, 但是, 我们需要在使用了 m_ 的地方都用一下 <code>const_cast</code>. 包括以后新增的代码也需要, 这显然不是个好办法.</p>

<p>改成下面这样呢?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">mutable</span> <span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>  <span class="c1">// protects internal data</span>
</span><span class='line'>  <span class="c1">//...             // more data</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">info</span> <span class="n">get_info</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">hold</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="cm">/* use &#39;more data&#39;*/</span><span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>回顾一下, <code>mutable</code> 在 C++98 中的含义: “mutable 表示不会被观察到的非 const.”</p>

<p>如果你对 mutable 的认识仅限于此, 那么可以说你不懂 mutable, 在 C++11 中, 你需要重新认识 mutable.</p>

<p><strong>一个类内部的 mutex 对象想要成为 mutable 类型. 为什么?</strong></p>

<p><strong>因为 mutex 自己已经是串行化访问的了</strong>.</p>

<p>在 C++98 中, mutable 意味着不会被观察到的非 const, 而在 C++11 中, mutable 意味着线程安全.</p>

<p>现在再看上面的代码, mutable表达了什么?</p>

<p>没错，线程安全, 而且是自然而且完美的表达, 因为 mutable 通常就是意味着 “as good as const/ logically const”.</p>

<p>再来看一个例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter_</span><span class="p">;</span>            <span class="c1">// protects internal data</span>
</span><span class='line'>  <span class="c1">//...                            // more data</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">info</span> <span class="n">get_info</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">++</span><span class="n">counter_</span><span class="p">;</span>                    <span class="c1">// oops, const</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="cm">/* use &#39;more data&#39;*/</span><span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>与最开始 mutex 的例子一样, 这段代码编译不过. 我们要做的就是把 <code>counter_</code> 声明为 <code>mutable</code>. 因为counter_ 本身就是线程安全的.</p>

<p>C++11 中增加了关于多线程的内容，<code>const</code> 与 <code>mutable</code> 关键字有了新的语义.</p>

<h3>参考</h3>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">C++ 标准草案 n3242</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2669.htm">Thread-Safety in the Standard Library (Rev 2)</a></li>
<li><a href="http://channel9.msdn.com/posts/C-and-Beyond-2012-Herb-Sutter-You-dont-know-blank-and-blank">C++ and Beyond 2012: Herb Sutter &ndash; You don&rsquo;t know [blank] and [blank]</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 lambda in Qt5]]></title>
    <link href="http://bitdewy.github.io/blog/2012/12/23/c-plus-plus-11-lambda-in-qt5/"/>
    <updated>2012-12-23T22:32:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/12/23/c-plus-plus-11-lambda-in-qt5</id>
    <content type="html"><![CDATA[<p>C++11 发布已经1年多，各家编译器也都有了很好的支持，新特性中有非常多值得关注的东西，比如：右值引用、类型推导、匿名函数等等。</p>

<h2>lambda 函数与表达式</h2>

<p>C++11 引入了 lambda 函数，在函数是 first class 的语言中，匿名函数是最基础的设施，可以方便的运用闭包造出高阶函数。现在 C++11 引入了 lambda 表达式（是不是可以在 C++ 中玩 Functional Programming 了，嘿嘿)，和标准库算法配合起来就不会像以前那么别扭了。在没有 lambda 的时候使用 <code>std::sort</code> 或者 <code>std::find</code> 时，需要一个具名函数，原本一个很简单的，用完就丢掉的代码段必须声明为一个函数或仿函数，割裂了逻辑不说，还占用了一个标识符(取名，在写代码的时候时很让人头疼的一件事，你懂的)，现在一切都变的简单了。</p>

<!-- more -->


<p>假设你想计算某个字符串包含多少个大写字母，使用 for_each() 遍历一个 char 数组，下面的 lambda 表达式确定每个字母是否是大写字母，每当它发现一个大写字母，lambda 表达式给 Uppercase 加 1：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello World!&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">Uppercase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//modified by the lambda  </span>
</span><span class='line'>    <span class="n">for_each</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">Uppercase</span><span class="p">]</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">isupper</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
</span><span class='line'>            <span class="n">Uppercase</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Uppercase</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; uppercase letters in: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>匿名函数的威力当然不是只有这么一点，不过这不是本文的重点，关于匿名函数和闭包可以向会 javascript 的同学学习。</p>

<h2>Qt5</h2>

<h3>old signal &amp; slot</h3>

<p>Qt5 终于在末日前一天——12月20日正式发布了，信号槽有了新的用法。</p>

<p>在 Qt5 之前，信号槽连接要这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">valueChanged</span><span class="p">(</span><span class="n">QString</span><span class="p">,</span><span class="n">QString</span><span class="p">)),</span>
</span><span class='line'>             <span class="n">receiver</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">updateValue</span><span class="p">(</span><span class="n">QString</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>Qt 利用 SIGNAL 和 SLOT 这两个宏，把函数名转换成一个字符串。然后后，moc 将会扫描全部文件，将所有的 signal 和 slot 提取出来做成一个映射表。QObject::connect() 函数会从这个映射表里面找到该字符串，从 signal 的名字就可以找到 slot 的名字，就知道了在 signal emit 的时候，该去调用哪一个 slot 函数。</p>

<p>但是，由于信号槽都被处理成了字符串，所以编译期间是无法检查的，所有检查都是在运行时完成的。而且，由于是字符串，所以 slot 中的参数类型名必须与 signal 的完全一致。</p>

<h3>new signal &amp; slot</h3>

<p>在 Qt5 中我们有了更好的选择（原来的语法仍然支持）：使用函数指针</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span>
</span><span class='line'>        <span class="n">receiver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Receiver</span><span class="o">::</span><span class="n">updateValue</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来和之前的版本很类似，但新的用法有很多好处：</p>

<ul>
<li>编译期类型检查，以及 <code>Q_OBJECT</code> 宏检查</li>
<li>可以随意使用 typedef 和 namespace 了</li>
<li>支持参数类型的隐式转换，比如(QString 转换为 QVariant)</li>
<li>可以连接任何成员函数，不仅仅是槽函数</li>
</ul>


<p>坏处是，槽函数从此以后不能用默认参数了。(也没那么坏，是吧)</p>

<p>更有威力的是，connect 可以连接简单函数了，不仅仅是 QObject 对象的成员函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span> <span class="n">someFunction</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>看到这儿，就能想到最开始的 lambda 了吧，没错，<code>someFunction</code> 可以是个 function 也可以是一个 lambda 表达式，新的连接方式可以和 <code>tr1::bind(std::bind)</code> 以及 lambda 表达式完美的配合。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span>
</span><span class='line'>    <span class="n">tr1</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Receiver</span><span class="o">::</span><span class="n">updateValue</span><span class="p">,</span> <span class="s">&quot;senderValue&quot;</span><span class="p">,</span> <span class="n">tr1</span><span class="o">::</span><span class="n">placeholder</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">newValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">receiver</span><span class="o">-&gt;</span><span class="n">updateValue</span><span class="p">(</span><span class="s">&quot;senderValue&quot;</span><span class="p">,</span> <span class="n">newValue</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>唯一的坏处就是： <code>receiver</code> 在销毁的时候，无法自动断开连接</p>

<h3>异步操作变的更简单</h3>

<p>有了 C++11 的 lambda 表达式，与 STL 的算法一样，关于网络的一些异步操作同样变的非常简单了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">doYourStuff</span><span class="p">(</span><span class="k">const</span> <span class="n">QByteArray</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTcpSocket</span><span class="p">;</span>
</span><span class='line'>    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">connectToHost</span><span class="p">(</span><span class="s">&quot;qt.nokia.com&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
</span><span class='line'>    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QTcpSocket</span><span class="o">::</span><span class="n">connected</span><span class="p">,</span> <span class="p">[</span><span class="n">socket</span><span class="p">,</span> <span class="n">page</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">socket</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">QByteArray</span><span class="p">(</span><span class="s">&quot;GET &quot;</span> <span class="o">+</span> <span class="n">page</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">));</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QTcpSocket</span><span class="o">::</span><span class="n">readyRead</span><span class="p">,</span> <span class="p">[</span><span class="n">socket</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">qDebug</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&quot;GOT DATA &quot;</span><span class="o">&lt;&lt;</span> <span class="n">socket</span><span class="o">-&gt;</span><span class="n">readAll</span><span class="p">();</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是一个 <code>QDialog</code> 的例子，代码没有被割裂，也没有重入消息循环，看起来干净多了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">Doc</span><span class="o">::</span><span class="n">saveDocument</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">QFileDialog</span> <span class="o">*</span><span class="n">dlg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFileDialog</span><span class="p">();</span>
</span><span class='line'>    <span class="n">dlg</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">();</span>
</span><span class='line'>    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">dlg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QDialog</span><span class="o">::</span><span class="n">finished</span><span class="p">,</span> <span class="p">[</span><span class="n">dlg</span><span class="p">,</span> <span class="k">this</span><span class="p">](</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">QFile</span> <span class="n">file</span><span class="p">(</span><span class="n">dlg</span><span class="o">-&gt;</span><span class="n">selectedFiles</span><span class="p">().</span><span class="n">first</span><span class="p">());</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">dlg</span><span class="o">-&gt;</span><span class="n">deleteLater</span><span class="p">();</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然 C++ 不推崇函数式，但 lambda 的引入绝对是一大进步，据说 Java 8 也会引入 lambda，不过 Java 8 什么时候发布都还没谱呢……</p>

<h3>参考</h3>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11</a></li>
<li><a href="http://qt-project.org/wiki/New_Signal_Slot_Syntax">New Signal Slot Syntax Coming in Qt 5</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] why c++ is not back]]></title>
    <link href="http://bitdewy.github.io/blog/2012/12/16/why-c-plus-plus-is-not-back/"/>
    <updated>2012-12-16T17:42:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/12/16/why-c-plus-plus-is-not-back</id>
    <content type="html"><![CDATA[<p>前言：这个月初，<a href="http://herbsutter.com/">Herb Sutter</a> 发了一篇名为 <a href="http://simpleprogrammer.com/2012/12/01/why-c-is-not-back/">Perspective: “Why C++ Is Not ‘Back’”</a>，的文章，虽然 <a href="http://herbsutter.com/">Sutter</a> 不同意原文中的全部细节，但也推荐读一读原文和评论。语言之争，由来已久，每次一有这种文章就会引发激烈的讨论，比如<a href="http://coolshell.cn/articles/7992.html">这里</a>。</p>

<p>本译文中不会发表任何观点，尽量表达原作者的意图，如有翻译不当的地方欢迎大家积极指出，我会做出修改。</p>

<p>原文在这里： <a href="http://simpleprogrammer.com/2012/12/01/why-c-is-not-back/">Why C++ Is Not “Back”</a></p>

<p><strong>下面是译文：</strong></p>

<p>我喜爱 C++。</p>

<p>C++ 真正教会了我如何写代码。</p>

<p>以前，我会学习语言本身的复杂性，<a href="http://www.cplusplus.com/reference/stl/">STL</a>，以及内存管理和指针运算中的所有细节。</p>

<p>这些都是很美好的时光。我还记得一遍又一遍的读 <a href="http://www.aristeia.com/">Scott Meyers</a> 的 <a href="http://www.amazon.com/gp/product/B008E30L9A/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B008E30L9A&amp;linkCode=as2&amp;tag=makithecompsi-20">Effective C++</a> 系列。每一次都能从中学到一些新的东西，或者更理解如何使用 C++。</p>

<p>我说上面这些只是想让你知道，<strong>我不讨厌 C++</strong>。我喜欢 C++。</p>

<p>我知道，有很多优秀现在仍然在使用 C++ 并教别人如何使用，这一点也没有错。</p>

<p>但问题是什么？</p>

<!-- more -->


<h2>新消息是不正确的</h2>

<p><a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11</a> 发布了，最近大家对使用 C++ 开发又提起了兴趣。</p>

<p>不要误会我的意思，C++11非常棒！我100%的同意新标准中所做的一切。C++ 无疑已经变得更易用也更强大。</p>

<p>但有一件事，它并没有做到，这是最重要的——更简单。</p>

<p><strong>看来，许多经验丰富的开发人员已经忘记了当初为什么抛弃 C++ 而转到 Java，C# 以及其他的开发语言中。</strong></p>

<p>许多年轻的或者新入行的开发者不知道这些历史，被现在 C++ 的新消息和复兴所迷惑。</p>

<p>每个人都在问我，是否需要学习 C++，就像几年前一样，我现在的答案还是一样——<strong>不</strong>！</p>

<p>好吧，大写的 “不” 是有点苛刻。一个更好的答案是 “为什么？”</p>

<h2>你为什么想要学习 C++？</h2>

<p>我所能想到的今天去学习 C++ 的理由只有下面三个。</p>

<ul>
<li>你绝对的需要每一 bit 都发挥出最大的性能，并且想要用一个支持面向对象抽象的语言</li>
<li>你写的代码将跑在原生的硬件上。（比如：你正在写一个底层驱动程序）</li>
<li>当内存控制和时间绝对重要的时候，你需要系统有确定性的行为以及手动管理内存的能力。（想想实时嵌入式操作系统正在控制的一个移动的机械装置）</li>
</ul>


<p>虽然我可能少考虑了其他的情况，但是其他的情况基本上也无法逃出上面所说的三个范围。</p>

<p>等等，等等，可移植性呢？</p>

<p>不需要！<strong>不要想着学习 C++ 然后构建任何地方都能跑起来的软件。</strong> 今天我们还有大量的其他选择，而且 C++ 根本没有人们以为的那样有多好的可移植性。每个操作系统或者平台的底层抽象是非常不同的。</p>

<p>另外，请不要告诉我 C++正好可以给你你所需要的更多的权利和可控性。</p>

<p><strong>大多数软件开发是解决实际问题，管理复杂性，而不是在玩底层的细节。</strong>在几乎所有的现代大型软件开发中，我们需要的都是更高级的抽象，而不是低级别的抽象。</p>

<h2>但是，我就是想学 C++</h2>

<p>好了，听着，我知道你认为 Windows 8 非常酷，并且有很多人都在学习 C++ 来开发他们的 Windows 8 应用，但是在你喝 “Kool-Aid” 之前，你应该知道它里面有些什么。</p>

<p>写 C++ 代码不是去野餐。</p>

<p>即使 C++11 做了一些改变，C++ 仍然是一个非常难学习，也非常难掌握的语言。</p>

<p>你也许听说过下面这个关于 C++ 的说法：</p>

<blockquote><p>C makes it easy to shoot yourself in the foot. C++ makes it harder, but when you do, you blow away your whole leg!</p>

<p>— Bjarne Stroustrup</p></blockquote>

<p>你不知道 Bjarne 是谁？好吧，他是 C++ 之父。我想你能从他的话里面得到自己的结论。</p>

<p>我不断的听到 C++11 相对于 C++98 的改进，我一点也不怀疑。</p>

<p><strong>但它没有改进的是语言的规模大小——事实上反而增加了。</strong></p>

<p>当然，你可以使用 C++ 的一个子集。当然，你也可以使用新的<a href="http://en.wikipedia.org/wiki/Smart_pointer">智能指针</a>，把你从手工管理内存的情况中解救出来。你可以使用 <a href="http://msdn.microsoft.com/en-us/library/dd293608.aspx">lambda</a> 来避免使用函数指针。当然类型自动推导也是非常必要的新鲜空气。</p>

<p><strong>问题是，你仍然需要知道底层的东西，以了解当你调试一个有内存问题的 C++ 程序时，究竟问题在哪儿。</strong>（如果你生在脱管代码的时代，这些可能是你从来都没有听说过的东西。）</p>

<p>你也可能会遇到 20 年前的 C++ 代码，它看起来就像一个完全不同的语言。</p>

<p>下面是一个 C++ 开发人员的面试问题列表：</p>

<ol>
<li>C++ 中有多少种方式初始化一个基本类型数据，它们分别是什么？</li>
<li>为什么析构函数要声明为虚函数？</li>
<li>C++ 支持重载，是什么意思？</li>
<li>C++ 重载的例子有哪些？</li>
<li>什么是 name mangling，为什么要用它？</li>
<li>什么是抽象基类？</li>
<li>什么是 RTTI？</li>
<li>如何访问一个同名但是被”隐藏“的变量？</li>
<li>namespace 是什么，如何使用？</li>
<li>struct 与 class 有什么区别，与 C 比又有什么区别？</li>
<li>template 是什么，如何使用？</li>
<li>什么是拷贝构造函数，什么时候需要拷贝构造函数，与赋值操作符相比有哪些不同？</li>
<li>深拷贝和浅拷贝有什么不同？</li>
<li>const 的作用是什么，如何使用？</li>
<li>在 C++ 中，传值，传引用和传递指针的区别是什么？</li>
<li>什么时候应该返回一个值的引用，什么时候不应该返回一个值的引用？</li>
<li>在堆和栈上创建一个变量有什么不同？</li>
<li>如何释放一个数组动态分配的内存？只使用 delete 的含义是什么？</li>
<li>什么是多继承？ 什么时候使用多继成？</li>
<li>什么是纯虚函数？</li>
<li>关键字 mutable 是做什么的？</li>
<li>关键字 volatile 是做什么的？</li>
<li>STL 是什么？</li>
<li>什么是 vector ？</li>
<li>头文件 algorithms 中包含哪些内容？</li>
<li><code>#include&lt;iostream.h&gt;</code> 和 <code>#include&lt;iostream&gt;</code> 有什么区别？</li>
<li><code>++i</code> 和 <code>i++</code> 有什么区别？</li>
<li>什么是短路计算？怎样才能使用它？它为什么是危险的？</li>
<li>什么是逗号表达式？</li>
<li>唯一的三目运算符是什么？如何使用？</li>
<li>const 成员函数有什么作用？如何使用？</li>
<li>在 C++ 中使用 try/catch 好不好？</li>
<li>为什么不能在析构函数中抛异常？</li>
<li>关键字 explicit 是做什么的？</li>
<li>C++ 中类型转换的正确方式是什么？</li>
<li>内联函数是什么，都做了什么？</li>
</ol>


<p>上面一些问题，在 C# 或 Java 中，有相同的答案，但是你可以从这个问题列表看出来，C++ 水非常非常深。需要花费大量的精力来了解语言本身。</p>

<p>C# 或 Java 开发会有些关于语言本身的学习，但更多的是学习库的使用。</p>

<p>C++ 开发更多的是学习语言的每一个角落。</p>

<h2>C++ 不是未来的方向</h2>

<p>最大的问题，编程语言真正需要的是简单和增加它的抽象能力，而不是降低。</p>

<p>底层的代码总会有需求，但是今天大部分的代码都是更高层次的。</p>

<p>很多年前，当我无法再说 C++ 比 C# 开发效率更高的时候，我第一次跳下了 C++ 这条船。</p>

<p>我很长时间都试图相信曾经在 C++ 上耗费的精力时没有白费的，但是<strong>事实证明，C# 把事情简化到了伟大的程度，它有 C++ 一样的能力，却不需要额外的责任。</strong></p>

<p>当我想休息一下再写这篇博客的时候，我碰巧发现了微软研究院的一个叫做 <a href="https://www.touchdevelop.com/">touchdevelop</a> 的项目。这才是我们的方向。我们需要编程语言越来越简单，而不是越来越复杂。</p>

<p>不要误会我的意思，<a href="https://www.touchdevelop.com/">touchdevelop</a> 会有非常多的限制，但是我相信像这样的东西才是未来。</p>

<p>似乎微软正在努力推动让 C++ 回归主流，让 Windows 8 支持 C++ 开发，并试图干掉 XNA，但我觉得这是一个扭曲的看法，这似乎是 Windows 系统的开发人员根深蒂固的想法——开发人员想要使用 C++。</p>

<p>我只是不想看到自己再回到以前，在能使用 C# 在各个平台写代码的时候，还使用那么复杂的语言。C# 不是完美的语言，但是它非常优雅，简单。</p>

<h2>关于 C++ 的只言片语</h2>

<p>虽然我说了上面那些话，但我还是相信学习 C++ 是值得的。</p>

<p>不，我不是在自相矛盾，请允许我解释。</p>

<p>如果你能写 C++，那么你能用其他任何语言写代码。如果你了解堆、栈、内存，引用和指针以及让 C++ 如此复杂的其他底层细节，它会在你使用高级别抽象语言时给你帮助，让你能够明白计算机是如何工作的。</p>

<p><strong>这篇文章，我的观点不是抨击 C++，或抨击 C++ 使用者，和教别人 C++ 的人，只是说出我的观点，这貌似是热心的 C++ 社区所鼓励的。</strong></p>

<p>每个人都不会成为 C++ 开发人员，而且也不需要。也许 C++ 有能力让你的程序更高效（在某些情况下），它几乎绝对不可能让你开发过程更高效（除非极少数的极端情况下。）</p>

<p>我很高兴，C++ 有了很大的改进，但是我不认为它能很快的东山再起，而且这是一个好事情。</p>

<p><strong>译文完。</strong></p>

<h3>参考</h3>

<ul>
<li><a href="http://channel9.msdn.com/posts/C-and-Beyond-2011-Herb-Sutter-Why-C">Herb Sutter &ndash; Why C++?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CMake lua 5.2]]></title>
    <link href="http://bitdewy.github.io/blog/2012/12/15/cmake-lua5-dot-2/"/>
    <updated>2012-12-15T18:09:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/12/15/cmake-lua5-dot-2</id>
    <content type="html"><![CDATA[<p>不知道从什么时候开始，lua 源码不再提供 visual studio 工程文件了。windows 用户只能自己动手了，无奈 visual studio 版本太多，工程文件也不是人能读懂，简直不可维护。所以下面用 <a href="http://www.cmake.org/">CMake</a> 来生成 vcproj，这样维护起来更方便。</p>

<h2>什么是 CMake？</h2>

<p><a href="http://www.cmake.org/">CMake</a> 是个开源的跨平台自动化建构系统，它用组态档控制建构过程（build process）的方式和 Unix 的 Make 相似，只是 <a href="http://www.cmake.org/">CMake</a> 的组态档取名为 CMakeLists.txt。<a href="http://www.cmake.org/">CMake</a> 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 <a href="http://www.cmake.org/">CMake</a> 和 SCons 等其他类似系统的区别之处。</p>

<p>有了 <a href="http://www.cmake.org/">CMake</a> 就不用在 vcproj 的各个版本之前来回的切换了，每次用 <a href="http://www.cmake.org/">CMake</a> 生成相应的工程文件就一切 OK 了。</p>

<h2>Windows 下用 CMake 安装 lua 5.2.1</h2>

<h3>安装 CMake</h3>

<p>从<a href="http://cmake.org/cmake/resources/software.html">官方下载</a>相应的安装包，安装完成后，别忘了把 <a href="http://www.cmake.org/">CMake</a> 加入 <code>PATH</code> 中。</p>

<h3>使用 CMake 生成 vcproj</h3>

<p>lua官方不提供带 CMake 的源码，会的朋友可以手工写几个 CMakeList.txt 就 OK，不会的直接下载 bitdewy 写好的 <a href="http://sdrv.ms/TTp5Y6">cmake-lua-5.2.1.tar.gz</a> 吧。解压后用 visual studio 的命令行进入 <code>lua-5.2.1/build</code> 目录，然后输入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>cmake -DCMAKE_INSTALL_PREFIX<span class="o">=</span><span class="s2">&quot;C:\lua52&quot;</span> ..
</span></code></pre></td></tr></table></div></figure>


<p>完成之后就可以打开 build 目录下的 lua.sln 文件直接编译了，编译 INSTALL 工程，会在上面设置的 <code>C:\lua52</code> 目录中安装 lua，luac，静态链接库，动态链接库，头文件、源代码以及文档，如果不想安装，不编译 INSTALL 工程就好。如果不设置安装目录，那么 windows 下默认的安装目录就是 <code>%ProgramFiles%</code> 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[COM、ABI与引用计数]]></title>
    <link href="http://bitdewy.github.io/blog/2012/12/09/com-and-reference-counting/"/>
    <updated>2012-12-09T18:18:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/12/09/com-and-reference-counting</id>
    <content type="html"><![CDATA[<h2>什么是 COM ？</h2>

<p>Component Object Model (COM) 组件对象模型，是微软 1993 年引入的软件组件的二进制接口标准。它可以让多种编程语言之间可以相互通信，动态的创建对象。详细内容请看 <a href="http://en.wikipedia.org/wiki/Component_Object_Model">Component Object Model</a>。</p>

<h2>什么是 ABI ？</h2>

<p>Application Binary Interface (ABI) 应用二进制接口，描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低层接口。</p>

<p>ABI涵盖了各种细节，例如：</p>

<ul>
<li>数据类型、大小以及内存布局</li>
<li>调用约定（控制着函数的参数如何传送以及如何接受返回值）</li>
<li>系统调用的编码和一个应用如何向操作系统进行系统调用</li>
<li>在一个完整的操作系统ABI中，目标文件、程序库的二进制格式等等。</li>
</ul>


<p>一个完整的ABI，像Intel二进制兼容标准(<a href="http://www.everything2.com/index.pl?node=iBCS">iBCS</a>)，允许支持它的操作系统上的程序不经修改在其他支持此ABI的操作体统上运行。</p>

<p>其他的ABI标准化细节包括<a href="http://en.wikipedia.org/wiki/Name_mangling#Name_mangling_in_C.2B.2B">C++ name mangling</a>、异常传播，同一个平台上的编译器之间的调用约定，但是不包括跨平台的兼容性。详细内容请看 <a href="http://en.wikipedia.org/wiki/Application_binary_interface">Application binary interface</a></p>

<!-- more -->


<h2>什么是引用计数？</h2>

<p>引用计数是一种资源管理的方式，经常和垃圾回收在一起讨论，引用计数策略和<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">垃圾回收</a>策略都属于资源的自动化管理 ，在引用计数中，每一个对象负责维护对象所有引用的计数值。当一个新的引用指向对象时，引用计数器就递增，当去掉一个引用时，引用计数就递减。当引用计数到零时，该对象就将释放占有的资源。COM 是使用引用计数的典型例子之一。详细内容请看 <a href="http://en.wikipedia.org/wiki/Reference_counting#COM">Reference counting</a></p>

<h2>为毛 COM 中的接口都没有虚析构函数？</h2>

<p>这是个违反直觉的设计：</p>

<ol>
<li>《Effective C++》 第三版，item 7：为多态基类声明 virtual 析构函数</li>
<li>《C++ Coding Standards &mdash; 101 Rules, Guidelines, and Best Practices》第 50 条，将基类析构函数设为公用且虚拟的，或者保护且非虚拟的</li>
</ol>


<p>学过 C++ 的人应该都知道，基类的析构函数需要声明为 virtual 或者禁止直接调用基类的析构函数，否则使用派生类初始化基类指针，当调用 delete 释放时，由于基类的析构函数不是虚函数，那么派生类的析构函数将不会被调用，造成对象的切割，派生类特有的部分将不会得到释放，造成内存或资源的泄漏。</p>

<p>COM 的核心在于：接口，它解决了二进制级复用的两个主要问题：</p>

<ol>
<li>不同的编译器对具体技术的不同实现问题和<a href="http://en.wikipedia.org/wiki/Name_mangling">name mangling</a>问题。首先，客户程序源代码中仅仅需要引入接口定义，而不同的编译器对同一接口的VTBL的结构安排是一样的，所有的组件功能的调用都通过同样的VTBL来中转。其次，由于用户通过接口来调用组件的功能，而不需要其它导出函数，所以没有<a href="http://en.wikipedia.org/wiki/Name_mangling">name mangling</a>的问题了。</li>
<li>组件仅仅导出接口，而不是导出类，避免了因组件中的类的大小发生变化(破坏了二进制兼容性)而客户程序不重新编译而继续运行时产生运行错误的问题。</li>
</ol>


<p>不同的编译器对一个接口的vptr和vtbl是一致的，但纯虚析构函数不满足，因为不同的编译器对纯虚析构函数指针在vtbl中安放的位置是不一样的，因此 COM 要实现二进制级的复用，就不能有虚析构函数。COM 使用这种方式实现了 ABI，满足了二进制兼容的问题。</p>

<p>但为了实现二进制兼容，COM 没有办法原地更新而不影响现有代码，只能每次发布新版本都引入新的 interface class，然后就有了一堆带版本号的 interface：</p>

<ul>
<li>IDocHostUIHandler，IDocHostUIHandler2</li>
<li>IDirect3D7, IDirect3D8, IDirect3D9</li>
<li>IXMLDOMDocument, IXMLDOMDocument2, IXMLDOMDocument3</li>
</ul>


<p>对于追求代码好看的人来说，这很难接受，<strong>实在是太难看了</strong>。不过这的确解决了二进制兼容的问题。</p>

<h2>为毛 COM 需要使用引用计数？</h2>

<p>首先 windows 跨 dll 释放内存会存在严重问题，因此资源的申请以及释放都要在组建内部完成。 其次，COM 组件的生命周期不能由客户来管理，因为用户可以得到指向同一个实体的多个接口型的指针，这样对多个指针执行 delete 操作，将会导致运行时错误，并且用户必须记住哪个指针对应哪个对象，并保证对每个对象仅仅调用一次 delete 操作。为了解决这个问题，COM 将这种操作从用户移到组件内部，使用了引用计数机制，同时保证了二进制兼容性。</p>

<p>COM 使用引用计数的最主要动机是在不同的语言和运行时系统中都能正常使用，用户只使用相应的接口(addRef, Release)来管理对象的生命周期，而不必知道 COM 对象的内存分配细节到底如何实现。</p>

<p>为了实现跨语言，COM 将大量的工作都放到了组件内部来做，例如指针在继承链中转换时，会使用 RTTI，但是 RTTI 是与编译器相关的，所以这种转换的动作只能放到 COM 内部，导出一个 QueryInterface 函数来执行这种转换并返回适当的指针。</p>

<p>但 COM 的引用计数代价不小，使用 COM 时最容易出现的 bug 就是引用计数不正确。而引用计数的不正确有可能是在某个不透明的第三方组件中。因此， 保证引用计数的正确性不是个容易的问题。</p>

<p>在 .Net 中，微软抛弃了<a href="http://en.wikipedia.org/wiki/Reference_counting">引用计数</a>，而引入了[垃圾回收][GC]。</p>

<h4>参考</h4>

<ul>
<li>陈硕：<a href="http://www.cnblogs.com/Solstice/archive/2011/03/09/1978024.html">C++ 工程实践(4)：二进制兼容性</a></li>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Component_Object_Model">Component Object Model</a></li>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Application_binary_interface">Application binary interface</a></li>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Reference_counting">Reference counting</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 配置 Qt 开发环境手记]]></title>
    <link href="http://bitdewy.github.io/blog/2012/12/09/qt-xcode-hello/"/>
    <updated>2012-12-09T13:10:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/12/09/qt-xcode-hello</id>
    <content type="html"><![CDATA[<p>首先，这是一个奇葩的需求，不要问为什么不用 Qt Creator，为什么不用 qmake + make，没有那么多为什么。</p>

<p>其次，准备好 Xcode 先。正文开始：</p>

<h2>安装Qt library</h2>

<p>Qt5 已经发布 RC1 版本，不过还没到不影响正常使用的程度，所以还是先用 4.8.4，下载链接点<a href="http://qt-project.org/downloads">这里</a>，MAC 版的 release 和 debug 库是分开的，可以自由选择。一路安装，下一步就 OK。</p>

<!-- more -->


<h2>生成 xcodeproj</h2>

<p>生成 xcodeproj 文件(夹)，(它是文件还是文件夹？)，先创建目录，然后进入，使用 <code>qmake -project</code> 生成 pro 文件，如果找不到 <code>qmake</code>，那就需要手工找，或者重新安装 Qt library 了，生成 pro 文件之后，就可以用 <code>qmake -spec macx-xcode</code> 生成 xcodeproj 了，然后，就没有然后了，直接用 Xcode 打开就 OK。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>localhost:~ bitdewy<span class="nv">$ </span>mkdir Projects/qt_xcode_hello  <span class="c">#建个文件夹先</span>
</span><span class='line'>localhost:~ bitdewy<span class="nv">$ </span><span class="nb">cd </span>Projects/qt_xcode_hello/    <span class="c">#进入新建的文件夹</span>
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>qmake -project    <span class="c">#生成pro文件 </span>
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>ls                <span class="c">#看看生成了啥玩意儿</span>
</span><span class='line'>qt_xcode_hello.pro
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>qmake -spec macx-xcode  <span class="c">#生成xcodeproj</span>
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>ls                      <span class="c">#再看看</span>
</span><span class='line'>qt_xcode_hello.pro        qt_xcode_hello.xcodeproj
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>open qt_xcode_hello.xcodeproj/  <span class="c">#用 Xcode 打开</span>
</span></code></pre></td></tr></table></div></figure>


<h2>配置 Xcode 工程</h2>

<p>打开个空工程，自然是毛也没有，首先工程中新建个文件，然后新建 target 选 other &ndash;> External Build System ，Product Name 就叫 qmake，Build Tool 指定到 qmake 的路径，Finish 之后，删除 Arguments 中的 <code>$(ACTION)</code>。Command + D，Duplicate 出来个 qmake copy，改名 <code>qmake -project</code>，Arguments 填上 <code>-project</code>，先run <code>qmake -project</code>，再run <code>qmake</code>，xcode 工程就和谐了，现在可以写代码跑了。</p>

<p>明白人一看就知道上面是在干什么了，新建文件，然后 <code>qmake -project</code> 更新pro文件，再 <code>qmake</code> 生成 makefile。整个过程实际上就三行 shell 搞定。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>touch qt_xcode_hello.cpp
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>qmake -project
</span><span class='line'>localhost:qt_xcode_hello bitdewy<span class="nv">$ </span>qmake
</span></code></pre></td></tr></table></div></figure>


<h2>为毛不直接生成能用的 Xcode 工程</h2>

<p>更明白的人可能要说脏话了，你妹的搞这么麻烦，生成 xcodeproj 之前补上一句 <code>touch qt_xcode_hello.cpp</code> 不就不用配置 XCode 工程了么？ bitdewy 也不是二货，为毛要配置 Xcode 工程？ 因为 Qt 的 Meta Object Compile，用到 signal 和 slot 的时候，都需要 qmake 生成 moc 文件，所以先配置一下没什么坏处这样。</p>

<h4>参考</h4>

<ol>
<li><a href="http://qtnode.net/wiki/Qt4_with_Xcode">Qt4 with Xcode</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello All]]></title>
    <link href="http://bitdewy.github.io/blog/2012/11/25/hello-world/"/>
    <updated>2012-11-25T22:18:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/11/25/hello-world</id>
    <content type="html"><![CDATA[<p>Hello world, new github blog;</p>

<h1>一级标题</h1>

<h2>二级标题</h2>

<h3>三级标题</h3>

<h4>四级标题</h4>

<h5>五级标题</h5>

<h6>六级标题</h6>

<blockquote><p>这是一个引用</p>

<blockquote><p>引用中的引用</p></blockquote></blockquote>

<p><a href="http://bitdewy.github.com">这是一个超链接</a></p>

<p>下面是一个list：</p>

<ul>
<li>第一条</li>
<li>第二条</li>
<li>第三条</li>
</ul>


<p><em>斜体</em>、<em>还是斜体</em>、<strong><em>粗+斜</em></strong>、<strong>粗体</strong></p>

<p>后面是代码-> <code>something.excute();</code> &lt;&ndash; 前面是代码</p>

<p>下面是一段代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># Fibonacci series:</span>
</span><span class='line'><span class="c"># the sum of two elements defines the next</span>
</span><span class='line'><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'><span class="k">while</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后来一张八爪萌猫大图：</p>

<!-- more -->


<p><img src="http://octodex.github.com/images/snowoctocat.jpg" alt="" /></p>

<p>全文完整代 markdown 代码如下：</p>

<pre><code>Hello world, new github blog;

#一级标题
##二级标题
###三级标题
####四级标题
#####五级标题
######六级标题

&gt; 这是一个引用
&gt;&gt; 引用中的引用

[这是一个超链接](http://bitdewy.github.com)

下面是一个list：

- 第一条
- 第二条
- 第三条

_斜体_、*还是斜体*、***粗+斜***、**粗体**

后面是代码-&gt; `something.excute();` &lt;- 前面是代码

下面是一段代码：

``` python
# Fibonacci series:
# the sum of two elements defines the next
a, b = 0, 1
while b &lt; 10:
    print b
    a, b = b, a+b
```

最后来一张八爪萌猫大图：

&lt;!-- more --&gt;
![](http://octodex.github.com/images/snowoctocat.jpg)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix 的隐藏文件是个 Bug]]></title>
    <link href="http://bitdewy.github.io/blog/2012/09/14/unix-hidden-file-is-a-bug/"/>
    <updated>2012-09-14T01:05:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/09/14/unix-hidden-file-is-a-bug</id>
    <content type="html"><![CDATA[<p>玩过 Unix/Linux 的人应该都知道，在 *nix 文件系统中，以<code>.</code>开始的文件(夹)是隐藏文件(夹)，但你可能想不到这是一个设计上的 bug。</p>

<p>8月份的时候，<a href="http://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a> 在 Google+ 上发了一篇名为 &ldquo;<a href="https://plus.google.com/101960720994009339267/posts/R58WgWwN9jp">A lession in shortcuts</a>&rdquo; 的短文，介绍了 Unix 文件系统中隐藏文件这个设计上的 bug (feature)。</p>

<p>在 Unix 文件系统设计的早期，为了导航更方便而引入了 <code>.</code> 和 <code>..</code>。当用户输入 <code>ls</code> 时会列出文件清单，所以 <a href="http://en.wikipedia.org/wiki/Ken_Thompson">Ken</a> 或 <a href="http://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis</a> 添加了一些简单的代码。当时用的是汇编，不过代码看起来应该是像这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">continue</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这比它应有的样子稍微短了一点点：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">continue</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>嘿，这很简单。</p>

<!-- more -->


<p>但产生了两个后果。</p>

<p>首先，这不是一个好的先例。一些其他懒惰的程序员用相同的简化方式引人了 bug。本应该被计算的以 <code>.</code> 开始的文件就这样被忽略掉了。</p>

<p>其次，更糟糕的是，隐藏文件的概念随之而来了。更懒惰的程序员开始往 home 目录中仍各种文件(夹)。在我写这片短文的机器上，我没有安装多少东西，但是 home 文件夹下有数以百计的隐藏文件，我甚至不知道大部分是干什么的，也不知道它们是否还有用。每次需要扫瞄 home 目录的操作都会因为这些长时间积累下来的垃圾而变慢。</p>

<p>我非常确定，隐藏文件的概念是一个无意中产生的结果。这完全就是一个错误。</p>

<p>原文地址：<a href="https://plus.google.com/101960720994009339267/posts/R58WgWwN9jp">A lession in shortcuts</a></p>

<p>PS： 上面一共出现了三个人，这三位都是神级的人物，网络上有一篇流传了很多年的文章叫做 “我心目中的编程高手” 里面介绍了 9 位神级人物，这三位大神都榜上有名。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ ORM 框架 ODB]]></title>
    <link href="http://bitdewy.github.io/blog/2012/08/21/cpp-orm-odb/"/>
    <updated>2012-08-21T22:03:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/08/21/cpp-orm-odb</id>
    <content type="html"><![CDATA[<h2>什么是 ORM？</h2>

<p>对象关系映射（Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。如今已有很多免费和收费的ORM产品，而有些程序员更倾向于创建自己的ORM工具。</p>

<p>面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。</p>

<p>简单的说：ORM相当于中继数据。通俗的说，ORM就是将对象和它们之间的关系映射成关系数据库的表，以及在数据库中它们的关系。目标就是确定一种持久化对象数据的有效策略，在考虑类之间继承结构的同时，存储各个对象的数据属性和对象间的关系。</p>

<!-- more -->


<h2>成熟的 ORM 产品</h2>

<ul>
<li>Java: 广泛使用的 ORM 框架Hibernate</li>
<li>Python: web框架 Django 中包含了 ORM</li>
<li>C++: ODB，QxOrm，LiteSQL 等</li>
</ul>


<p>这里有一个 ORM 产品的列表：<a href="http://en.wikipedia.org/wiki/List_of_object-relational_mapping_software">List of object-relational mapping software</a></p>

<h2>ODB</h2>

<p>ODB 是一个开源的，支持多平台，支持多数据库的 C++ 的 ORM 框架，可将 C++ 对象数据库表映射，进行轻松的数据库查询和操作。
下面是常规的 C++ 代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">person</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">email_</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">age_</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是ODB所需的持久化之后的 C++ 代码， ODB可以根据下面的代码自动生成数据库：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#pragma db object</span>
</span><span class='line'><span class="k">class</span> <span class="nc">person</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">odb</span><span class="o">::</span><span class="n">access</span><span class="p">;</span>
</span><span class='line'>    <span class="n">person</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma db id</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">email_</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">age_</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了上面的声明，我们就可以对 person 对象进行一系列的数据库操作了，下面是一个 SQLite 的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">odb</span><span class="o">::</span><span class="n">sqlite</span><span class="o">::</span><span class="n">database</span> <span class="n">db</span><span class="p">(</span><span class="s">&quot;people.db&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">person</span> <span class="n">john</span><span class="p">(</span><span class="s">&quot;john@doe.org&quot;</span><span class="p">,</span> <span class="s">&quot;John Doe&quot;</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
</span><span class='line'><span class="n">person</span> <span class="n">jane</span><span class="p">(</span><span class="s">&quot;jane@doe.org&quot;</span><span class="p">,</span> <span class="s">&quot;Jane Doe&quot;</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">odb</span><span class="o">::</span><span class="n">transaction</span> <span class="n">t</span><span class="p">(</span><span class="n">db</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'><span class="n">db</span><span class="p">.</span><span class="n">persist</span><span class="p">(</span><span class="n">john</span><span class="p">);</span>
</span><span class='line'><span class="n">db</span><span class="p">.</span><span class="n">persist</span><span class="p">(</span><span class="n">jane</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="n">odb</span><span class="o">::</span><span class="n">query</span><span class="o">&lt;</span><span class="n">person</span><span class="o">&gt;</span> <span class="n">person_query</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p:</span> <span class="n">db</span><span class="p">.</span><span class="n">query</span><span class="o">&lt;</span><span class="n">person</span><span class="o">&gt;</span><span class="p">(</span><span class="n">person_query</span><span class="o">::</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">))</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">jane</span><span class="p">.</span><span class="n">age</span><span class="p">(</span><span class="n">jane</span><span class="p">.</span><span class="n">age</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">db</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">jane</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">t</span><span class="p">.</span><span class="n">commit</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了 ORM 所有的数据库的操作也变得面向对象了，代码中不会夹杂着 SQL语句，写起代码来应该会更顺手了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 std::unordered_map]]></title>
    <link href="http://bitdewy.github.io/blog/2012/08/21/unordered-map/"/>
    <updated>2012-08-21T17:54:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/08/21/unordered-map</id>
    <content type="html"><![CDATA[<h2>历史</h2>

<p>在 C++ 中，第一个被广泛使用的哈希表实现是 SGI STL 中的，hash_map, hash_set, hash_multimap, hash_mutiset。
由于哈希表是非常常用的数据结构，逐渐的各厂家实现的标准库中都引入了该数据结构。</p>

<p>例如，GCC 的 lisbstdc++ , 以及微软的 MSVC 标准库。在这些公用的名字后面，有不同的实现，呃，不同的实现。它们在接口、能力、内在数据结构和支持操作的相关效率方面不同。写出使用哈希表的可移植代码是可能的，但不可能像使用标准库中的容器一样容易。（知道标准的重要性了吧。）好在 <code>hash_*</code> 这一组类加入了 C++ TR1 , 可惜由于名字被非标准的各家实现占用，只能退而求其次，改名为 <code>unordered_*</code>。</p>

<p>C++11 中，不排序的关联容器已经正式进入标准库。现在再选择的话，可以毫不犹豫的放弃非标准的 <code>hash_*</code> 而选择标准库中的 <code>unordered_*</code> 系类了。boost &lt;<a href="http://www.boost.org/doc/libs/1_53_0/boost/unordered_map.hpp">boost/unordered_map.hpp</a>> 中同样有实现。</p>

<!-- more -->


<h2>选择合适的数据结构</h2>

<p>对于一个程序员来说，分析具体的问题，选择适合的数据结构，有时候比算法更重要。好的数据结构可以帮助程序员解决大部分效率问题。Soctt Meyers 在《Effective STL》的第一条就提到：“仔细选择你的容器”。</p>

<p><code>std::unordered_map</code> 与 <code>std::map</code> 的区别是, <code>std::map</code> 是按照 <code>operator&lt;</code> 比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对 map 进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照 <code>operator&lt;</code> 定义的大小排序。</p>

<p>而 <code>std::unordered_map</code> 是计算元素的 hash 值，根据 hash 值判断元素是否相同。所以，对 <code>unordered_map</code> 进行遍历，结果是无序的。</p>

<p>用法的区别是，<code>std::map</code> 的 key 需要定义 <code>operator&lt;</code> 。 而 <code>std::unordered_map</code> 需要定义 <code>hash_value</code> 函数并且重载 <code>operator==</code>。
对于内置类型，如 <code>std::string</code>, 这些都不用操心。对于自定义的类型做 key, 就需要自己重载 <code>operator&lt;</code> 或者 <code>hash_value()</code> 了。</p>

<p>选择时,请基于时间和空间的综合考虑, <em>当不关心空间, 也不需要结果排好序时, 可以选择 <code>unordered_map</code> 获得更好的时间效率。</em></p>

<p><code>std::map</code> 对应与 java 中的 <code>TreeMap</code>, 而 <code>std::unordered_map</code> 对应于 java 中的 <code>HashMap</code>. 对于标准库中的散列表无法取名为 <code>hash_*</code>, 只能叫 <code>unordered_*</code>, 我只能说… 标准库进展太慢，结果好白菜都让猪给拱了……遗憾啊……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] GotW #104: Smart Pointers, Part 2 (Difficulty: 5/10)]]></title>
    <link href="http://bitdewy.github.io/blog/2012/07/15/gotw104/"/>
    <updated>2012-07-15T16:28:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/07/15/gotw104</id>
    <content type="html"><![CDATA[<p>原文在这里 <a href="http://herbsutter.com/gotw/_104/">GotW #104: Smart Pointers, Part 2 (Difficulty: 5/10)</a></p>

<p>当你正在研究最近新加入的项目的代码时，你发下了下面的工厂方法的声明：</p>

<p><code>widget* load_widget( widget::id desired );</code></p>

<h2>JG 问题</h2>

<p>1. 返回值的类型有什么问题？</p>

<h2>Guru 问题</h2>

<p>2. 返回值的推荐类型是是什么？ 解释你的答案，包括任何的权衡。</p>

<p>3. 你希望更改返回值的类型为问题 #2 中推荐的类型，但是你担心破坏了原有代码的函数调用的兼容性；重新编译现有的函数调用是可行的，但修改所有的函数调用就……。然后你灵光一闪，意识到这是一个相当新的项目，所有的代码都使用现代 C++ 惯用法，然后你继续修改返回值类型，而没有一点担心，知道重构仅仅需要一点点或者更不不需要更改调用函数的代码。是什么让你如此自信？</p>

<!-- more -->


<h2>解决方案</h2>

<p><strong>1. 返回值的类型有什么问题？</strong></p>

<p>第一，我们能够从两行的问题描述中知道些什么？</p>

<ul>
<li>我们说过，load_widget 是一个工厂方法。它通过“loading” 生产出一个对象，然后把它返回给调用者。由于返回值类型是指针类型，所以结果可能是 null。</li>
<li>调用者会适当的使用该对象，可能是调用它的成员函数，或者把它传给其他的函数，等等。这是不安全的，除非调用者确保该对象存活——调用者管理对象的生命周期；或者共享所有权，如果工厂方法负责维护内部的强引用和弱引用的话。</li>
<li>因为调用者持有或共享所有权，它必须在对象不再需要时做一些工作。如果是直接持有，掌管生命周期的话，它应该销毁该对象，通常是一个 delete 或者也可能是类似于 unload_widget 的一个函数调用。不然的话，如果是共享所有权，它应该减少共享的引用计数。</li>
</ul>


<p>不幸的是，返回一个 widget* 有两个主要的问题。第一，默认情况下它是不安全的，因为默认的操作模式（比如不保存返回值）会造成 widget 泄露：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 1: Leak by default. Really, this is just so 20th-century...</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span><span class="o">*</span> <span class="n">load_widget</span><span class="p">(</span> <span class="n">widget</span><span class="o">::</span><span class="n">id</span> <span class="n">desired</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="o">:::</span>
</span><span class='line'>
</span><span class='line'><span class="n">load_widget</span><span class="p">(</span> <span class="n">some_id</span> <span class="p">);</span> <span class="c1">// oops</span>
</span></code></pre></td></tr></table></div></figure>


<p>Example 1 的代码可以干净的编译，运行，（不）开心的泄露 widget。</p>

<p>第二，函数签名传达出来的信息太少了，“一个 widget ？是的，开始吧！享受它。”文档中会指出调用者应该持有该对象，掌管对象的生命周期（或者其它），但是函数声明没有给出这些信息——它掌管对象的生命周期，还是共享所有权，到底是哪个？阅读文档然后记下它吧，因为函数声明没办法告诉我们到底是哪种情况。</p>

<p><strong>2. 返回值的推荐类型是是什么？ 解释你的答案，包括任何的权衡。</strong></p>

<p>推荐的返回值类型是 unique_ptr 或者也可能是 shared_ptr。注意现在 C++ 中返回值类型是很平常的了，但是还有一点不太合适，它改变了语义，因为返回指针类型允许返回 null （无对象），而返回一个值得话不能轻易地处理这个语义，除非加个类似于 optional&lt;> 的东西。</p>

<p><em>准则：工厂方法应该默认返回 unique_ptr 类型，或当需要共享所有权时使用 shared_ptr 类型。</em></p>

<p>这同时解决了上面两个问题：安全，自描述。</p>

<p>第一，考虑如何立即解决 Example 1 中的安全问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 2: Clean up by default. Much better...</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'>
</span><span class='line'><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">load_widget</span><span class="p">(</span> <span class="n">widget</span><span class="o">::</span><span class="n">id</span> <span class="n">desired</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="o">:::</span>
</span><span class='line'>
</span><span class='line'><span class="n">load_widget</span><span class="p">(</span> <span class="n">some_id</span> <span class="p">);</span> <span class="c1">// cleans up</span>
</span></code></pre></td></tr></table></div></figure>


<p>Example 2 的代码可以干净的编译，运行，开心的清理 widget。但它不仅仅在这种情况下正确——构造也是正确的，因为现在没有办法去制造出一个导致泄露的错误。</p>

<p>画外音：可能会有人说，“难道不会有人一直写 load_widget(some_id).release()？”如果这些人发神经的话，当然可以；正确的答案是，“不要这么做。” 记住我们关心的是什么——bug 和错误，而不是精心设计的犯罪——显然病态的滥用属于后一类。这与在 C# 的 using 块中显式的调用 Dispose，或在 Java 的 try-with-resources 块中调用 close，没什么区别，不会比它们存在更多的类型安全问题。</p>

<p>如果清理工作不是一个单独的 delete 语句，那么该怎么做？简单：使用自定义的 deleter。锦上添花的是例子中的工厂方法知道使用哪个 deleter，并且能够在构造返回值的时候确定；调用者不需要关心这些，尤其是，当调用者使用 auto 关键字作为返回值类型的时候。</p>

<p>第二，这是自描述的：一个返回值类型是 unique_ptr 的函数，清楚的说明这是一个纯“source” 函数，如果一个函数的返回值是 shared_ptr，那么清楚的说明它返回的是一个共享的所有权和/或一个观察者。</p>

<p>最后，为什么默认情况下，如果你不需要表达共享所有权的语义时，优先考虑使用unique_ptr？因为不管对于性能还是正确性来说，这都是对的事情，并且也给调用者留下了一些余地：</p>

<ul>
<li>返回值类型为 unique_ptr 表示返回唯一所有权，这是纯“source” 工厂方法的标准形式。</li>
<li>unique_ptr 的性能不会被打败——转移一个 unique_ptr 和转移/复制一个原始指针一样的廉价。</li>
<li>如果调用者想要通过 shared_ptr 来管理对象的声明周期，可以通过隐式的转移操作来转换为 shared_ptr 类型——不需要显式的 std::move 因为编译器知道返回值是一个临时对象。</li>
<li>如果调用者想要用其他的办法来维护对象的生命周期，可以通过调用 .release() 来得到原始指针。这是有用的，但是 shared_ptr 没有。</li>
</ul>


<p>看下面的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 2, continued</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="k">auto</span> <span class="n">up</span> <span class="o">=</span> <span class="n">load_widget</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                              <span class="c1">// unique_ptr (by default)</span>
</span><span class='line'><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">load_widget</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>                <span class="c1">// shared_ptr (if desired)</span>
</span><span class='line'><span class="n">my</span><span class="o">::</span><span class="n">smart_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">msp</span> <span class="o">=</span> <span class="n">load_widget</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">release</span><span class="p">();</span>  <span class="c1">// your own smart pointer (if desired)</span>
</span><span class='line'><span class="n">widget</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">load_widget</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">release</span><span class="p">();</span>                  <span class="c1">// or even old-school manual management (not recommended)</span>
</span><span class='line'><span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，如果工厂方法持有一些共享所有权的对象，不论是通过内部的 shared_ptr 还是 weak_ptr，返回 shared_ptr。这时调用者只能被迫使用 shared_ptr，但在这种情形下，这样是合适的。</p>

<p><strong>3. 你希望更改返回值的类型为问题 #2 中推荐的类型，但是你担心破坏了原有代码的函数调用的兼容性；重新编译现有的函数调用是可行的，但修改所有的函数调用就……。然后你灵光一闪，意识到这是一个相当新的项目，所有的代码都使用现代 C++ 惯用法，然后你继续修改返回值类型，而没有一点担心，知道重构仅仅需要一点点或者更不不需要更改调用函数的代码。是什么让你如此自信？</strong></p>

<p>现代可移植的 C++ 代码使用 unique_ptr，shared_ptr，和 auto。返回 unique_ptr 类型可以和这三个协同工作，返回 shared_ptr 只能与后两个协同工作。</p>

<p>如果调用者接受返回值时使用了 auto，例如 <code>auto w = load_widget(whatever)</code>；那么类型自然会是正确的，正常的解引用也可以工作，只有在调用者试图把它存储到一个其他类型的非局部变量中时代码才会出问题。</p>

<p><em>准则：优先考虑使用 auto 声明变量，除非需要显式的类型转换。它更短，而且可以避免类型轻微更改时引起的不必要的波澜。</em></p>

<p>否则：如果调用者没有使用 auto ，那么它应该已经使用返回结果初始化了 unique_ptr 或 shared_ptr， 因为现代 C++ 代码不使用非参数的原始指针变量（下次详细讨论）。每种情况下，返回一个 unique_ptr 可以工作：一个 unique_ptr 可以无缝的转换成这些类型，如果语义上需要返回共享的所有权，那么调用者应该已经使用了 shared_ptr，这样的话，再次工作还会是正常的。（可能比之前的更好，因为为了让原本的返回原始指针的版本正常工作，返回类型大概会被 enable_shared_from_this 所胁迫，但如果我们显示的返回一个 shared_ptr 的话，这些就是不需要的了。）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] GotW #103: Smart Pointers, Part 1 (Difficulty: 3/10)]]></title>
    <link href="http://bitdewy.github.io/blog/2012/07/14/gotw103/"/>
    <updated>2012-07-14T19:14:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/07/14/gotw103</id>
    <content type="html"><![CDATA[<p>原文在这里 <a href="http://herbsutter.com/gotw/_102/">GotW #103: Smart Pointers, Part 1 (Difficulty: 3/10)</a></p>

<h2>JG 问题</h2>

<p>1. 什么情况下你会使用 shared_ptr 和 unique_ptr ？尽可能多的列出你能想到的情况。</p>

<h2>Guru 问题</h2>

<p>2. 为什么要使用 make_shared 来构造 shared_ptr 对象？请解释。</p>

<p>3. 如何处理 auto_ptr ？</p>

<!-- more -->


<h2>解决方案</h2>

<p><strong>1. 什么情况下你会使用 shared_ptr 和 unique_ptr ？尽可能多的列出你能想到的情况。</strong></p>

<p>当不确定时，优先考虑使用 unique_ptr，你可以在之后有需要的时候转换成 shared_ptr。如果你一开始就可以确定需要共享所有权，那么你可以直接使用 make_shared（看下面的 #2）来构造 shared_ptr 对象。</p>

<p>“当不确定时，优先考虑使用 unique_ptr” 的主要原因包括一下几点：</p>

<p><strong>语义</strong>：选择正确的智能指针，尽可能的直接表达你的意图，和（当前）你所需要的。如果你正在创建一个对象并且不需要共享所有权（当时看来），使用表达唯一所有权的 unique_ptr，你仍然可以把它放到容器中，（例如：<code>vector&lt;unique_ptr&lt;widget&gt; &gt;</code>），同时也可以做大部分原始指针能做的事情，而且更安全。如果之后你又需要共享所有全，那么你通常都可以直接把 unique_ptr 转换为 shared_ptr。</p>

<p><strong>效率</strong>：unique_ptr 比 shared_ptr 有更好的性能，因为它不需要维护一个引用计数和控制块；unique_ptr 的转移几乎和原始指针一样廉价。如果你没有比你需要的要求更多，那么就不会招致额外的开销。</p>

<p><strong>适应性</strong>：如果你一开始就使用 unique_ptr，你通常稍后可以把它转换成 shared_ptr，或者甚至一个原始指针。（通过 get 或者 release）。</p>

<p><strong>2. 为什么要使用 make_shared 来构造 shared_ptr 对象？请解释。</strong></p>

<p>shared_ptr 的实现需要维护被 shared_ptrs 和 weak_ptrs 引用的对象的内部信息控制块。特别的，内部信息包含的不是一个引用计数，而是两个：</p>

<ul>
<li>一个“强引用”计数，用来记录当前有多少个存活的 shared_ptrs 正持有该对象。共享的对象会在最后一个强引用离开的时候销毁（也可能是释放）。</li>
<li>一个“弱引用”计数，用来记录当前有多少个正在观察该对象的 weak_ptrs。当最后一个弱引用离开的时候，共享的内部信息控制块会被销毁和释放（共享的对象也会被释放，如果还没有释放的话）。</li>
</ul>


<p>如果你通过使用原始的 new 表达式分配对象，然后传递给 shared_ptr，shared_ptr 的实现没有办法选择，而只能单独的分配控制块，看下面的 Example 2(a) 和 Fugure 2(a)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 2(a): Separate allocation</span>
</span><span class='line'><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">widget</span><span class="p">();</span>
</span><span class='line'><span class="n">shared_ptr</span> <span class="n">sp1</span><span class="p">{</span> <span class="n">p</span> <span class="p">},</span> <span class="n">sp2</span><span class="p">{</span> <span class="n">sp1</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://y6bhba.bay.livefilestore.com/y1pDu8kORu85CKSKHFVBvapxrccVoMAjc8W0d6mScWwunuhqV8n25QZKgZhM6MPtFGV1c6dPgjil7g/sharedptr1.png" alt="" /></p>

<p>我们应该在此避免两次单独的分配，如果你使用 make_shared 来分配对象，那么shared_ptr 的构造就仅需要一步，他的实现可以把两次分配合并成一次分配，看下面的 Example 2(b) 和 Figure 2(b)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 2(b): Single allocation</span>
</span><span class='line'><span class="k">auto</span> <span class="n">sp1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="p">(),</span> <span class="n">sp2</span><span class="p">{</span> <span class="n">sp1</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://y6yska.bay.livefilestore.com/y1p-Y0XAkcMZMrSdxkTa85nShcDkVKvqhMTFVGSDc0jURLybPXTGHPdWv9CZGgcGmvZwQQvd6Y1Qdg/sharedptr2.png" alt="" /></p>

<p>通常情况下，一个单独的函数调用可以表达的比你想要的东西更多，你给了系统一个更好的机会去以更好的效率完成这项工作。这是毫无疑问的，使用单独的函数调用 make_shared 代替 new widget() 和 shared_ptr(widget *)，就好像当你插入 100 个元素到 vector 中时，使用单独的一个指定插入区间的函数调用 v.insert(first, last) 来代替调用 100 次 v.insert(value) 一样。</p>

<p><strong>3. 如何处理 auto_ptr ？</strong></p>

<p>auto_ptr 是最……的特性，它在 C++ 还没有转移语义的时候，勇敢的尝试创建一个 unique_ptr。</p>

<p>现在 auto_ptr 是被反对的，并且不应该在新的代码中使用它。如果你有机会，应该试着在你的代码中全局替换，把 auto_ptr 都替换成 unique_ptr；大部分使用的地方会像之前一样工作，而且它可能暴露出问题（比如编译期错误）或者修复（悄悄地）一个或两个你自己都不知道的 bug。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] GotW #102: Exception-Safe Function Calls (Difficulty: 7/10)]]></title>
    <link href="http://bitdewy.github.io/blog/2012/07/07/gotw102/"/>
    <updated>2012-07-07T00:06:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/07/07/gotw102</id>
    <content type="html"><![CDATA[<p>[这是 <a href="http://www.gotw.ca/gotw/056.htm">GotW #56</a> 的 C++11 更新版]</p>

<p>原文在这里 <a href="http://herbsutter.com/gotw/_102/">GotW #102: Exception-Safe Function Calls (Difficulty: 7/10)</a></p>

<h2>JG问题</h2>

<p>1. 考虑下面的语句，函数 f，g，h 和表达式 expr1 还有 expr2，它们的执行顺序是什么？假设 expr1 和 expr2 不包含函数调用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 1(a)</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Example 1(b)</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="n">g</span><span class="p">(</span> <span class="n">expr1</span> <span class="p">),</span> <span class="n">h</span><span class="p">(</span> <span class="n">expr2</span> <span class="p">)</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Guru问题</h2>

<p>2. 当你翻看公司的陈年老代码的时候，你发现了如下的代码片段：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 2</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// In some header file:</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T1</span><span class="o">*</span><span class="p">,</span> <span class="n">T2</span><span class="o">*</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// At some call site:</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="k">new</span> <span class="n">T1</span><span class="p">,</span> <span class="k">new</span> <span class="n">T2</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码包含潜在的异常安全问题吗？请解释。</p>

<p>3. 当你继续查看的时候，你发现了有人不喜欢 Example 2 的代码，因为上面那个问题提到的文件的后续版本已经被改成了下面这个样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 3</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// In some header file:</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// At some call site:</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">{</span> <span class="k">new</span> <span class="n">T1</span> <span class="p">},</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">{</span> <span class="k">new</span> <span class="n">T2</span> <span class="p">}</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这比之前的 Example 2 的版本有哪些改进，如果有的话？ 异常安全问题是否仍然存在？请解释。</p>

<p>4. 如何写出一个 make_unique 使它能够解决 Example 3 中的问题，并能以如下方式使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 4</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// In some header file:</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// At some call site:</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h2>解决方案</h2>

<p><strong>1. 考虑下面的语句，函数 f，g，h 和表达式 expr1 还有 expr2，它们的执行顺序是什么？假设 expr1 和 expr2 不包含函数调用。</strong></p>

<p>答案遵循下面的基本规则：</p>

<ul>
<li>函数调用之前，所有的参数必须都已经求值。这也包括任何有副作用的作为函数参数的表达式。</li>
<li>当函数开始执行的时候，在调用该函数的代码中不会有任何表达式开始或继续求值，直到函数调用结束。函数调用永远都不会交叉执行。</li>
<li>用作函数参数的表达式可能以任意的顺序求值，包括交叉执行，除非另有其他规则限制。</li>
</ul>


<p>在标准 C++11 中，这些线程内的顺序约束由“sequenced before” 关系决定，它约束了编译器和硬件在单线程执行中的行为。取代了旧的 C/C++ “sequence point”（序列点） ，但它们的目的是相同的。</p>

<p>给出了这些规则，让给我看看在我们的例子中发生了什么：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 1(a)</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在例子 1(b) 中，函数和表达式可能以任何的顺序来计算，考虑下面的规则：</p>

<ul>
<li>epxr1 必须在 g 调用之前计算。</li>
<li>expr2 必须在 h 调用之前计算。</li>
<li>g 和 h 必须在 f 调用之前完成。</li>
</ul>


<p>表达式 expr1 和 expr2 的求值有可能交错，但不可能与函数调用交错。举个例子，无论是表达式 expr2 的一部分，还是函数 h 的执行，都不可能发生在 g 的执行过程中；但是，h 的调用有可能发生在 g 调用之前，也可能是 g 调用之后。</p>

<h2>一些函数调用的异常安全问题</h2>

<p><strong>2. 当你翻看公司的陈年老代码的时候，你发现了如下的代码片段：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 2</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// In some header file:</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T1</span><span class="o">*</span><span class="p">,</span> <span class="n">T2</span><span class="o">*</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// At some call site:</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="k">new</span> <span class="n">T1</span><span class="p">,</span> <span class="k">new</span> <span class="n">T2</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>这段代码包含潜在的异常安全问题吗？请解释。</strong></p>

<p>是的，这有一些潜在的异常安全问题。</p>

<p>简要归纳：像 new T1 这样的调用，很简单，一个 new 表达式。回忆一下 new 表达式所做的事情（简单起见，忽略定位new 和数组形式的 new，因为这个我们讨论的没有太大关系。）</p>

<ul>
<li>分配内存</li>
<li>在分配的内存中构造一个新的对象；然后</li>
<li>如果由于异常而构造失败，分配的内存将被释放</li>
</ul>


<p>所以每个 new 表达式本质上是两个函数调用：一个是 operator new（可能是全局的，或者这个类型所提供的），另一个是构造函数。</p>

<p>在 Example 2 中，考虑如果编译器生成的代码将按照下面的步骤执行时，将会发生什么：</p>

<ol>
<li>给 T1 分配内存</li>
<li>构造 T1</li>
<li>给 T2 分配内存</li>
<li>构造 T2</li>
<li>调用函数 f</li>
</ol>


<p>它存在的问题是：如果第 3 步或第 4 步由于异常而失败了，C++ 标准没有要求 T1 对象必须销毁和释放内存，这是典型的内存泄漏，很明显这不是件好事。</p>

<p>另一个可能的执行顺序：</p>

<ol>
<li>给 T1 分配内存</li>
<li>给 T2 分配内存</li>
<li>构造 T1</li>
<li>构造 T2</li>
<li>调用函数 f</li>
</ol>


<p>这个执行顺序不仅仅含有一个，而是两个异常安全的问题并且他们会产生不同的结果：</p>

<ul>
<li>如果第 3 步由于异常而失败，那么给 T1 分配的内存将自动释放（第 1 步会回滚），但是标准没有要求释放给 T2 分配的内存，内存泄漏了。</li>
<li>如果第 4 步由于异常而失败，T1 的内存已分配且构造完成，但是标准没有要求销毁和释放它的内存，T1 泄漏了。</li>
</ul>


<p>“呃”，你可能想知道，“为什么这个异常安全漏洞会存在？为什么标准不要求清理时编译器做正确的事来防止这个问题？”</p>

<p>C++ 拥有 C 语言的灵魂——效率，因此 C++ 标准允许编译器某些情形下自行决定表达式的求值顺序，因为这可以允许编译器进行可能的性能优化。为了保证这一点，一些表达式求值规则不是异常安全的，所以如果你想要写异常安全的代码，那么你就需要知道它，并且避免它。</p>

<p>幸运的是，你可以做一些简单的工作来避免这个问题。也许像 unique_ptr 这样的智能指针会有帮助？</p>

<p><strong>3. 当你继续查看的时候，你发现了有人不喜欢 Example 2 的代码，因为上面那个问题提到的文件的后续版本已经被改成了下面这个样子：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 3</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// In some header file:</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// At some call site:</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">{</span> <span class="k">new</span> <span class="n">T1</span> <span class="p">},</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">{</span> <span class="k">new</span> <span class="n">T2</span> <span class="p">}</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>这比之前的 Example 2 的版本有哪些改进，如果有的话？ 异常安全问题是否仍然存在？请解释。</strong></p>

<p>这个代码试图把问题直接丢给 unique_ptr。很多人相信智能指针是异常安全的万能药，是试金石和护身符，只要有它的出席，就能解决编译器的消化不良。</p>

<p>不是的。没有任何改变。Example 3 仍然不是异常安全的，和之前的原因一模一样。</p>

<p>特别的，只有当资源真的由 unique_ptr 接管时，这些资源才是安全的，但是当还没有到达 unique_ptr 的构造函数时，同样的问题还会存在。因为上面提到的两种执行顺序还是有可能的，只是在调用函数 f 之前需要调用 unique_ptr 的构造函数而已。一个例子：</p>

<ol>
<li>给 T1 分配内存</li>
<li>构造 T1</li>
<li>给 T2 分配内存</li>
<li>构造 T2</li>
<li>构造 unique_ptr<T1></li>
<li>构造 unique_ptr<T2></li>
<li>调用函数 f</li>
</ol>


<p>在上面的情况下，如果第 3 步或第 4 步异常了，相同的问题仍会存在，下面的也是一样：</p>

<ol>
<li>给 T1 分配内存</li>
<li>给 T2 分配内存</li>
<li>构造 T1</li>
<li>构造 T2</li>
<li>构造 unique_ptr<T1></li>
<li>构造 unique_ptr<T2></li>
<li>调用函数 f</li>
</ol>


<p>还是一样，如果第 3 步或第 4 步抛出异常，还是会存在异常安全问题。</p>

<p>幸运的是，这不是 unique_ptr 的问题，只是 unique_ptr 的误用而已。让我们看看如果更好的使用它。</p>

<h2>make_unique</h2>

<p><strong>4. 如何写出一个 make_unique 使它能够解决 Example 3 中的问题，并能以如下方式使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Example 4</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// In some header file:</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// At some call site:</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>基本思路：</p>

<ul>
<li>我们需要同一个线程中的函数调用不要产生交错，所以我们使用函数来完成分配、构造和构造 unique_ptr 对象的的工作。</li>
<li>因为我们需要函数可以配合任何类型工作，所以我们需要使用函数模板。</li>
<li>由于需要通过 make_unique 传递构造参数给需要构造的对象，我们要使用 C++11 的完美转发，把参数传递给 make_unique 函数中的 new 表达式。</li>
<li>shared_ptr 已经有一个类似的设施 std::make_shared，为了一致性我们把这个函数叫做 make_unique。（C++ 11 中没有 make_unique 是某种程度上的疏忽，几乎可以确定，不就的将来它会被添加到标准中，在这段时间内，我们使用下面的实现。）</li>
</ul>


<p>把上面的要素组装到一起，我们可以得到：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_unique</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">)</span> <span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这解决了异常安全问题，任何的执行顺序都不会造成资源泄露，因为现在我们只有两个函数，并且我们知道他们必须一个一个的执行。考虑下面的求值顺序：</p>

<ol>
<li>调用函数 make_unique<T1></li>
<li>调用函数 make_unique<T2></li>
<li>调用函数 f</li>
</ol>


<p>如果第 1 步异常了，不会产生泄露因为 make_unique 是异常安全的。</p>

<p>如果第 2 步异常了，那么第一步构造出来的 unique_ptr<T1> 临时对象会被清理掉吗？</p>

<p>是的，它会被清理。可能有人会认为：这难道和 Example 2 是不一样的吗？而 Example 2 是不能正确清理的。不，这和 Example 2 是不同的。因为在这里，unique_ptr<T1> 事实上是一个临时对象，而临时对象的销毁在标准中是明确说明的。在标准 12.2/3 节中（从 C++98 之后没有更改过）：<em>在表达式求值完成之后临时对象将被销毁，包括他们的创建点。即使表达式求值以异常而终止时，也是一样。</em></p>

<p><strong>准则：</strong></p>

<ul>
<li>优先考虑使用 make_shared 来构造 shared_ptr 对象来管理内存，用 make_unique 来构造 unique_ptr 对象。</li>
<li>虽然现在标准 C++ 中还没有 make_unique，这是一个疏忽，几乎可以确定它最终会加入到标准中。在这期间，使用上面的版本，你的代码会向前兼容 C++ 标准的。</li>
<li>避免直接使用 new 或其他的原始的分配内存的方法。取而代之的是，使用类似于 make_unique 的工厂方法，它会包装原始的内存分配然后直接传给需要接管资源的对象，通常是智能指针，它会自动清理资源，或者其他析构函数负责安全的删除资源的对象。</li>
</ul>


<h2>感谢</h2>

<p>这个问题是在 comp.lang.c++.moderated 的讨论中提出的。解决方案中的观点是由 James Kanze, Steve Clamage, 和 Dave Abrahams 在该讨论以及其他讨论和私人邮件中提出的。同时也感谢 Clark Nelson，他起草了 C++11 中的“sequenced before” 的概念，并阐明了其中的疑问。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] GotW #101: Compilation Firewalls, Part 2 (Difficulty: 8/10)]]></title>
    <link href="http://bitdewy.github.io/blog/2012/07/02/gotw101/"/>
    <updated>2012-07-02T02:38:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/07/02/gotw101</id>
    <content type="html"><![CDATA[<p>原文在这里 <a href="http://herbsutter.com/gotw/_101/">GotW #101: Compilation Firewalls, Part 2 (Difficulty: 8/10)</a></p>

<h2>Guru问题</h2>

<p><a href="http://bitdewy.github.com/blog/2012/06/30/gotw100/">GotW #100</a> 展示了仅使用标准 C++11 的 Pimpl 惯用法最佳实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// in header file</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">widget</span><span class="p">();</span>
</span><span class='line'>    <span class="o">~</span><span class="n">widget</span><span class="p">();</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">impl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">impl</span><span class="o">&gt;</span> <span class="n">pimpl</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// in implementation file</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span><span class="o">::</span><span class="n">impl</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// :::</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span><span class="o">::</span><span class="n">widget</span><span class="p">()</span> <span class="o">:</span> <span class="n">pimpl</span><span class="p">{</span> <span class="k">new</span> <span class="n">impl</span><span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span> <span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="n">widget</span><span class="o">::~</span><span class="n">widget</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// or =default</span>
</span></code></pre></td></tr></table></div></figure>


<p>有办法把 Pimpl 模式包装到库中使得 widget 类更容易实现吗？如果可以？应该怎么做？试着让 widget 的实现更方便更简洁，让编译器默认生成的函数有正确的行为，或者当 widget 的实现存在问题时给出编译错误。</p>

<!-- more -->


<h2>解决方案</h2>

<p>是的，我们有一些办法。可能最简单的办法之一是使用一个类似 unique_ptr 的 helper 类，但是我还是会把它叫做 pimpl 而不是 pimpl_ptr 因为他还要负责分配和释放 impl 对象。</p>

<p>让我们朝着我们的目标前进，即简化 widget 的代码。由于 Pimpl 惯用法同时影响可见类的定义的头文件和隐藏私有部分的实现的头文件，我们把 Pimpl 也放到两个文件中。</p>

<p>首先，我们引入一个 pimpl_h.h 然后添加 <code>pimpl&lt;myclass::impl&gt;</code> 类型的数据成员。然后在我们的实现文件中引入 pimpl_impl.h 然后定义我们的 impl 类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// in header file</span>
</span><span class='line'><span class="cp">#include &quot;pimpl_h.h&quot;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">impl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pimpl</span><span class="o">&lt;</span><span class="n">impl</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// in implementation file</span>
</span><span class='line'><span class="cp">#include &quot;pimpl_impl.h&quot;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span><span class="o">::</span><span class="n">impl</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么这比手工实现的 Pimpl 惯用法更好？</p>

<ul>
<li>首先，代码变得简单了，因为我们头文件中减少了代码：在手工实现的版本中，你还需要声明构造函数，然后在实现文件中显式的分配 impl 对象。你应该还记得需要声明析构函数，然后在实现文件中显式的实现，<a href="http://bitdewy.github.com/blog/2012/06/30/gotw100/">GotW #100</a> 中已经解释过这个晦涩的问题。</li>
<li>第二，代码更健壮了：在手工实现的版本中，如果你忘了实现非内联的析构函数，Pimpl 类将能够独立的编译，但是如果调用者试图销毁这个对象时，将会的到一个有用的编译错误“无法生成析构函数，由于 impl 呃，你知道的，不是完整类型”，这可能会使代码调用者挠着头离开，然后找你检查一下这到底是什么问题。</li>
</ul>


<p>pimpl<T> 模板会完成这些工作，不过，我们还要再加点料：它在可见类和实现类之间而不知道任何一个的定义，并且它把所有东西都连接到一起，完成了那些可见类和实现类可能去要做的事。幸运的是，没有什么是 pimpl<T> 不能控制的。</p>

<p>现在，我们来看看 pimpl_h.h 和 pimpl_impl.h 把我们的思绪连接起来。</p>

<h4>pimpl_h.h : 可见类需要的东西</h4>

<p>pimpl_h.h 提供不透明的 impl 和它的指针（在这里，我们使用 m 代替 pimpl）。它同时也声明两个构造函数和一个析构函数，这些将在 pimpl_impl.h 中以非内联的方式实现，并掌管 impl 对象的生命周期。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// pimpl_h.h</span>
</span><span class='line'><span class="cp">#ifndef PIMPL_H_H</span>
</span><span class='line'><span class="cp">#define PIMPL_H_H</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;memory&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">pimpl</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">pimpl</span><span class="p">();</span>
</span><span class='line'>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span> <span class="n">pimpl</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">);</span>
</span><span class='line'>    <span class="o">~</span><span class="n">pimpl</span><span class="p">();</span>
</span><span class='line'>    <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">();</span>
</span><span class='line'>    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>第二个构造函数提供了一种给 impl 对象传递初始化参数的方式。由于 pimpl 对 impl 一无所知，这时候完美转发立功了！这是一个有意思的惯用法，它会逐渐的被人所熟知：所有的参数用使用 (&amp;&amp;) 右值引用，然后传递参数时使用 std::forward，这些会在 pimpl_impl.h 中实现。</p>

<h4>pimpl_impl.h:提供内部实现</h4>

<p>pimpl_impl.h 提供创建和销毁 impl 对象的其他内部实现，就像上面说的，下面我们将看到完美转发的实现部分。</p>

<p>首先，如果你知道非内联的完美转发模板声明语法，给你发一朵小红花。注意构造函数需要的模板不是一个，而是两个，一个是 pimpl 模板参数，另一个是构造函数的参数的模板参数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// file pimpl_impl.h</span>
</span><span class='line'><span class="cp">#ifndef PIMPL_IMPL_H</span>
</span><span class='line'><span class="cp">#define PIMPL_IMPL_H</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;utility&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">pimpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pimpl</span><span class="p">()</span> <span class="o">:</span> <span class="n">m</span><span class="p">{</span> <span class="k">new</span> <span class="n">T</span><span class="p">{}</span> <span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">pimpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pimpl</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span><span class="n">args</span> <span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">m</span><span class="p">{</span> <span class="k">new</span> <span class="n">T</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">}</span> <span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">pimpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">pimpl</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">T</span><span class="o">*</span> <span class="n">pimpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">T</span><span class="o">&amp;</span> <span class="n">pimpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>每个构造函数都可以在不知道 impl 类型细节的时候创建出一个新的 impl 对象。类型只要调用者在其他地方定义就可以了。</p>

<p>转发构造函数可以简单的转发参数，<code>pimpl&lt;widget&gt;::impl</code> 类型可以幸福的提供带着任何参数的构造函数，可见类 widget 的构造函数可以接受这些参数然后安全的正确的转发给 impl，而不需要 pimpl&lt;>。所有需要的“智慧”的东西都由标准中的&amp;&amp;右值引用和 <code>std::forward</code> 提供——这是避免左值需要了解太多右值业务的漂亮的标准实现，而且它能很好地工作。</p>

<h2>注解</h2>

<p>变长模板参数使得转发构造函数写起来比固定模板参数更容易。如果你使用的编译器支持右值语法但是还不支持变长模板参数，有仍然可以实现相同的效果，只是需要一些重复——决定你准备支持的参数个数，然后写一组模板构造函数的重载，来代替单个变长模板构造函数。前三个看起来可能是这个样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Arg1</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">pimpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pimpl</span><span class="p">(</span> <span class="n">Arg1</span><span class="o">&amp;&amp;</span> <span class="n">arg1</span> <span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">m</span><span class="p">(</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Arg1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Arg2</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">pimpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pimpl</span><span class="p">(</span> <span class="n">Arg1</span><span class="o">&amp;&amp;</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">Arg2</span><span class="o">&amp;&amp;</span> <span class="n">arg2</span> <span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">m</span><span class="p">(</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg2</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Arg1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Arg2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Arg3</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">pimpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pimpl</span><span class="p">(</span> <span class="n">Arg1</span><span class="o">&amp;&amp;</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">Arg2</span><span class="o">&amp;&amp;</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">Arg3</span><span class="o">&amp;&amp;</span> <span class="n">arg3</span> <span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">m</span><span class="p">(</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg3</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>更改记录</h2>

<p>2011-12-06: 把 pimpl&lt;> 从一个基类更改为成员——我真的讨厌不必要的继承，你也应该是的。</p>

<p>2011-12-13: 增加解释，为什么这比手工实现的 Pimpl 惯用法更好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] GotW #100: Compilation Firewalls (Difficulty: 6/10)]]></title>
    <link href="http://bitdewy.github.io/blog/2012/06/30/gotw100/"/>
    <updated>2012-06-30T01:20:00+08:00</updated>
    <id>http://bitdewy.github.io/blog/2012/06/30/gotw100</id>
    <content type="html"><![CDATA[<p>[这是 <a href="http://www.gotw.ca/gotw/024.htm">GotW #24</a> 的 C++11 更新版]</p>

<p>原文在这里 <a href="http://herbsutter.com/gotw/_100/">GotW #100: Compilation Firewalls (Difficulty: 6/10)</a></p>

<h2>JG 问题</h2>

<p>1. Pimpl 惯用法是什么？为什么要使用它？</p>

<h2>Guru 问题</h2>

<p>2. 怎样才是 Pimpl 惯用法在 C++11 中的最佳实现？</p>

<p>3. 类中的那些部分应该放到 impl 对象中？一些可能的选择包括：</p>

<ul>
<li>所有私有数据（非函数）</li>
<li>所有私有成员</li>
<li>所有私有和保护成员</li>
<li>所有私有非虚成员</li>
<li>全部都放到 impl 对象中，然后实现公有接口，每个实现仅仅简单的做函数转发（handle/body 的变体）</li>
</ul>


<p>它们的每一个的缺点和优点是什么？你怎么选择？</p>

<p>4. impl 对象是否需要一个指向公开对象的反向指针？如果需要的话，它的最佳实现是什么？如果不需要的话，为什么？</p>

<!-- more -->


<h2>解决方案</h2>

<h3>1. Pimpl 惯用法是什么？为什么要使用它？</h3>

<p>在 C++ 中，当头文件中的类定义改变时，所有使用了这个类的用户都必须重新编译，甚至仅仅更改了那些用户无法访问的类的私有成员，也是如此。这是因为 C++ 的构建模型是基于文本包含的，并且 C++ 假定调用者知道以下两件事，而这些是会受到私有成员影响的：</p>

<ul>
<li><strong>大小和布局</strong>：调用的代码必须知道一个类的大小和布局，包括私有数据成员。调用者总是知道被调用者的实现，这个约束导致了调用者和被调用者之间更紧密的耦合，但这是 C++ 对象模型的核心和哲学，因为保证编译器默认情况下可以直接访问对象，是允许编译器进行深度性能优化的重要组成部分。</li>
<li><strong>函数</strong>：调用的代码必须决定调用类的哪个成员，包括那些不可访问的，重载了非私有函数的私有函数——如果私有函数时更好的匹配，那么调用代码将编译失败。（C++ 经过深思熟虑的设计决定，由于安全问题，重载决议将在访问控制权限之前进行。举个例子，这可以保证当改变访问权限，把私有函数改为公有时，它不会改变合法的已有的代码的行为。）</li>
</ul>


<p>为了减小编译依赖，最通常的技术是使用一个不透明的指针，隐藏实现的细节，下面是基本思路：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Pimpl idiom - basic idea</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// :::</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">impl</span><span class="p">;</span>        <span class="c1">// things to be hidden go here</span>
</span><span class='line'>    <span class="n">impl</span><span class="o">*</span> <span class="n">pimpl_</span><span class="p">;</span>       <span class="c1">// opaque pointer to forward-declared class</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>类 widget 使用了 handle/body 惯用法的变体，参见 Coplien 的文章[1]，handle/body 过去主要用途是引用计数共享的实体，但是它还有更通用的隐藏实现的功能。为了方便，下面我会把类 widget 叫做可见类，impl 叫做 &ldquo;Pimpl class” [2]</p>

<p>这个惯用法最大的好处是打破了编译时的依赖。首先，由于使用 Pimpl 可以消除多余的 #include，这使得编译过程更快了。我曾经在一个项目中仅仅把一些使用广泛的可见类转换为使用 Pimpls 就使得编译生成时间减少了一半。第二，它使得代码更改对编译的影响减小了，因为在类的 Pimpl 中的这一部分可以自由更改了——成员可以自由的添加或者删除，而不用重新编译客户端的代码。因为它可以在仅仅更改隐藏的成员时避免重新编译客户代码，所以它又被称为“编译防火墙”。</p>

<p><img src="http://y6b2pg.bay.livefilestore.com/y1pI_P3uHZCpkMFb96zRCFLihUxgDDQB7L3qbpfLfmSTYl74ZUZlc5KuGqow_81iGfYsiKOU_Ap1G4/firewalls.png" alt="" /></p>

<p>但是这还留下了一些问题：pimpl 应当是裸指针吗？哪些东西应该放到 Pimpl class 中？让我们看看这些和其他重要的细节吧。</p>

<h3>2. 怎样才是 Pimpl 惯用法在 C++11 中的最佳实现？</h3>

<p>避免使用裸指针和显式的 delete。仅仅使用标准 C++ 设施，最适当的选择是使用只能指针 unique_ptr 持有这个 Pimpl 对象，因为可见类是 Pimpl 对象的唯一所有者。使用 unique_ptr 也可以是代码变得简单。[3]</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// in header file</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">widget</span><span class="p">();</span>
</span><span class='line'>    <span class="o">~</span><span class="n">widget</span><span class="p">();</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">impl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">impl</span><span class="o">&gt;</span> <span class="n">pimpl</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// in implementation file</span>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span><span class="o">::</span><span class="n">impl</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// :::</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span><span class="o">::</span><span class="n">widget</span><span class="p">()</span> <span class="o">:</span> <span class="n">pimpl</span><span class="p">{</span> <span class="k">new</span> <span class="n">impl</span><span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span> <span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="n">widget</span><span class="o">::~</span><span class="n">widget</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>                   <span class="c1">// or =default</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意这个模式的关键部分：</p>

<ul>
<li>使用 unique_ptr 来持有 Pimpl 对象是更好的选择。它比使用 shared_ptr 更高效，而且更能正确表达意图，Pimpl 对象是不应该共享的。</li>
<li>在你自己的实现文件中定义和使用 Pimpl 对象。隐藏细节。</li>
<li>在可见类的非内联构造函数中分配 Pimpl 对象。</li>
<li>你仍然需要自己在可见类的实现文件中定义和实习它的析构函数，即使它和编译器生成的版本一模一样。这是因为虽然 unique_ptr 和 shared_ptr 可以实例化不完整的类型，但是 unique_ptr 的析构函数需要完整的类型，以便调用 delete（与 shared_ptr 不同，shared_ptr 可以在构造时获得更多的信息）。在实现 impl 的同时，自己实现它的析构函数，这可以有效的防止编译器自动生成析构函数。</li>
<li>上面的模式没有生成默认的拷贝和转移语义，因为 C++11 编译器没有那么热心为你生成拷贝和转移操作。由于我们已经自己定义了析构函数，这使得编译器不再为我们生成转移构造和转移赋值。如果你想要支持拷贝和/或转移语义，和析构函数一样，你需要在实现中定义拷贝和转移操作。</li>
</ul>


<p>C++11 中 Pimpl 另一个优势是，它是转移友好的，因为它仅仅需要拷贝单个指针就可以了。so cool。</p>

<p>让我们考虑一下上面提出的选择，哪些东西应该放到隐藏的 Pimpl 中。</p>

<h2>什么是 Pimpl ？[4]</h2>

<h3>3. 类中的那些部分应该放到 impl 对象中？</h3>

<p>一些可能的选择包括：</p>

<ul>
<li><strong>所有私有数据（非函数）</strong></li>
</ul>


<p>选择1（得分：6/10）：这是一个好的开始，因为我们可以前向声明任何数据类，这比 #include 类的实际声明要好，它会造成代码依赖。</p>

<p>但是它也存在缺点：一个小问题，我们需要在可见类的实现中不停的写 pimpl-> 。还有个大问题，当增加和删除私有成员函数时，我们还是需要重新编译，而且在极少数情况下，如果重载了非私有函数的话，它会干扰重载决议。</p>

<p>有更好的选择吗？</p>

<ul>
<li><strong>所有私有成员</strong></li>
</ul>


<p>选择2（得分：9/10）：这（几乎）是我最近的一贯做法。毕竟，在 C++中，我们说的“外部代码不应该也不能关心的部分”就是私有 private。</p>

<p>下面是三条注意事项，第一个就是我上面所说的“几乎”的原因：</p>

<ul>
<li> 你不能隐藏虚函数到 Pimpl 中，即使虚函数是私有的。如果重写了继承来的虚函数，它必须出现在派生中，即使这个类是 final 类。如果虚函数是 new 函数，那么它必须出现在可见类中，这样才能让派生类重写。</li>
<li> 如果你需要使用可见类中的函数，那么 Pimpl 类的函数就需要一个指向可见类对象的反向指针，这增加了间接层。</li>
<li><p> 一个好的折中办法是，使用“选择2”的同时，把那些私有成员需要调用的非私有成员函数一起放到 Pimpl 中（参考下面的“反向指针”）。</p></li>
<li><p><strong>所有私有和保护成员</strong></p></li>
</ul>


<p>选择3（得分：0/10）：多余的把保护成员移动到 Pimpl 中式绝对错误的。虚成员和保护成员不应该移动到 Pimpl 中，因为这会让他们变得没有价值。毕竟，保护成员仅仅可以让派生类访问，如果让他们不可见或不可用那就没有任何价值了。派生类只能强制了解 Pimpl 的细节，然后再继承 Pimlp，然后维护一个并行的两个对象的继承体系。</p>

<p>但是，仍然有合理的原因把虚函数放到 Pimpl-like（body/implementation） 类中。但是它的动机和 Pimpl 惯用法是不同的，这是桥接模式[5]，它把一个类分成两部分，这两部分都可以包含实现以及独立的可扩展的虚函数。但是这是和 Pimpl 动机不同的另外的模式。</p>

<ul>
<li><strong>所有私有非虚成员</strong></li>
</ul>


<p>选择4（得分：10/10）：这是理想的情况。为了避免保存或者传递一个反向指针，你可能需要把那些私有函数调用的公有函数也放到 Pimpl 中，然后在可见类中提供一个接口转发。但是你不应该移动保护成员和虚函数到 Pimpl 中，就像上面提到的。</p>

<ul>
<li><strong>全部都放到 impl 对象中，然后实现公有接口，每个实现仅仅简单的做函数转发（handle/body 的变体）</strong></li>
</ul>


<p>选择5（得分：8/10某种情况下）：这在某种情况下是有用的，并且它可以有效避免反向指针，因为所有东西都在 Pimpl 类中了。主要的缺点是多了一层封装，并且它使得可见类无法通过继承来扩展了。</p>

<p><strong>它们的每一个的缺点和优点是什么？你怎么选择？</strong></p>

<p>完整的答案事实上比上面我们讨论的要简单的多。抛开经验和具体的分析，我们需要回顾，然后从第一条原则开始回答。</p>

<p>深呼吸，放松，好的。</p>

<p>主要考察的是面向对象语言[6]中的三个部分。它们是：</p>

<ol>
<li>调用者的接口=公有成员。挺合适所有外部调用者可见和可用的部分。</li>
<li>派生类的接口=保护和虚成员，这些是仅派生类可见和可用的。</li>
<li>其他=私有和非虚成员，根据定义，这些是属于实现的细节。</li>
</ol>


<p><img src="http://y6argw.bay.livefilestore.com/y1pw2uUN6-6uSwVzVAKo9bJMQozoiWhrAoEreB-STKa-ZYSV3d-ma_-tB_ex-iUTRD1Br7A5NGdbrQ/impl.png" alt="" /></p>

<p>仅仅第3条，所有第3条涵盖的内容，可以隐藏也应该隐藏到 Pimpl 中。这样我们就能继承所有上面提到的其他东西；举个例子，我们不能把虚成员放到 Pimpl 中，因为我们在第2条中提到的，派生类需要它可见。</p>

<p>上面的表格描述了不同设计的选择。包括 Pimpl，以及引出的其他设计，Coplien 提出的 Handle/Body ，还有桥接模式，虽然某些地方和 Pimpl 类似，但是它的动机和结构是非常不同的。</p>

<h3>4. impl 对象是否需要一个指向公开对象的反向指针？如果需要的话，它的最佳实现是什么？如果不需要的话，为什么？</h3>

<p>答案是：有时候，很不幸，是的。毕竟，我们所做的就是（人为地，不自然的）把对象分为两部分，来隐藏其中一部分。</p>

<p>考虑下面的情况：当可见类的一个函数被调用的时候，通常隐藏部分的函数或者数据是需要协助完成请求的。这没问题也很合理。但是上面已经讨论过，有时候 Pimpl 中的函数必须调用可见类中的非私有或者虚函数。这时候，需要一个指向可见类的指针。</p>

<p>有两个选择：</p>

<ul>
<li>在 Pimpl 中保存一个反向指针。这会带来轻微的开销，而且会一直保存着这个指针无论你用还是不用。此外，when you repeat yourself you can lie——如果你不小心维护指针的正确性让它指向正确的可见对象，反向指针会存在同步问题，举个例子，默认情况下转移操作之后，它就不再正确了。</li>
<li>（推荐）通过参数传递 this 指针给 Pimpl 中的函数（例如：pimpl->func(this, params)）。这仅仅会在函数调用(简单)时，带来栈上(廉价的)很小的空间开销，而且也不可能存在同步问题。但是，这意味着给每一个需要的隐藏函数增加个多余的参数。</li>
</ul>


<h2>感谢</h2>

<p>感谢 Edd, pizer, and Howard Hinnant 阐明为什么 ~unique_ptr<T> 需要 T 是完整类型, 并需要用户自己在外部实现类的析构函数；感谢 Stephan Lavavej and Alisdair Meredith 提醒我在转移构造和转移赋值时使用 =default；感谢 Howard Hinnant 指出即使使用了 =default，转移赋值函数仍然需要在实现文件中以非内联函数形式实现，因为它需要类型完整（确保能够 delete）。</p>

<h2>注解</h2>

<p>[1] James O. Coplien. “<a href="http://users.rcn.com/jcoplien/Patterns/C++Idioms/EuroPLoP98.html">C++ Idioms</a>” (EuroPLoP98).</p>

<p>[2] 一开始我使用 impl_ 作为指针的变量名。pimpl 是从 1996 年开始使用的，分享给我这个名字的是同学兼好友 Jeff Sumner，使用字母 “p” 作为指针变量的前缀，同时我也发现了之前变量名的可怕的双关。</p>

<p>[3] 这是 C++ 11 中最简单的模型。最主要的替代方案是使用 shared_ptr 或者裸指针来代替 unique_ptr，这两个的正确实现都比它复杂，存在潜在的错误，编译器生成的函数会产生不正确的行为：如果你使用 shared_ptr，你可以默认得到正确的析构函数，转移构造函数转移赋值函数，但是编译器生成的拷贝操作将是错误的，所以你需要手工明确的实现，或者使用 =delete 禁止它们（如果你忘记了，那你就默默得到了错误的语义），一个无用但是却存在的引用计数。如果你使用裸指针，你需要手动实现5个操作，析构函数，拷贝构造函数，拷贝赋值函数，转移构造函数，还有转移赋值函数。</p>

<p>[4] 不要发关于这个标题的笑话给我，大部分答案我都能想到。</p>

<p>[5] Gamma et al. <a href="http://en.wikipedia.org/wiki/Design_Patterns">Design Patterns: Elements of Reusable Object-Oriented Software</a> (Addison-Wesley, 1994).</p>

<p>[6] 一个类中不需要包含全部特性，举个例子，#2 不适用于那些不存在继承的值语义类。</p>
]]></content>
  </entry>
  
</feed>
