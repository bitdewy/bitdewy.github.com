<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bitdewy]]></title>
  <link href="http://bitdewy.github.com/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2014-11-02T22:33:46+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译] Item 3: Understand decltype]]></title>
    <link href="http://bitdewy.github.com/blog/2014/10/21/emcpp-item-3/"/>
    <updated>2014-10-21T14:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/10/21/emcpp-item-3</id>
    <content type="html"><![CDATA[<p><code>decltype</code> 是一个奇怪的发明。给一个名字或者表达式，<code>decltype</code> 可以告诉你这个名字或者表达式的类型。通常的情况下，他告诉你的都是你预期的。但是偶尔也会有些出人意料。</p>

<p>我们从最典型的情况开始 —— 那些不会让你惊奇的情况。与模板类型推导和 <code>auto</code> 类型推导不同，<code>decltype</code> 通常只是鹦鹉学舌般的返回你传入的名字或表达式的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// decltype(i) is const int</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>    <span class="c1">// decltype(w) is const Widget&amp;</span>
</span><span class='line'>                            <span class="c1">// decltype(f) is bool(const Widget&amp;)</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>               <span class="c1">// decltype(Point::x) is int</span>
</span><span class='line'><span class="p">};</span>                          <span class="c1">// decltype(Point::y) is int</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// decltype(w) is Widget</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="p">{</span>                 <span class="c1">// decltype(f(w)) is bool</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>        <span class="c1">// simplified version of std::vector</span>
</span><span class='line'><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>              <span class="c1">// decltype(v) is vector&lt;int&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>            <span class="c1">// decltype(v[0]) is int&amp;</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是完全没有惊喜？</p>

<!-- more -->


<p>在 C++11 中，<code>decltype</code> 的作用也许就是声明一个返回值类型依赖于模板参数的模板函数。举个例子，假设我们准备写一个以容器 (接受下标操作的) 和索引 <code>index</code> 为参数的函数，验证用户之后返回。返回值的类型与容器下标操作的类型相同。</p>

<p><code>T</code> 类型容器的 <code>operator[]</code> 返回值类型通常是 <code>T&amp;</code>。对于 <code>std::deque</code> 来说，是这个样，对于 <code>std::vector</code> 来说，大部分情况下也是的，不过对于 <code>std::vector&lt;bool&gt;</code> 来说，情况就不一样了，它的返回值不是 <code>bool&amp;</code>。这就是我们要在 Item 6 中讨论的问题。在这里，最重要的是，我们要知道容器的 <code>operator[]</code> 的返回值依赖于容器。</p>

<p><code>decltype</code> 可以让这个问题变得简单，下面的代码展示如何利用 <code>decltype</code> 来计算返回值。它还可以进一步的精简，我们稍后再说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span>  <span class="c1">// works, but requires refinement </span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数名前面的 <code>auto</code> 在类型推导中什么用处都没有。取而代之的是 C++11 的尾随返回值类型 (trailing return type)。函数返回值的类型在函数参数列表之后声明 (在 &ndash;> 符号之后)。尾随返回值类型的好处是，函数的参数可以用于声明返回值类型。在 <code>authAndAccess</code> 中，我们的返回值类型声明用到了参数 <code>c</code> 与 <code>i</code>。如果我们将返回值类型置于函数名前，那么我们就无法使用 <code>c</code> 和 <code>i</code>，因为这时它们还没有声明。</p>

<p>上面的声明中，<code>autoAndAccess</code> 的返回值与我们预期的完全一致，就是容器 <code>Container</code> 的 <code>operator[]</code> 的返回值类型。</p>

<p>C++11 支持单句 <code>lambda</code> 的返回值类型推导，而 C++14 进行了扩展，支持所有 <code>lambda</code> 和函数，包括那些多条语句的。这意味着在上面的例子中，使用 C++14 我们可以省略掉尾随返回值类型，仅仅保留最前面的 <code>auto</code> 即可。在这里，<code>auto</code> 是类型推导的占位符。编译器会根据函数的具体实现来推导函数的返回值类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>    <span class="c1">// C++14, not require</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>            <span class="c1">// return type deduced from c[i]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，在这里返回值类型推导使用的是哪个类型推导规则？模板？ <code>auto</code> ? 还是 <code>decltype</code> ?</p>

<p>也许你会有些惊讶，函数的 <code>auto</code> 返回值类型遵循的是模板类型推导规则。看起来 <code>auto</code> 类型推导规则，在这里是一个更好的选择，不过 <code>auto</code> 类型推导与模板类型推导机会是完全一致的。唯一的区别就是模板类型推导无法推导大括号初始化。</p>

<p>在这里，<code>authAndAccess</code> 的返回值类型推导使用模板类型推导是有问题的，不过 <code>auto</code> 类型推导也是一样存在问题。这里的问题是，我们需要推导的表达式是一个引用。</p>

<p>回想一下之前的讨论，<code>operator[]</code> 对于大多数容器类型 <code>T</code> 来说，返回值类型都是 <code>T&amp;</code>，我们在 Item 1 中已经讨论过了，在模板类型推导时，表达式的引用会被忽略。考虑下这对我们上面的代码意味着什么：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">authAndAccess</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// authenticate user, return d[5], then assign 10 to it; this won&#39;t compile!</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，<code>d[5]</code> 返回类型是 <code>int&amp;</code>，但是 <code>auto</code> 返回值类型推导会将引用忽略掉，变成了 <code>int</code> 类型。而 <code>int</code> 类型作为一个函数的返回值，是一个右值，而上面的代码中企图将 <code>10</code> 赋值给一个右值。这在 C++ 中是禁止的，因此会编译失败。</p>

<p>这个问题是由于我们使用了会忽略引用的模板类型推导。在这里，我们需要的实际上是 <code>decltype</code> 类型推导。它能够保证返回值类型与 <code>c[i]</code> 的类型完全一致。</p>

<p>C++ 将引入新的类型推导规则，<code>decltype</code> 类型推导，在 C++14 中通过标识符 <code>decltype(auto)</code> 来实现。这看起来有些奇怪，但是很好的表达了意图：<code>auto</code> 是要推导的类型，<code>decltype</code> 表明需要遵循 <code>decltype</code> 类型推导规则。现在我们可以把之前的代码改成下面这样了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>    <span class="c1">// C++14, works, but still requires refinement</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在 <code>authAndAccess</code> 的返回值与 <code>c[i]</code> 的类型完全一致了，一般情况下当 <code>c[i]</code> 返回 <code>T&amp;</code> 类型时，<code>authAndAccess</code> 也会返回 <code>T&amp;</code>，而当 <code>c[i]</code> 需要返回一个 object 类型时，<code>authAndAccess</code> 也会返回 object 类型。</p>

<p><code>decltype(auto)</code> 的使用，不仅限于函数返回值类型，当你需要使用 <code>decltype</code> 类型推导规则时，它可以用于声明变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">cw</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">myWiget1</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>    <span class="c1">// auto type deduction:</span>
</span><span class='line'>                       <span class="c1">// myWidget1&#39;s type is Widget</span>
</span><span class='line'>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">myWidget2</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>  <span class="c1">// decltype type deduction:</span>
</span><span class='line'>                                <span class="c1">// myWidget2&#39;s type is const Widget&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>但肯定还有两个问题困扰着你，一个就是上面的代码中提到的优化，我们到现在还没有谈到，现在就让我们来看这个问题。</p>

<p>回头看看我们的 C++14 版本的 <code>authAndAccess</code> 函数声明；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>容器参数的类型是左值引用，这样可以让容器返回元素供调用者修改。但是这意味着这个函数无法接受右值的容器作为参数了，因为右值是无法绑定到左值引用的。</p>

<p>不可否认，传一个右值给 <code>authAndAccess</code> 的场景非常少见。一个右值的容器作为一个临时对象会在函数 <code>authAndAccess</code> 结束时销毁，这意味着容器元素的引用（ <code>authAndAccess</code> 函数的返回值）会失效。但是给 <code>authAndAccess</code> 传入一个临时对象还是有意义的。调用者有时会需要一个容器元素的拷贝的，比如下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">makeStringDeque</span><span class="p">();</span>  <span class="c1">// factory function</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// make copy of 5th element of deque returned</span>
</span><span class='line'><span class="c1">// from makeStringDeque</span>
</span><span class='line'><span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">makeStringDeque</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>支持上面的用法，意味着我们要将原本的函数修改为同时支持左值和右值。重载是可以解决这个问题，但是这样一来我们就需要维护两个函数了。有一种办法可以避免同时维护两个函数，我们可以让函数 <code>authAndAccess</code> 同时支持左值以及右值参数，Item 24 中，我们会详细的介绍全局引用。修改后的 <code>authAndAccess</code> 函数声明如下和：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>          <span class="c1">// c is now a </span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span>  <span class="c1">// universal reference</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的模板中，我们不知道 <code>Container</code> 的类型，同时我们也忽略了 index 对象的类型。对一个未知类型使用值传递会因为不必要的拷贝而造成性能问题，也会有对象切割问题（Item 41），还会被同事吐槽，不过在这里我们只考虑标准库容器的情况（比如，<code>std::string</code>, <code>std::vector</code> 以及 <code>std::deque</code> 的 <code>operator[]</code>），在这里仍然坚持使用值传递。</p>

<p>不过我们还需要更新一下模板函数的实现，根据 Item 25，我们使用 <code>std::forward</code> 把全局引用包起来，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>  <span class="c1">// final C++14 version</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码完全符合我们的需求，不过需要支持 C++14 的编译器。如果你现在还没有支持 C++14 的编译器的话，那就需要一个 C++11 的版本。和 C++14 的版本非常相似，唯一的不同点是我们需要手动的指定返回值类型，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>    <span class="c1">// final C++11 version</span>
</span><span class='line'><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">authenticateUser</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另一个问题 —— 除非你是一个库的作者，不然的话，这种情况基本不可能遇到。</p>

<p>要完全明白 <code>decltype</code> 的行为，你必须了解少数的特殊情况。大多数不值得在本书中讨论，不过我们现在来看一看它们是如何使用的。</p>

<p>对一个变量名使用 <code>decltype</code>，会得到与变量名一致的类型。变量名是一个左值，但是不会影响 <code>decltype</code> 的行为。但对于左值表达式来说，情况就变的复杂了，它会使 <code>decltype</code> 返回左值引用。也就是说，如果一个左值表达式不仅仅是一个变量名，那么对于类型 <code>T</code> 的左值表达式使用 <code>decltype</code>， 它会得到一个 <code>T&amp;</code> 类型。这很少会产生冲突，因为大部分的左值表达式都内含左值引用的限定符。例如返回左值的函数通常返回的都是左值引用。</p>

<p>但是这还是会产生一些不期望的问题，例如，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>x</code> 是变量名，<code>decltype(x)</code> 的类型是 <code>int</code>。但是，使用括号将 <code>x</code> 包起来，情况就不一样了。<code>x</code> 是一个左值， <code>(x)</code> 是一个左值表达式，<code>decltype((x))</code> 的类型是 <code>int&amp;</code>。一个括号改变了 <code>decltype</code> 的类型。</p>

<p>在 C++11 中，这不是大问题，但在 C++14 中，由于支持了 <code>decltype(auto)</code>，这个微不足道的变化会变的影响含漱的返回值类型推导。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f1</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// decltype(x) is int, so f1 returns int</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f2</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>    <span class="c1">// decltype((x)) is int&amp;, so f2 returns int&amp;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，<code>f2</code> 不仅仅只是与 <code>f1</code> 的返回值类型不同，它还返回了一个局部变量的引用。这使得你的代码不知不觉的就产生了未定义行为。</p>

<p>这就是说当你使用 <code>decltype(auto)</code> 时，必须要非常小心。一些非常小的细节就可能会影响 <code>decltype(auto)</code> 的类型推导结果。确定类型推导的结果是否符合你的预期，你需要用到 Item 4 中介绍的技术手段。</p>

<p>与此同时，不要忘记从更高的角度来审视这个问题。<code>decltype</code>（不论是否与 <code>auto</code> 在一起）偶尔会产生让你惊讶的结果，但是它不是一般情况。<code>decltype</code> 通常都会符合你的预期。这对于变量名来说是非常正确的。这种情况下，<code>decltype</code> 就像它们看起来的那样：它推导的结果就是变量声明的类型。</p>

<h2>需要记住的</h2>

<ul>
<li><code>decltype</code> 几乎总是与表达式的类型完全一致。</li>
<li>对于类型为 <code>T</code> 的左值表达式（除了变量名），<code>decltype</code> 的类型为 <code>T&amp;</code>。</li>
<li>C++14 支持 <code>decltype(auto)</code>，与 <code>auto</code> 类似，在初始化的时候推导变量的类型，但是使用 <code>decltype</code> 类型推导规则。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 2: Understand auto type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2/"/>
    <updated>2014-09-18T23:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/09/18/emcpp-item-2</id>
    <content type="html"><![CDATA[<p>如果你已经阅读了 Item 1 模板类型推导，那么你应该已经掌握了 <code>auto</code> 的类型推导，出了下面要讲到的一个不同之外，其他都和 Item 1 完全一致，但是你肯定还有疑问，为什么模板类型推导涉及到了模板，函数以及参数，而 <code>auto</code> 却不涉及这些。</p>

<p>没错，但是这也没什么关系。其实模板类型推导与 <code>auto</code> 类型推导有直接的映射关系。有很直观的转换关系。</p>

<p>在 Item 1 中，我们使用下面的模板函数用来描述模板类型推导，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span> <span class="p">(</span><span class="n">expr</span><span class="p">);</span>    <span class="c1">// call f with some expression</span>
</span></code></pre></td></tr></table></div></figure>


<p>在调用函数 <code>f</code> 时，编译器使用表达式 <code>expr</code> 来推导类型 <code>T</code> 和 <code>ParamType</code>。</p>

<p>当使用 <code>auto</code> 来声明变量时，<code>auto</code> 代替了上面 <code>T</code> 的位置，同时变量的类型就是 <code>ParamType</code> 的类型。看下面的例子会更直观，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，变量 <code>x</code> 的类型标识符就是一个简单的 <code>auto</code>，在</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>中，类型标识符是 <code>const auto</code>，在</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>中，类型标识符是 <code>const auto&amp;</code>。推导上面 <code>x</code>, <code>cx</code> 以及 <code>rx</code> 的类型，编译器所做的事情就像是有一个模板函数一样，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_x</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>           <span class="c1">// conceptual template for deducing x&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_x</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is x&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_cx</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// conceptual template for deducing cx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_cx</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is cx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_rx</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>   <span class="c1">// conceptual template for deducing rx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_rx</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is rx&#39;s type</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>就像刚才说的一样，<code>auto</code> 的类型推导只有一点（一会儿会讲到）不一样之外，其他与模板类型推导完全一致。</p>

<p>Item 1 中根据 <code>ParamType</code> 的类型，把类型推导分了三种情况来处理，在 <code>auto</code> 类型推导时，<code>auto</code> 替代了 <code>ParamType</code>  也同样分为三种情况，</p>

<ul>
<li>情况1：类型标识符是一个指针或者引用，但不是右值引用</li>
<li>情况2：类型标识符是一个全局引用</li>
<li>情况3：类型标识符既不是指针也不是引用</li>
</ul>


<p>我们已经见过了情况1 与情况3 的例子了，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>           <span class="c1">// case 3 (x is neither ptr nor reference)</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">// case 3 (cx isn&#39;t neither)</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// case 1 (rx is a non-universal ref.)</span>
</span></code></pre></td></tr></table></div></figure>


<p>情况2 就像你预期的那样，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">// x is int lvalue, so uref1&#39;s type is int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref2</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>    <span class="c1">// cx is const int and lvalue, so uref2&#39;s type is const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">uref3</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>    <span class="c1">// 27 is int and rvalue, so uref3&#39;s type is int&amp;&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Item 1 中我们讨论了非引用的数组和函数是如何退化成指针的。在 <code>auto</code> 类型推导中也是一样的，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;R. N. Briggs&quot;</span><span class="p">;</span>    <span class="c1">// name&#39;s type is const char[13]</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">arr1</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>                      <span class="c1">// arr1&#39;s type is const char *</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>                     <span class="c1">// arr2&#39;s type is const char (&amp;)[13]</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>            <span class="c1">// someFunc is function, type is void(int, double)</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">func1</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span>                 <span class="c1">// func1&#39;s type is void(*)(int, double)</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;</span> <span class="n">func2</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span>                <span class="c1">// func2&#39;s type is void(&amp;)(int, double)</span>
</span></code></pre></td></tr></table></div></figure>


<p>就像你看到这样，<code>auto</code> 类型推导就像模板类型推导一样。</p>

<p>仅有一种情况，他们是不一样的。我们从一个简单的例子开始，在 C++98 中，我们用 27 来初始化一个 int 变量，我们可以有下面两种写法，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11 统一初始化，增加了下面的写法，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>总而言之，4中不同的写法的结果都是一样的，初始化了一个值为 27 的整型。</p>

<p>但是，就像 Item 5 中解释的一样，使用 <code>auto</code> 来声明类型是可以获得好处的，所有我们可以将上面的 <code>int</code> 全部替换为 <code>auto</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这 4 种写法都能够正常编译，但是却表达了不同的含义。前两种写法定义了一个值为 27 的整型。但后两种写法实际上定义了一个只有一个元素 27 的 <code>std::initializer_list&lt;int&gt;</code>！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>        <span class="c1">// type is int, value is 27</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>         <span class="c1">// ditto</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>    <span class="c1">// type is std::initializier_list&lt;int&gt;, value is { 27 }</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>       <span class="c1">// ditto</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是 <code>auto</code> 类型推导的一个特殊规则。当使用大括号初始化一个 <code>auto</code> 变量时，类型会被推导为 <code>std::initializer_list</code>，如果类型推导不成功（比如，大括号中的某个元素类型与其他的不一致），那么将会编译失败：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x5</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">};</span>    <span class="c1">// error! can&#39;t deduce T for std::initializer_list&lt;int&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>就像上面注释中写的一样，类型推导在这种情况下会失败，但是要明白这里有两个类型推导，这是很重要的。第一个是 <code>auto</code>，<code>x5</code> 使用了大括号来初始化，那么 <code>auto</code> 会被推导为 <code>std::initializer_list</code> 类型，但同时 <code>std::initializer_list</code> 是一个模板类型，模板参数 <code>T</code> 同样需要推导，类型推导失败产生于第二步：模板类型推导。在上面的例子中，就是由于大括号中的元素类型不一致而导致的模板类型推导失败。</p>

<p><code>auto</code> 类型推导与模板类型推导的唯一不同在于大括号初始化。当使用大括号初始化时，<code>auto</code> 会推到为 <code>std::initializer_list</code> 类型，但对于模板类型推导来说，这会产生一个错误，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>  <span class="c1">// x&#39;s type is std::initializer_list&lt;int&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>         <span class="c1">// template with parameter declaration equivalent to x&#39;s</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">({</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span><span class="p">});</span>         <span class="c1">// error! can&#39;t deduce type for T</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过，如果你明确指定了 <code>param</code> 的类型为 <code>std::initializer_list&lt;T&gt;</code> 那么模板类型推导会推导出 <code>T</code> 的类型，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">initList</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">({</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span> <span class="p">});</span>    <span class="c1">// T deduce as int, and initList&#39;s type is std::initializer_list&lt;int&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，<code>auto</code> 类型推导与模板类型推导唯一的不同在于，对于大括号初始化，<code>auto</code> 类型推导会将它推导为 <code>std::initializer_list</code>，而模板类型推导不会。</p>

<p>也许你会想知道为什么会有这样的区别。我也曾想过，但是没有找到一个很好的解释。不过规则就是规则，你只需要记住，当使用大括号初始化 <code>auto</code> 类型时，它会被自动推到为 <code>std::initializer_list</code> 类型。如果你想要使用新的统一初始化，那么记住这一点是非常重要的。一个典型的 C++11 错误就是当你想要一个其他类型时却意外的声明了一个 <code>std::initializer_list</code> 类型。这也是为什么有些开发者仅仅在必要的时候才使用大括号初始化的一个原因。（我们会在 Item 7 中详细讨论）</p>

<p>对 C++11 来说，这就是全部了。但是对于 C++14，还有些其他内容。C++14 允许使用 <code>auto</code> 来表示需要被推导的函数返回值类型（详见 Item 3），C++14 的 lambda 中也允许 <code>auto</code> 用作参数类型。但是这些 <code>auto</code> 遵循的是模板类型推导，而不是 <code>auto</code> 类型推导。因此，一个返回值类型声明为 <code>auto</code> 返回一个大括号初始化时，会导致编译失败，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">createInitList</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>    <span class="c1">// error: can&#39;t deduce type for { 1, 2, 3 }</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>lambda:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="k">auto</span> <span class="n">resetV</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">v</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">newValue</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span> <span class="o">=</span> <span class="n">newValue</span><span class="p">;</span> <span class="p">};</span>    <span class="c1">// C++14</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'><span class="n">resetV</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">});</span>    <span class="c1">// error! can&#39;t deduce type for { 1, 2, 3 }</span>
</span></code></pre></td></tr></table></div></figure>


<h2>需要记住的</h2>

<ul>
<li><code>auto</code> 类型推导通常和模板类型推导是一致的，但是 <code>auto</code> 类型推导会将大括号初始化推到为 <code>std::initializer_list</code>，而模板类型推导不会</li>
<li><code>auto</code> 在函数返回值以及 lambda 参数类型推导时，遵循模板类型推导，而不是 <code>auto</code> 类型推导。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] Item 1: Understand template type deduction]]></title>
    <link href="http://bitdewy.github.com/blog/2014/08/23/emcpp-item-1/"/>
    <updated>2014-08-23T00:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/08/23/emcpp-item-1</id>
    <content type="html"><![CDATA[<p>在使用一个复杂的系统时，我们可以不用知道具体的细节。从这个方面来说，C++ 的模板类型推导是很成功的。数以百万的程序员都使用过模板，即使他们可能很难描述清楚这些类型是如何推导的。</p>

<p>如果你是其中的一员，我有一个好消息，也有一个坏消息。好消息是，模板类型推导是最引人注目的 C++11 新特性 <code>auto</code> 的基础。如果你很清楚 C++98 中的模板类型推导，那么你会很容易明白 C++11 中的 <code>auto</code>。坏消息是，当使用 <code>auto</code> 时，有些类型推导会变得没有那么直观。因此完全掌握类型推导的规则是非常有必要的。Item 1 会介绍你必须知道的类型推导规则。</p>

<p>我们从一小段伪代码开始：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span> <span class="p">(</span><span class="n">expr</span><span class="p">);</span>    <span class="c1">// call f with some expression</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编译期间，编译器使用表达式 <code>expr</code> 来推导两个类型：一个是 <code>T</code> 另一个是 <code>ParamType</code>。这两个类型通常是不一样的，因为 <code>ParamType</code> 通常是含有修饰的，比如 <code>const</code> 或者引用。举个例子，如果模板的声明如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// ParamType is const T&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>    <span class="c1">// call f with an int</span>
</span></code></pre></td></tr></table></div></figure>


<p>类型 <code>T</code> 会被推导为 <code>int</code>，而 <code>ParamType</code> 被推导为 <code>const int&amp;</code>。</p>

<p>将类型 <code>T</code> 推导为传入的参数类型是很自然的，即 <code>T</code> 的类型就是 <code>expr</code> 的类型。在上面的例子中，<code>x</code> 是 <code>int</code> 类型，<code>T</code> 被推导为 <code>int</code> 类型。但是有时候却不是这样的。类型推导不仅仅依赖于表达式 <code>expr</code> 的类型，同时还依赖于 <code>ParamType</code> 的形式。有下面三种情况：</p>

<ul>
<li>ParamType 是一个指针或者引用类型，但是不是全局引用。（全局引用将会在 Item 24 中讲述。现在你只需要知道他不同于引用，也不同于右值引用即可）。</li>
<li>ParamType 是一个全局引用。</li>
<li>ParamType 即不是指针也不是引用</li>
</ul>


<!-- more -->


<p>因此我们需要考虑上面描述的三种场景来一一讲述。每个都基于下面的伪代码，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>    <span class="c1">// deduce T and ParamType from expr</span>
</span></code></pre></td></tr></table></div></figure>


<h3>情况1：<code>ParamType</code> 是一个指针或者引用，但不是右值引用</h3>

<p>这是最简单的一种情况，在这种情况下，类型推导的工作如下：</p>

<ol>
<li>如果 <code>expr</code> 是一个引用类型，忽略引用部分。</li>
<li>然后模式匹配 <code>expr</code> 的类型，根据 <code>ParamType</code> 的类型来决定 <code>T</code> 的类型。</li>
</ol>


<p>举个例子，如果我们的模板是下面这样，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// param is a reference</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后我们有如下的变量声明，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>           <span class="c1">// x is an int</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">// cx is a const int</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// rx is a reference to x as a const int</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>param</code> 和 <code>T</code> 的类型推导结果如下，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>     <span class="c1">// T is int, param&#39;s type is int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>    <span class="c1">// T is const int, param&#39;s type is const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>    <span class="c1">// T is const int, param&#39;s type is const int&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在第二个以及第三个调用中，注意由于 <code>cx</code> 和 <code>rx</code> 是 <code>const</code> 值，所以 <code>T</code> 被推导为 <code>const int</code> 类型，这对调用者来说是至关重要的。当调用者传入一个 <code>const</code> 对象给一个引用参数时，参数仍然是不可更改的。比如，参数是一个 <code>const</code> 引用。这也是为什么传入一个 <code>const</code> 对象给一个接受 <code>T&amp;</code> 类型的模板参数是安全的：<code>const</code> 约束直接变为了 <code>T</code> 类型的一部分。</p>

<p>在第三个调用中，注意虽然 <code>rx</code> 的类型是引用，<code>T</code> 仍然被推导为非引用。这是由于类型推导过程中 <code>rx</code> 的引用修饰被忽略掉了。</p>

<p>上面的例子都是左值引用参数，但其实右值引用的类型推导和上面是完全一样的。当然，只有右值类型的参数才能传递给右值引用，但他对类型推导完全没有影响。</p>

<p>如果我们将 <code>f</code> 的参数类型由 <code>T&amp;</code> 更改为 <code>const T&amp;</code>，情况会有一些变化，但非常好理解。<code>cx</code> 和 <code>rx</code> 的 <code>const</code> 修饰仍然有用。但由于现在假定 <code>param</code> 的类型是一个 <code>const</code> 引用，现在不再需要将 <code>const</code> 推断为类型 <code>T</code> 的一部分了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// param is now ref-to-const</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>                <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>          <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>         <span class="c1">// as before</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                      <span class="c1">// T is int, param&#39;s type is const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                     <span class="c1">// T is int, param&#39;s type is const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                     <span class="c1">// T is int, param&#39;s type is const int&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>和上面一样，<code>rx</code> 的引用修饰在类型推导时会被忽略。</p>

<p>如果 <code>param</code> 是一个指针（或者 <code>const</code> 指针），类型推导基本是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">param</span><span class="p">);</span>          <span class="c1">// param is now a pointer</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>                <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>        <span class="c1">// px is a ptr to x as a const int</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// T is int, param&#39;s type is int*</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">px</span><span class="p">);</span>                     <span class="c1">// T is const int, param&#39;s type is const int*</span>
</span></code></pre></td></tr></table></div></figure>


<p>到目前位置，你可能已经哈欠不断了，因为对于指针和引用的类型推导，规则这么简单，所有的结果都是显而易见的，就和你想象的完全一样。</p>

<h3>情况2：<code>ParamType</code> 是全局引用</h3>

<p>当模版参数是全局引用时，类型推导就没有那么明显了。声明的形式有点像右值引用（全局引用的类型声明形式是 <code>T&amp;&amp;</code>），但是当传入的参数是左值类型时行为是不一样的。具体细节在 Item 24 中讲述，现在我们来看一个简单的版本：</p>

<ul>
<li>如果 <code>expr</code> 是一个左值，那么 <code>T</code> 和 <code>ParamType</code> 都会推导为左值引用。有两个不寻常的地方。第一，这是仅有的模板类型推导会将类型 <code>T</code> 推导为引用类型的情形。第二，尽管 <code>ParamType</code> 的类型声明使用了右值引用的符号，但却推导为了左值引用。</li>
<li>如果 <code>expr</code> 是一个右值，会使用“正常的”（情况1）规则。</li>
</ul>


<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">tempalte</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>        <span class="c1">// param is now a universal reference</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>               <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>         <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// as before</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// x is lvalue, so T is int&amp;, param&#39;s type is also int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                    <span class="c1">// cx is lvalue, so T is const int&amp;, param&#39;s type is also const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                    <span class="c1">// rx is lvalue, so T is const int&amp;, param&#39;s type is also const int&amp;</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>                    <span class="c1">// 27 is rvalue, so T is int, param&#39;s type is therefore int&amp;&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Item 24 中会详细解释为什么在上面的情形中类型推导是这样的。在这里我们的重点是，左值参数和右值参数对于全局引用来说，类型推导的规则是不一样的。这很特别的，当使用全局引用时，类型推导会区别对待左值参数和右值参数，这是在其他类型中不会发生的。</p>

<h3>情况3：<code>ParamType</code> 即不是引用也不是指针</h3>

<p>当 <code>ParamType</code> 既不是引用也不是指针时，我们来按值传递，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>          <span class="c1">// param is now passed by value</span>
</span></code></pre></td></tr></table></div></figure>


<p>这意味着 <code>param</code> 会做一个拷贝 —— 产生一个全新的对象。<code>param</code> 的类型推导遵循如下规则：</p>

<ol>
<li>像上面一样，如果 <code>expr</code> 的类型是一个引用，那么引用类型会被忽略。</li>
<li>如果忽略了 <code>expr</code> 的引用修饰之后，<code>expr</code> 是一个 <code>const</code>，那么将 <code>const</code> 也忽略。如果有 <code>volatile</code> 修饰，也同样忽略。（<code>volatile</code> 修饰并不常用，通常只是在实现设备驱动时会用到。更多细节，参见 Item 40）。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>              <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// as before</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>       <span class="c1">// as before</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                    <span class="c1">// T&#39;s and param&#39;s types are both int</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                   <span class="c1">// T&#39;s and param&#39;s types are again both int</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                   <span class="c1">// T&#39;s and param&#39;s types are still both int</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，即使 <code>cx</code> 和 <code>rx</code> 都是 <code>const</code> 类型，<code>param</code> 的类型也不是 <code>const</code>。这是有道理的。<code>param</code> 是一个与 <code>cx</code> 和 <code>rx</code> 无关的对象 —— 是一份拷贝。因此， <code>cx</code> 和 <code>rx</code> 的 <code>const</code> 属性，不会影响 <code>param</code>。这就是为什么在类型推导过程中 <code>expr</code> 的 <code>const</code>（以及 volatile）修饰会被忽略的原因：<code>expr</code> 不可更改并不意味着它的拷贝不可以。</p>

<p>意识到 <code>const</code>（以及<code>volatile</code>）修饰仅仅在传值参数中会被忽略，是非常重要的。像前面看到的，对于 <code>const</code> 引用，或者 指向 <code>const</code> 对象的指针参数，<code>expr</code> 的 <code>const</code> 修饰是保留到类型推导中的。但是考虑以下情况，<code>expr</code> 是一个指向 <code>const</code> 对象的 <code>const</code> 指针，且 <code>expr</code> 是值传递给 <code>param</code> 的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                              <span class="c1">// param is still passed by value</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Fun with pointers&quot;</span><span class="p">;</span>  <span class="c1">// ptr is const pointer to const object</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>                                       <span class="c1">// pass arg of type const char * const</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，右边（第二个）的 <code>const</code> 表示 <code>ptr</code> 不可更改。左边（第一个）表示 <code>ptr</code> 指向的常量字符串不可更改。当 <code>ptr</code> 传递给 <code>f</code> 时，<code>ptr</code> 值传递会产生一个拷贝，根据类型推导规则，<code>ptr</code> 的 <code>const</code> 修饰会被忽略掉，最终 <code>param</code> 类型为 <code>const char*</code>，即指向常量字符串的指针。<code>ptr</code> 所指向的内容的 <code>cosnt</code> 修饰被保留，而 <code>ptr</code> 本身的 <code>const</code> 修饰在值传递时被忽略。</p>

<h4>数组参数</h4>

<p>几乎所有主流的模板类型推导都包含它，但是还是有一些值得注意的地方。数组类型与指针类型是不同的，尽管他们有时可以转换。在很多时候数组是可以退化成指针的。下面的代码可以编译通过：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;J. P. Briggs&quot;</span><span class="p">;</span>   <span class="c1">// name&#39;s type is const char[13]</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptrToName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>         <span class="c1">// array decays to pointer</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，<code>ptrToName</code> 作为一个 <code>const char*</code> 类型，使用了 <code>const char[13]</code> 类型的 <code>name</code> 来初始化。但是这两个类型是不同的，由于数组到指针的退化规则才使得代码能够编译通过。</p>

<p>但当我们将一个数组类型传递给一个值传递的模版参数时，会发生什么呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>               <span class="c1">// template with by-value paramter</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>                       <span class="c1">// what types are deduced for T and param ?</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们使用没有模板的情况先来观察，对，没错，下面的语法是合法的，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">myFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">param</span><span class="p">[]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是数组参数的声明会被退化成指针，这意味着它和下面的声明是完全一致的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">myFunc</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">param</span><span class="p">);</span>     <span class="c1">// same function as above</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的退化是从 C 语言中继承而来的，他给我们造成了数组类型与指针类型是一样的这种幻觉。</p>

<p>由于数组参数的声明会被当作指针来看待，那么当模版参数是数组并且按值传递时，参数会被推导为指针类型。这意味着模板函数 <code>f</code> 的模板参数 <code>T</code> 会被推导为 <code>const char *</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>        <span class="c1">// name is array, but T deduced as const char*</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是现在问题出现了，尽管参数不能是一个真正的数组类型，但是我们可以声明一个数组的引用。因此当我们更改模板函数 <code>f</code> 使他接受引用参数时，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>        <span class="c1">// template with by-reference parameter</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后我们传入有一个数组，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>                 <span class="c1">// pass array of f</span>
</span></code></pre></td></tr></table></div></figure>


<p>类型推导会将 <code>T</code> 推导为数组类型，这个类型包括了数组的长度，在这个例子中，<code>T</code> 的类型被推导成为 <code>const char[13]</code>，函数 <code>f</code> 的参数类型为 <code>const char(&amp;)[13]</code>。</p>

<p>有趣的是，它提供了一种推导数组元素个数的方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// return size of an array as a compile-time constant. (The array parameter has no name,</span>
</span><span class='line'><span class="c1">// because we care only about the number of elements it contains.)</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>                                <span class="c1">// info</span>
</span><span class='line'><span class="n">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="n">noexcept</span>    <span class="c1">// below on</span>
</span><span class='line'><span class="p">{</span>                                                    <span class="c1">// constexpr</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">N</span><span class="p">;</span>                                        <span class="c1">// and</span>
</span><span class='line'><span class="p">}</span>                                                    <span class="c1">// noexcept</span>
</span></code></pre></td></tr></table></div></figure>


<p>与 Item 15 中解释的一样，声明一个 <code>constexpr</code> 函数，那么它的返回值在编译期就确定了。这就让用一个已知的数组去声明一个同样大小的数组成为可能：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">keyVals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">35</span> <span class="p">};</span>    <span class="c1">// keyVals has 7 elements</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">mappedVals</span><span class="p">[</span><span class="n">arraySize</span><span class="p">(</span><span class="n">keyVals</span><span class="p">)];</span>               <span class="c1">// so does mappedVals</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，作为一个现代的 C++ 程序员，你会很自然的习惯于用 <code>std::array</code> 来代替内建的数组类型，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">keyVals</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mappedVals</span><span class="p">;</span>   <span class="c1">// mappedVals&#39; size is 7</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>arraySize</code> 声明时带着 <code>noexcept</code>，这帮助编译器生成更好的代码。详细内容，参见 Item 14。</p>

<h4>函数参数</h4>

<p>在 C++ 中，不是只有数组才会退化成指针。函数类型可以退化成函数指针，上面我们讨论的关于数组的类型推导规则也适用于函数，只是退化成函数指针而已。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>    <span class="c1">// someFunc is a function;</span>
</span><span class='line'>                               <span class="c1">// type is void(int, double)</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>              <span class="c1">// in f1, param passed by value</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>             <span class="c1">// in f2, param passed by ref</span>
</span><span class='line'>
</span><span class='line'><span class="n">f1</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>                  <span class="c1">// param deduced as ptr-to-func;</span>
</span><span class='line'>                               <span class="c1">// type is void (*)(int, double)</span>
</span><span class='line'><span class="n">f2</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>                  <span class="c1">// param deduced as ref-to-func;</span>
</span><span class='line'>                               <span class="c1">// type is void (&amp;)(int, double)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在日常的使用中，这几乎没有什么区别，但是如果你已经知道了数组会退化成指针，那么你也会很自然的知道函数到指针的退化。</p>

<p>这就是模板类型推导的规则。大部分情况下它非常简单。左值在传递给全局引用时的推导有些稍微不同，但是数组和函数类型的退化更让人迷惑。有时候你会想抓住编译器问，“告诉我你在推导什么类型！” 这个时候，你需要 Item 4 中的内容，它会告诉你如何查看正在推导的类型。</p>

<h2>需要记住的</h2>

<ul>
<li>在模板类型推导时，引用类型的参数会被当作非引用，即引用限定会被忽略。</li>
<li>当推导类型是全局引用时，左值会被特殊对待。</li>
<li>当推导值传递参数时，<code>const</code>, <code>volatile</code> 会被忽略。</li>
<li>在类型推导时，数组以及函数名会退化为指针，除非它们被用来初始化引用变量。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Effecticve Modern C++》预览]]></title>
    <link href="http://bitdewy.github.com/blog/2014/07/21/effective-modern-cpp-preview/"/>
    <updated>2014-07-21T22:14:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/07/21/effective-modern-cpp-preview</id>
    <content type="html"><![CDATA[<p>虽然最近工作在用 javascript, 但 C++ 也没放下, <a href="http://www.aristeia.com">Scott Meyers</a> 的新书《Effective modern C++》终于在 O&#8217;Reilly <a href="http://shop.oreilly.com/product/0636920033707.do">上架了</a>. 第一时间买了一本. 2年前的时候, <a href="http://www.aristeia.com">Scott</a> 就给了<a href="http://blog.bitdewy.me/blog/2012/06/24/effective-c-plus-plus-11/">一版</a> Effective C++11 的初步想法, 两年后的今天, 顺带着 C++14 终于正式出炉了, 不过目前还是 early release 版本, 还没有经过 review, 正式版要到年底才会放出.</p>

<p>不得不说, C++ 现在终于有了它该有的样子. 大致浏览了一下, 如果现在才开始关注 C++11/C++14 的话, 非常推荐这本书. 如果看过前两代 《Effective C++》和《More effective C++》的话, 那你会再次找到久违的感觉.</p>

<p>全书共分为 6 章, 包括: 类型推导, 新关键字 auto, C++98 到 C++11/14 的变化, 智能指针, 右值引用转移语义与完美转发, lambda 表达式, 并发 API.</p>

<p>关于类型推导, 由于 C++11/14 引入了新的关键字 <code>auto</code>, <code>decltype</code>, 以及新的概念右值引用, 那么类型推导就不仅仅存在于模板中了, 因此从现在开始掌握类型推导的规则是 C++ 的必备技能了.</p>

<p>C++11/14 和以前相比, 变化非常的大, 在这本书中, 用了近 1/3 的章节来讲述如何从 C++98 过度到 C++11/14. 有些甚至推翻了之前的推荐做法, 比如 Item 13: Prefer const_iterators to iterators 就与作者之前的 《Effective STL》中的 item 26 完全相反. 所以对于每个写 C++ 代码的人来说, 这一部分是必须要更新的知识.</p>

<p>对于智能智能, 相信大家早就不陌生, 作者的《More Effective C++》中也讲到了智能指针. 这一次, 终于成为了标准, 本书中也讲到了各种类型智能指针合适的使用场景, 掌握了这些之后, 相信资源管理的问题, 就能够减少很多了.</p>

<p>转移语义很好的解决了性能问题, 完美转发解决了模板函数重载时爆炸式增长的问题, 而右值引用就是这两个特性的基础. 对于那些写库的人来说, 这些特性真是天大的好事.</p>

<p>关于 lambda 表达式, 有了 lambda 表达式, 标准库中的那些算法终于能变得好用了. 在没有 lambda 之前, 在使用每个标准库算法之前, 还需要一个仿函数, 这是一件多么不爽的事情.</p>

<p>对于并发, 在 C++98 以及之前, 标准连多线程的概念都没有, 我们只能使用平台相关的多线程设施, 甚至一些我们觉得没问题的多线程模型都会在这种情况下出问题. (比如: 这篇<a href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">C++ and the Perils of Double-Checked Locking</a>) 现在标准中不仅有了 thread, 甚至还有了更高级的 task, future, promise. 当然如果能有 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a> 就更好了, 不过这个特性可能要等到 C++17 了.</p>

<!-- more -->


<p>最后放出《effecticve modern C++》的目录</p>

<h4>Chapter 1 Deducing Types</h4>

<ul>
<li>Item 1: Understand template type deduction.</li>
<li>Item 2: Understand auto type deduction.</li>
<li>Item 3: Understand decltype.</li>
<li>Item 4: Know how to view deduced types.</li>
</ul>


<h4>Chapter 2 auto</h4>

<ul>
<li>Item 5: Prefer auto to explicit type declarations.</li>
<li>Item 6: Be aware of the typed initializer idiom.</li>
</ul>


<h4>Chapter 3 From C++98 to C++11 and C++14</h4>

<ul>
<li>Item 7: Distinguish () and {} when creating objects.</li>
<li>Item 8: Prefer nullptr to 0 and NULL.</li>
<li>Item 9: Prefer alias declarations to typedefs.</li>
<li>Item 10: Prefer scoped enums to unscoped enums.</li>
<li>Item 11: Prefer deleted functions to private undefined ones.</li>
<li>Item 12: Declare overriding functions override.</li>
<li>Item 13: Prefer const_iterators to iterators.</li>
<li>Item 14: Use constexpr whenever possible.</li>
<li>Item 15: Make const member functions thread-safe.</li>
<li>Item 16: Declare functions noexcept whenever possible.</li>
<li>Item 17: Consider pass by value for cheap-to-move parameters that are always copied.</li>
<li>Item 18: Consider emplacement instead of insertion.</li>
<li>Item 19: Understand special member function generation.</li>
</ul>


<h4>Chapter 4 Smart Pointers</h4>

<ul>
<li>Item 20: Use std::unique_ptr for exclusive-ownership resource management.</li>
<li>Item 21: Use std::shared_ptr for shared-ownership resource management.</li>
<li>Item 22: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle.</li>
<li>Item 23: Prefer std::make_unique and std::make_shared to direct use of new.</li>
<li>Item 24: When using the Pimpl Idiom, define special member functions in the implementation file.</li>
</ul>


<h4>Chapter 5 Rvalue References, Move Semantics, and Perfect Forwarding</h4>

<ul>
<li>Item 25: Understand std::move and std::forward.</li>
<li>Item 26: Distinguish universal references from rvalue references.</li>
<li>Item 27: Use std::move on rvalue references, std::forward on universal references.</li>
<li>Item 28: Avoid overloading on universal references.</li>
<li>Item 29: Familiarize yourself with alternatives to overloading on universal references.</li>
<li>Item 30: Understand reference collapsing.</li>
<li>Item 31: Assume that move operations are not present, not cheap, and not used.</li>
<li>Item 32: Familiarize yourself with perfect forwarding failure cases.</li>
</ul>


<h4>Chapter 6 Lambda Expressions</h4>

<ul>
<li>Item 33: Avoid default capture modes.</li>
<li>Item 34: Use init capture to move objects into closures.</li>
<li>Item 35: Use decltype on auto&amp;&amp; parameters to std::forward them.</li>
<li>Item 36: Prefer lambdas to std::bind.</li>
</ul>


<h4>Chapter 7 The Concurrency API</h4>

<ul>
<li>Item 37: Prefer task-based programming to thread-based.</li>
<li>Item 38: Specify std::launch::async if asynchronicity is essential.</li>
<li>Item 39: Make std::threads unjoinable on all paths.</li>
<li>Item 40: Be aware of varying thread handle destructor behavior.</li>
<li>Item 41: Consider void futures for one-shot event communication.</li>
<li>Item 42: Use std::atomic for concurrency, volatile for special memory.</li>
</ul>


<p>有时间的话, 后续会持续更新每一章节的具体内容.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript new keyword: yield]]></title>
    <link href="http://bitdewy.github.com/blog/2014/06/29/why-yield/"/>
    <updated>2014-06-29T22:14:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/06/29/why-yield</id>
    <content type="html"><![CDATA[<h2>生成器与迭代器</h2>

<p>在以前写代码的时候, 涉及到迭代算法时, 通常整个过程中都需要维护一个状态变量, 而我们想使用迭代算法的中间值得时候, 不得不使用回调函数.</p>

<p>下面是一个斐波那契数列的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">do_callback</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">fib</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">do_callback</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">j</span> <span class="o">+=</span> <span class="nx">t</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">n</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">fib</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中使用了回调函数, 将小于 10 的斐波那契数列的元素输出到控制台.</p>

<p>迭代器和生成器提供了一个新的, 更好的途径来做同样的事情. 下面是使用生成器实现的代码:</p>

<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="o">*</span><span class="nx">fib</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">yield</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">j</span> <span class="o">+=</span> <span class="nx">t</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">fib</span><span class="p">();</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的 <code>function *fib</code>, 函数体中含有关键字 <code>yield</code> 的函数就是生成器. 当你调用它的时候, 它的形参绑定到实参, 但函数本身并不进行求值, 而是返回一个 <code>generator-iterator</code>, 每调用一次 <code>generator-iterator</code> 的 <code>next</code> 方法, 迭代算法会进行一次. 每一步产生的值都由关键字 <code>yield</code> 返回. <code>yield</code> 关键字可以看做 <code>generator-iterator</code> 的返回值, 它代表迭代算法每次迭代的分界线. 每当调用 <code>next</code> 方法时, 生成器会接着从 <code>yield</code> 语句紧接着的下一句恢复状态继续执行.</p>

<p>我们循环调用生成器的 <code>next</code> 方法, 直到我们想要的结果, 上面的例子中, 我们打印了斐波那契数列的前 10 项. 但是生成器的版本允许我们生成任意多项, 只要继续循环调用 <code>next</code> 方法即可.</p>

<p>对于那些认为 <code>yield</code>, 生成器仅仅是语法糖的人, 我只能表示: 呵呵. 如果一个能影响编程时的思考方式的东西也叫做语法糖的话, 那么 <code>C</code> 是汇编的语法糖, <code>C++</code> 就是 <code>C</code> 的语法糖了.</p>

<p>对 <code>yield</code> 关键字有了概念之后, 我们来看看它都给我们带来了些什么.</p>

<h2>生成器是产生迭代器更好的方式</h2>

<p>学过 <code>python</code> 的同学应该知道 <a href="https://docs.python.org/2/library/functions.html#range"><code>range</code></a> 与 <a href="https://docs.python.org/2/library/functions.html#xrange"><code>xrange</code></a> 的区别. 如果不清楚的话, 见<a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange">这个</a>问题. 没错, <code>range</code> 会返回一个 <code>list</code>, 而 <code>xrange</code> 却是惰性求值的. (不是严格意义上的生成器, 但特性类似)</p>

<p>因此, 当我们需要遍历一个非常非常大的列表时, 一次性返回全部结果, 非常的消耗内存, 显然不是一个可行的办法. 我们需要惰性求值, 需要迭代器. 但实现一个迭代器, 我们需要手工维护迭代器的内部状态, 实现 <code>next</code> 方法等等. 此时就该轮到我们的生成器登场了.</p>

<p>使用生成器我们可以仅仅使用一个 <code>function</code> 就实现一个具有内部状态的迭代算法. That&rsquo;s awesome!</p>

<p>我在写 <a href="http://blog.bitdewy.me/roar/">roar</a> 时, 实现惰性求值是一个纠结的问题, 由于 <code>C++</code> 没有生成器类似的特性, 迭代器都是手工完成的, 需要手工维护迭代器状态, 容易出错, 而且实现其他功能也会带来阻碍, 举个例子, 如果 <code>C++</code> 支持 <code>yield</code> 的话, 那么 LINQ 的 concat 函数一个可能的实现就是下面这样了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Collection</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">typename</span> <span class="n">Collection</span><span class="o">::</span><span class="n">iterator</span> <span class="n">concat</span><span class="p">(</span><span class="n">Collection</span> <span class="n">a</span><span class="p">,</span> <span class="n">Collection</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">yield</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">yield</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从思考到实现都是那么的流畅, 而不用像现在一样还在纠结如何才能在不对 <code>Collection</code> 进行合并操作就能让迭代器很好的工作这个问题了.</p>

<h2>yield 不仅仅为迭代器而生</h2>

<p>本质上, <code>yield</code> 语句就是利用编译器/解释器替我们做了CPS变换而已. 而CPS变化是控制流的最主要武器. 也许, yield 能帮我们简化控制流, 远离 callback hell?</p>

<p>先来回顾一下 <code>yield</code> 的用法及执行过程, 当遇到 <code>yield</code> 语句时, 生成器函数暂停, 交出控制权, 当外部指定生成器函数继续时(调用 <code>next</code> 方法), 控制权又交回生成器函数继续执行直到下一个 <code>yield</code> 语句. 如果我们能够将所有耗时/已经是异步 callback 的函数更改为 <code>yield</code>, 然后在 callback 中直接调用生成器的 <code>next</code> 方法, 那么我们就可以完全的抛弃 callback 来优雅的完成控制流. 已经有人利用生成器的特性完成这个功能了. 见 <a href="https://github.com/jmar777/suspend">suspend</a>.</p>

<p>对异步编程稍微有点研究的话, 相信不难从上面看到 await 的影子, async 和 await 是 C# 5.0 中引入的关键字, 它使得异步编程变得更简单, await 与 yield 类似, 会暂停并交出控制权, 之前的 <a href="http://blog.bitdewy.me/blog/2013/12/23/cps-async/">异步编程和延续传递风格</a> 和 <a href="http://blog.bitdewy.me/blog/2013/08/20/async-and-await/">异步编程 async &amp; await</a> 提到过相关内容. C++ 也会引入相应的标准, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a> 的提案就是 async &amp; await 的 C++ 版.</p>

<p>遗憾的是, 虽然 <code>yield</code> 虽然进入了 ES6, 但是 <code>await</code> 却没有. 如果 <code>await</code> 能够进入标准的话, 那么也许可以早日改善流程控制库满天飞的局面. ╮(╯▽╰)╭</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/">Python yield 使用浅析</a></li>
<li><a href="http://legacy.python.org/dev/peps/pep-0255/">PEP 255 &mdash; Simple Generators</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/hh191443.aspx">Asynchronous Programming with Async and Await</a></li>
<li><a href="http://www.cppblog.com/vczh/archive/2013/07/27/202154.html">如何设计一门语言（八）——异步编程和CPS变换</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[首尔-釜山-青岛8日游]]></title>
    <link href="http://bitdewy.github.com/blog/2014/05/15/korea-seoul/"/>
    <updated>2014-05-15T22:57:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/05/15/korea-seoul</id>
    <content type="html"><![CDATA[<p>五一假期请了 3 天假, 和几个比较好的朋友一起韩国自由行. (原本预谋好的是台湾自由行, 但是由于小伙伴的证件问题, 只能换了路线 ╮(╯▽╰)╭)</p>

<p>出国当然必备护照, 据说有小伙伴办护照填表格瞎填一通, 还被带到了小黑屋.( ⊙ o ⊙ ). 大家要小心千万不要乱填哈. 关于护照可以参考<a href="http://blog.bitdewy.me/blog/2014/01/28/passport/">这里</a>.</p>

<p>韩国签证还是比较容易办理, 如果没时间去领事馆的话淘宝花 300 块钱左右就可以代办了, 不需要本人办理, 不需要面签.</p>

<p>酒店在国内提前订好, 回避广告, 就不说在哪里定的了, 行程安排是 首尔-釜山-首尔 各住 2 晚. 人均 200 CNY/天. 釜山便宜一些, 首尔较贵, 但住的都不差. 如果能稍微提高一点点预算的话, 能住的非常好呢.</p>

<p>特别安排了 首尔-釜山-首尔 的路线, 坐了韩国的 KTX 高铁, 对外国游客韩国有 KR PASS, 可以直接在网站上预定. 定了 3 日票, 3 日内可以韩国火车随便乱坐, 虽然我们只坐了 首尔-釜山 的往返, 但也比直接买票划算不少. 关于 KR PASS 还差点搞出乌龙, KR PASS 有普通票和同行票, 同行票需要一个普通票带着才可以, 一张普通票最多可以带 5 个同行票(大概是 9 折左右的优惠), 差点全都买成同行票, 还好在出发前又重新定好. 人均 520 CNY.</p>

<p>作为马斯洛需求体系最底层的 WiFi 需求, 当然要提前做好工作, 由于不通韩语, 英语又没信心 ╮(╯▽╰)╭, 最终决定在国内定 wifi egg(3G路由), 国内还. 40CYN/天. 如果是韩国取韩国还的话, 还能再便宜一些. 但是作为一个极度缺乏安全感的人来说, 还是选择了多花一点点钱, 保证万无一失. ^_^</p>

<p>虽然做了不少准备工作, 也还是有不少 bug, 同行的小伙伴没有一个人用的是 中国电信, 而韩国只有 CMDA2000, 导致大家电话都无法使用, 不过 7-11 就有卖电话卡, 也不是什么大问题. 但是毕竟出门在外, 避免有了信号大家乱跑, 最终还是一致决定所有人都紧紧围绕在 WiFi egg 周围, 保持队形.(<em>^__^</em>) 不分开.</p>

<p>最后就是机票了, 往返机票大约 2400 CNY/人. 国际机票税比较高. 提前一个月定的机票, 如果再提前一些的话可能还会更便宜.</p>

<p>废话结束.</p>

<!-- more -->


<h2>Day0 北京-首尔-明洞-首尔塔</h2>

<p>提前在某网站定了车, 一大早4点多钟就起来, 5点钟从我大石景山出发, 一路浩浩荡荡 50 多公里到机场, 只花了 78 块钱. 司机人也超级 nice. 简直赚翻了. 一路过了海关, 安检, 到了国际隔离区第一件事请就是取 WiFi egg, 飞机很准时, 8:10 准时起飞, 上了飞机就开始补充睡眠了.</p>

<p>到首尔大概是中午了, 首先去换了一点点零钱, 机场的汇率很不划算, 少换一点点, 够公交卡就可以了. 到了之后首先是要安顿下来.</p>

<p>由于语言不通, 出行的方式选择了确定性最高的地铁, 各种便利店 7-11, CU 都有卖 T Money 公交卡, 自动售票机器可以充值. 全国通用, 在韩国 7 天到处乱跑, 大概花了 26000 KRW, 约合 150 CYN.</p>

<p><img src="http://5oelva.by3302.livefilestore.com/y2pXmwtkkqrS_9h4v1gs-sN80jgqUJziCii8RJVzL1Gl7alLT6GLlNJFSlkhRz4plVxWxYDd_lXkU-jnVBP2XaO40aNlEDICeEOpEw7JOu-zWM/0.png" alt="去酒店的路上" /></p>

<p>第一站首尔塔附近的酒店, 这是这次行程中最好的一家酒店, 有早餐, 有中文服务, 去釜山时候轻装上阵, 旅行箱也存在这家店里.</p>

<p>稍事休息之后, 向第一站明洞出发. 韩国的街区都叫做 xx 洞. 明洞应该是比较有名的商业区, 在我大宇宙中心-五道口, 还有一家店叫明洞排骨呢. 这里的汇率比较高, 在这里换钱比较合算, 一次性多换一些吧. 如果有不需要转换金的外币卡的话, 刷卡也是蛮划算的, 另外韩国很多地方都支持银联哦, 可以直接人民币消费.</p>

<p><img src="http://4uelva.by3302.livefilestore.com/y2pXJ9WZ8wqh2KaXCO1m84PN6Jl0RlvMBBFC_Z-frvbRjAFDnLA3FdGdNCGZZeiQUllGu_q8DWNKuYejNZ458KbKgOycOMPoj8mCFTWtXFmCMk/1.png" alt="明洞" /></p>

<p>第一天, 都比较羞涩, 就吃了些路边摊, 瞎逛, 没买什么东西就撤了. 晚餐是在明洞的一家有名的石锅拌饭.</p>

<p><img src="http://4pelva.by3302.livefilestore.com/y2p8iJie2FXBK0ZIghVur0XkzgD_xBdG1WqfaD400CPiHabTYUXz9ykUDoQFUF0Jq4XPi-P2rLlVQxmYw3q6bVWs4ctGlhYi1G9wvo_6m2IFRQ/2.png" alt="泉州中央会馆" /></p>

<p>要坐着吃, 才有韩国范儿. 石锅拌饭来啦.</p>

<p><img src="http://3uelva.by3302.livefilestore.com/y2pFGsUCvjj2b4MdTVD5ZqS7_yBV-28o-Uhj1V_xIOnnvss-aUS_A13G-K7SWq-JIKvoWk7uJBRVwSKBIjZ_K9NTf3Ddh1ikRigzmIcpcYkNMs/3.png" alt="石锅拌饭来啦" /></p>

<p>晚饭结束后去了首尔塔, 就是这根粉红色的柱子. 地图上看没多远, 但是爬山爬了好一会儿.</p>

<p><img src="http://3eelva.by3302.livefilestore.com/y2pIY_4c1g7-8z1rnm_TflD2wlXgyrsUn19FsQdFppF-OELzlQPtJcNztFC9sk75Zz-goy9YRCTJeZkQ7Z9ID91C0Hq9ChpXfwogDgaYJG9eCo/4.png" alt="首尔塔" /></p>

<p>原本还计划去 泰迪熊博物馆 也没有去~ ╮(╯▽╰)╭, 首尔塔上卖的糖果.</p>

<p><img src="http://3pelva.by3302.livefilestore.com/y2pv68fU3d-mgHL8-RQYdk1yWued3uHS_eTuWrhmCkqDaEHgCmZI5V3l_O1L6MJCxGqaeYJKi_pamxqbl9WMU7yXoZT4wupG0vkvP7LBIHpYL4/5.png" alt="首尔塔" /></p>

<p>有卖明信片, 买了两张, 寄给朋友一张, 寄给自己一张.</p>

<p><img src="http://4oelva.by3302.livefilestore.com/y2pWviiosjd8vBXTo_b7Lt5jJoHlTeobzO65-zw8lo2mPhiHKx9bU3ICWce9f685qMCvsZRxu72Nd_J9_e2bKhIilLv36uYrKfs68G6VLR7ErI/6.png" alt="首尔塔明信片" /></p>

<p>首尔塔上晒幸福</p>

<p><img src="http://2uelva.by3302.livefilestore.com/y2pGVqznVXe959WD6g_0wDnfd21pcpK6P_X-tvTckqfwz2dHDbXCbzCFbQf6qNQMCtRuRZdjX7PjmF1ODismx-7DeICFZOgXU0E68g2PC9f73Y/7.png" alt="" /></p>

<p>好多锁, 超级多.</p>

<p><img src="http://2eelva.by3302.livefilestore.com/y2py9E95pR5WuxB7ocn7RjQYMhI1ETz9QZHE9EzL28uk1gFBJX0lGQXWvctJV1lL68Ane9pbXtYhVYETAIK6kFDlJEYnES0EMlDwTGd5fJQk9E/8.png" alt="" /></p>

<p>从首尔塔回去已经很晚了, 第一天完.</p>

<h2>Day1 仁寺洞-景福宫-三清洞-梨花壁画村-东大门</h2>

<p>第二天, 首先是早餐~(≧▽≦)/~啦啦啦. 有免费早餐还是很幸福的.</p>

<p><img src="http://4ecmmq.by3302.livefilestore.com/y2p7YmYtKKg-Gg6bAe0IebBomsTDMApkCUDt222Sz64-GRgkO8Nv63dSPFrHxtP1WfRuhtKGwzc7ojzbREz5X39EKkQEpTIf-nEk3v82cBCoeo/9.png" alt="早餐" /></p>

<p>韩国的主题, 就是逛街. 早餐过后来到了仁寺洞, 来的太早, 很多店都还木有开门. 全是鸟文, 不知道是神马意思.</p>

<p><img src="http://4ucmmq.by3302.livefilestore.com/y2pMTD4jk2udiJdStPL3aZFH7fd0CWl57dHt_92mgEvvkeomvGMtDEIG9DoP1I4IN2wKIlHzTBb2lQ0VfZ03LOVuOa2QiIXRRwSUVJLARa7KXw/10.png" alt="仁寺洞" /></p>

<p>不知道这个 &ldquo;人人&rdquo; 到底是神马意思, 别人游记中都拍这个, 那我也拍一张吧.</p>

<p><img src="http://4pcmmq.by3302.livefilestore.com/y2pyo8phOB8SHKYCnHAvcFb6nso0W2iasLeuojI1O9eooGru_0koL4kmNLd2XQ_adQADUVCn_3Z76GEpDNDztJmn543kuozfemRQH9VjSrQ3z8/11.png" alt="仁寺洞人人" /></p>

<p>韩国地铁</p>

<p><img src="http://5ocmmq.by3302.livefilestore.com/y2pKpORkeBCHavPB2f17uj7Y5LVQhSeKoCUozoNEmUb1G6XaDDFg26FYixT4vmcSsBBfUxZtsNprbKbO0wL-q7B65etZiX2XycuCUpvdWNeARw/12.png" alt="地铁" /></p>

<p>从仁寺洞坐一站地铁来到了景福宫, 还碰巧赶上了表演, 里面没神马好看的, 貌似有很多棒子的宫廷剧是在景福宫拍摄的, 虽然我也没看过. ╮(╯▽╰)╭</p>

<p><img src="http://3ecmmq.by3302.livefilestore.com/y2pqQFCRxE3UomM386iBExwgYOIucj7DipGcI2_0ZqGhvJV4PgyGoFWdZupn00XRW0CgRtxooXz7o5wa1Rij-zXfWWYSllkfTsqwNoJ41lKSGo/13.png" alt="景福宫表演" /></p>

<p>午饭时间, 来到了景福宫旁边的任何时候都排长队的土俗村参鸡汤, 鸡肚子里有糯米, 板栗, 红枣, 人参, 好吃. ( ⊙ o ⊙ )！ 可惜餐前忘记了拍照给食物消毒. (╯‵□′)╯︵┻━┻ 来张店里的风景吧. 还是坐地上吃. 各种腿麻.</p>

<p><img src="http://3pcmmq.by3302.livefilestore.com/y2pxqXZmDb6W024ho_Sd9FjR22bOSowKCvydxI10fodDTwn2y8GwdYGtQ6vmFBKuGSvH8E4Oyxf3bTHbPO82uxVs1EIGlFrpVIHNNmwvDDxyOg/14.png" alt="参鸡汤" /></p>

<p>青瓦台, 韩国的中南海, 警备森然, 还不能乱拍照, 有小伙伴拍照, 被持枪的警察喝止.</p>

<p><img src="http://3ucmmq.by3302.livefilestore.com/y2pHfNP3YqRnQZAfdnLGF9qAffqYC_wUN248av08tjEXdMVilQGfDuKbFhwSIPAH4X1pIUopQgVoI-SsDMF9EGXGu0OvuTYu_Rid9TWetRZRYo/15.png" alt="青瓦台" /></p>

<p>过了青瓦台不远就到了三清洞, 又开始逛街. 逛完一洞又一洞. 乘地铁去逛大学路, 随便逛逛, 吃了路边摊. 然后徒步去梨花壁画村, 一度在发现了目标之后没当回事儿, 绕了一大圈才找到, 当返回的时候, 发现原来是这里的时候, 我们整个都斯巴达了. (╯‵□′)╯︵┻━┻.</p>

<p><img src="http://4ocmmq.by3302.livefilestore.com/y2pI8loNMMOQsDS9zB5SopnkKWsKafC5Ief4i10-7B_olgOWfC2ZVjEyQ8xH4QX0by4dEDLzOwlXKFdoU1ZbWu8lyGdX1kcPz1U8xICJkBf09Q/16.png" alt="壁画村" /></p>

<p>晚上的主题是东大门逛商场. 第二天完.</p>

<h2>Day2 首尔-釜山-南浦洞-海云台</h2>

<p>第三天一早, 收拾东西出发去釜山, 到达釜山已经接近中午, 天空不作美, 一来釜山就下大雨, 先去了南浦洞随便逛逛. 已经是第三天, 购物没第一天那么矜持了. 主旋律就是买买买. 天都黑了也要各种买.</p>

<p><img src="http://2ecmmq.by3302.livefilestore.com/y2p9loa-_d25Pzjlry5y0bWw1oChfz1kNd1XAL6oyV5XhCYw8jMK2N3Ic1rmn_NXskFRszZMFIWXo2JHQsyelHOAif-3UCCgdT-nP5CYRfZA4c/17.png" alt="南浦洞" /></p>

<p>来釜山就是为了海云台, 以前只吃过海云台, 这次可以见到真的了. 酒店就在海云台海水浴场很近的地方. 来了才发现, 这地方各种 Motel. ( ⊙ o ⊙ )</p>

<p><img src="http://2ucmmq.by3302.livefilestore.com/y2pQkUuZ1f7C6wxVaByFgsDVzJ9vNW9B49ATAbbPCN26dblFBMkgcqveZa816RLmwQCJk8FlW57JSoseeNeqxQLRh2wc6iC8U0aN3lOMicPRRQ/18.png" alt="海云台" /></p>

<p>睡的是地铺, 还在地板上发现了大量钞票. ( ⊙ o ⊙ )！</p>

<p><img src="http://4efbpq.by3302.livefilestore.com/y2p5FS31sa3mGgrY5uh6FJxF3205twkZIe7LK9lgI0NILPn1uwnIQUy11RHWH6yEsEH1NxY5ZUuKC0sKrJElrbVkQkDPMUI5XtzxgOt5OsT3lg/19.png" alt="海云台地铺" /></p>

<p>入住已经很晚了, 都懒得动, 只好派人去买晚饭, 还点名要炸鸡啤酒, 人生地不熟, 语言不通, 暴雨. 一路暴走, 走到了海边, 拍了些照片, 最后买了这些东西回来.</p>

<p><img src="http://4pfbpq.by3302.livefilestore.com/y2pX9YajED1sD-s6Sg4uC8DiT7hrf8mBPV17FTGNT5WFI-rU8qRkxiX9zdVdS0fMT6ZDHhAzWyrwzs7T_LnxOTyL0bRgRddBmVOQ_uokEOzLFA/20.png" alt="汉堡王" /></p>

<p>还有两瓶奇怪的东西乱入
<img src="http://5ofbpq.by3302.livefilestore.com/y2pjjMPS1w6jsGAMC8PuBY0Vey9dN1eK7Ho3dZSYgxFCHsp-L-zIlR6lrgo8QfQJGwf2jwaNcZjD9O3tNzCQ0Rj6qugmV6y8ukqgqsFk5roLQU/21.png" alt="" /></p>

<p>第三天就这么结束了.</p>

<h2>Day3 海云台-迎月路-VESTA汗蒸</h2>

<p>这是最舒服的一天, 主题就是玩沙子 + 汗蒸.</p>

<p><img src="http://4ufbpq.by3302.livefilestore.com/y2p_s1AL8MFrjxjEzcl2MsDb9YiVHcUehDA4bph7kbwa23AJ7VBFNlYtrUxRVG2FR1Ur_AWlKtrwlY6FarOBFqOoY24mKTCqWwZaY5Ze2Dy7sg/22.png" alt="海云台" /></p>

<p>拍照技巧之一拼星星</p>

<p><img src="http://3ufbpq.by3302.livefilestore.com/y2pDrFyr01vnAeSsKhdvhJMHxzHGLWxxrWiIJtdw2RCHswuQ4ZQD-1X6g4AEyKismWDKZu5qJBK2ra6fT1eo6rUJXlufe-swpm97K6XdIgWuqk/23.png" alt="拼星星" /></p>

<p>玩沙子玩到中午, 去吃了烤肉, 虽然语言不通, 但是老板娘很热情, 还帮烤好并喂到妹纸嘴里. 作为男孩子, 就木有这个福利了. ╮(╯▽╰)╭</p>

<p>下午的主题就是洗澡. 没法贴照片了. 第一次看着大海洗澡. 感觉还是很爽的, 哈哈.</p>

<p>晚上去吃了海鲜. 已经到了第 4 天, 拍照变得没那么勤快了.</p>

<h2>Day4 海云台-首尔-八色烤肉-弘大</h2>

<p>第 5 天早上, 早早的起来, 准备看日出, 可惜天气不好，云太厚 ╮(╯﹏╰）╭, 没能看成.</p>

<p><img src="http://3efbpq.by3302.livefilestore.com/y2pO07WFZTh0-ARIOoS3doc2z0Pks0hrH7Y_E3iiv9uMie4t_bCxO7LiEcpHl3UMoqbrMokRZX4AeFMRDcf1Ym3p-X3DrnzZhVnmzzD13K5k2s/24.png" alt="清晨的海云台" /></p>

<p>韩国海难刚过去不久, 有人在海云台边上点的蜡烛祈福</p>

<p><img src="http://3pfbpq.by3302.livefilestore.com/y2pfcilFVrjrj8Zi2anshIWhtG1T53QUktkeKP5p9TnEOGcwufxpOp_2jj8YAb_mX0WQlvQMirAQ0gdWUciamusc1eWBR6RP4V50K7fhxGmxQQ/25.png" alt="祈福" /></p>

<p>很遗憾, 没看成日出, 大家都表示要回笼. 回去回笼之后吃了早餐出发回首尔. 由于回笼太久, 到达首尔已经过了午饭时间, 大家一致表示晚上要吃一顿大的. 午餐就免了. 取回行李后, 赶到新的入住地点, 弘益大学附近. 入住之后, 在弘大附近瞎逛一下, 开始觅食寻找八色五花肉. 这家店在地下一层. 门面很不起眼. 路过都没看见. 一个韩国大叔看我们拿着 ipad 寻觅, 主动提供帮助, 一路我们领到了店门口. 好吃不贵, 感觉比国内还便宜, 肉也够厚, 味道很好.</p>

<p><img src="http://2ufbpq.by3302.livefilestore.com/y2ptkzspaxZG56Bj9FTcZZncDbEGLtGiKWSj08Aztr7uC8iP-69Q8Jdq8ixZ6UZH8v-lBzI8cWcVZ5iK1dBTFzus0DIIxuL2uRQuU35PtsNbFg/26.png" alt="八色五花肉" /></p>

<p>吃饱了, 逛街又有劲儿了. 第 5 日完.</p>

<h2>Day5 梨花女子大学-东大门-国立中央博物管-3D美术馆-炸鸡啤酒</h2>

<p>梨花女子大学, 不解释.</p>

<p><img src="http://4ofbpq.by3302.livefilestore.com/y2pXKgkblEDSkhXt6-qkPMIgO16FJiza5NF0ALTECImqE1B4x_y1sik8lk7yGDOzIn2XJXwEqBmbqx6zaO3CG92LiwzkxsBfxfBHgwnZDNpBSQ/27.png" alt="梨花女子大学" /></p>

<p>放眼望去全是妹纸, 不知道该看哪里.</p>

<p><img src="http://2efbpq.by3302.livefilestore.com/y2pg6187-yNBVPt6F358Rav3W6SDodEmVZwY7QvOwfJ5Bl1EIYnA3R7YyxygRBGY6Zwl1ioLxzereZkcWQ3POnfhf2LN-aQfo_F6GQQp0Ufdzo/28.png" alt="" /></p>

<p>在梨花女子大学的妇女文化博物馆还遇到了来学习的中学生(萝莉).</p>

<p>到了最后的日子, 只有疯狂的购物才是主旋律. 买的差不多了之后, 才想起要去国立中央博物馆看看, 可惜赶到的时候博物馆已经关门, 只能在博物馆外面围观.</p>

<p><img src="http://4edcgg.by3302.livefilestore.com/y2pmND85irttef8lFxrzm_S6CTndD3ZJ9h0PxygRv6WyvJX9iGbUIeiia4t9eLBr3jBJK3FKnWJuYk7fcyQBbmKdsQYyIt0OMniPJkjZse-6Mk/29.png" alt="国立中央博物馆" /></p>

<p>去博物馆未遂, 回到了住处继续逛弘大, 去了 3D 美术馆, 各种拍照. 国内貌似也有不少这种地方. 可惜的是时间不多, 而我们却在外面免费的地方折腾了超长时间. 囧o(╯□╰)o</p>

<p><img src="http://4udcgg.by3302.livefilestore.com/y2pTKsz1Zz9G0ul-ClsJ2fzdXjq651IWCFX2DTkwk7ssaR-pGTZ48YenqWlpTVc80WAWUTpQ-ux3gqKhNKsRoh-z__h9JQF5pHTDm-yYt9j8Ps/30.png" alt="" /></p>

<p>这是在韩国的最后一晚, 当然少不了炸鸡啤酒. 跋山涉水走了 N 个街区找到了这家有名的店.</p>

<p><img src="http://4pdcgg.by3302.livefilestore.com/y2pm6sIn3zKwjuVRNb_PUWwvrRdtI-juRTIMS_yLCkANoU1is2rgCvPKY62o_VhgILeYXzNTkqUORbVxb328Do1Txc6omzlIqpw8jjbElikG9M/31.png" alt="炸鸡啤酒" /></p>

<p>尽兴而归, 又是买买买, 在一家化妆品店里一次买了 210000 KRW 的东西, 导购妹子各种热情, 送了不少东西, 还送了每人一瓶玫瑰茶. 第 6 天完.</p>

<h2>Day6 梨花女子大学-仁川机场-青岛</h2>

<p>最后一天疯狂的购物, 又来到了梨花女子大学附近, 发现了 工口 乱入.</p>

<p><img src="http://5odcgg.by3302.livefilestore.com/y2p4a-87Qq57mnzyWrUC75ysdhh6ELoM_NAc9AHZNX9-SHtnVwSUx9xSOWWtASyVss6W4d0jznZvo1uEE7WBGgkZsZB2o0PZxC1fe2pnp8dyBk/32.png" alt="工口" /></p>

<p>买了一上午之后, 就要赶去机场准备回国了, 在我们离开韩国地铁 2 号线到达机场一个小时之后, 它就撞了. ( ⊙ o ⊙ ). 好惊悚. 机场退税退了不少, 全都在免税店花完了. ╮(╯▽╰)╭</p>

<p>下午 6 点就到了青岛, 住小伙伴家, 家长各种款待. 都不好意思了.</p>

<h2>Day7 青岛</h2>

<p>小伙伴家住八大关, 家门口各种游客, 我们进进出出, 游客都会投来诧异的目光. 他的麻麻还在淘宝上淘了个复古的报箱挂在大铁门上, 不少游客都以报箱为背景拍照. 忘了照报箱了, 随便拿一张八大关的照片顶一下吧.</p>

<p><img src="http://3edcgg.by3302.livefilestore.com/y2pSBtjYAoqIFITiZt-mOE87vxfXuRFNQy3tBxl1d8V7X9S7h8nsk8bPPo4ZSi7g3S0b_GyLpDB5h_QA6Bwmd_ZXHSaBCRgL7xD7jWErj670ZE/33.png" alt="八大关" /></p>

<p>这一天, 沿着青岛海岸线一路狂奔, 并发现了美女.</p>

<p><img src="http://3udcgg.by3302.livefilestore.com/y2pT72VndPKJpoLOzIAIZeg4IyiErhVAMyR2e-j5eCd73Jr2fQnygbNudrlgOOD1ZQbTN2si5jcUFttQ899Jas7tiGqm5pFphiojquTA0a2yLk/34.png" alt="美女" /></p>

<p>一路上的风景都很不错, 晚上6点从青岛出发回北京, 第二天上班. 8 天的旅行就这么结束了.<del>(>_&lt;)</del> 什么时候再去( ⊙ o ⊙ )啊！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 前端开发小测验, part 1 之 CSS]]></title>
    <link href="http://bitdewy.github.com/blog/2014/03/09/front-end-web-development-quiz-part1-css/"/>
    <updated>2014-03-09T01:30:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/03/09/front-end-web-development-quiz-part1-css</id>
    <content type="html"><![CDATA[<p>这是 <a href="http://www.devqin.com/">@devqin</a> 在 <a href="http://bb.ijser.cn/topic/46/%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E5%BE%97%E5%88%B0%E5%A4%9A%E5%B0%91%E5%88%86-%E8%87%AA%E6%88%91%E6%84%9F%E8%A7%89%E8%89%AF%E5%A5%BD%E8%80%85%E8%8E%AB%E5%85%A5-%E5%9B%A0%E4%B8%BA-%E5%AE%98%E6%96%B9%E8%AF%B4%E7%9A%84%E6%98%AF-maight-hurt-your-feelings">NADbb</a> 上发的一个找虐的测试. (原作者有个提示: Warning: might hurt your feelings).</p>

<p>我来挨个找证据, 今天是 part 1, CSS 部分.</p>

<h4>1)</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">MaRGin</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Are CSS property names case-sensitive?</p>

<p>CSS 属性名是大小写敏感的吗 ?</p>

<p><strong>答</strong>: 不敏感. <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 的 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#forward-compatible-parsing">7.1 Forward-compatible parsing</a> 最后有这么一段话,</p>

<blockquote><p>All CSS style sheets are case-insensitive, except for parts that are not under the control of CSS. I.e., in CSS1, font family names and URLs can be case-sensitive. Also, the case-sensitivity of the CLASS and ID attributes is under the control of HTML.</p></blockquote>

<p>因此, 只有不受 CSS 控制的, 如 <code>font family</code> 的名字, <code>url</code>, 以及受 <code>HTML</code> 控制的 <code>ID</code> 和 <code>class</code> 大小写敏感, 其他受 CSS 控制的内容都是大小写不敏感的.</p>

<h4>2) Does setting <code>margin-top</code> and <code>margin-bottom</code> have an affect on an inline element ?</h4>

<p><code>margin-top</code> 与 <code>margin-bottom</code> 对内联元素是否有效 ?</p>

<p><strong>答</strong>: 没效果, <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 的 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#inline-elements">4.2 Inline elements</a> 中有如下描述:</p>

<blockquote><p>If the inline element has margins, borders, padding or text decorations attached, these will have no effect where the element is broken.</p></blockquote>

<p>CSS2.1 中, <a href="http://www.w3.org/TR/CSS21/box.html#propdef-margin-bottom">8.3 Margin properties: &lsquo;margin-top&rsquo;, &lsquo;margin-right&rsquo;, &lsquo;margin-bottom&rsquo;, &lsquo;margin-left&rsquo;, and &lsquo;margin&rsquo;</a> 节关于 <code>margin-top</code> 和 <code>margin-bottom</code> 有如下描述:</p>

<blockquote><p>These properties have no effect on non-replaced inline elements.</p></blockquote>

<p>关于 non-replaced 与 replaced element 的定义可以参考 CSS2.1 中的 <a href="http://www.w3.org/TR/CSS21/conform.html#replaced-element">Replaced element</a></p>

<h4>3) Does setting <code>padding-top</code> and <code>padding-bottom</code> on an inline element add to its dimensions ?</h4>

<!-- more -->


<p><code>padding-top</code> 与 <code>padding-bottom</code> 会增加内联元素的大小吗 ?</p>

<p><strong>答</strong>: 不会, <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 的 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#inline-elements">4.2 Inline elements</a> 中有如下描述:</p>

<blockquote><p>If the inline element has margins, borders, padding or text decorations attached, these will have no effect where the element is broken.</p></blockquote>

<p>CSS2.1 中, <a href="http://www.w3.org/TR/CSS21/visudet.html#Computing_heights_and_margins">10.6.1 Inline, non-replaced elements</a> 节, 有如下描述:</p>

<blockquote><p>The vertical padding, border and margin of an inline, non-replaced box start at the top and bottom of the content area, and has nothing to do with the &lsquo;line-height&rsquo;. But only the &lsquo;line-height&rsquo; is used when calculating the height of the line box.</p></blockquote>

<p>因此, 只有 <code>line-height</code> 属性才能改变内联元素的高度.</p>

<h4>4) If you have a <code>&lt;p&gt;</code> element with <code>font-size: 10rem</code>, will the text be responsive when the user resizes / drags the browser window?</h4>

<p>当拖动浏览器窗口大小时, 有 <code>font-size: 10rem</code> 属性的 <code>&lt;p&gt;</code> 元素中的文本内容是否会有反应 ?</p>

<p><strong>答</strong>: 不会有反应. CSS3 中, 对 <a href="http://www.w3.org/TR/css3-values/#font-relative-lengths">rem unit</a> 有如下描述:</p>

<blockquote><p>Equal to the computed value of ‘font-size’ on the root element. When specified on the ‘font-size’ property of the root element, the ‘rem’ units refer to the property&rsquo;s initial value.</p></blockquote>

<p>因此 <code>&lt;p&gt;</code> 元素中的文本内容只与根元素的字体大小有关, (主流的浏览器, 默认根元素的 <code>font-size</code> 为 <code>16px</code>), 而拖动窗口大小是不会改变根元素的 <code>font-size</code> 属性值的. 所以不会有反应.</p>

<h4>5) The pseudo class <code>:checked</code> will select inputs with type radio or checkbox, but not <code>&lt;option&gt;</code> elements.</h4>

<p>伪类 <code>:checked</code> 会作用于 <code>radio</code> 或者 <code>checkbox</code>, 但是不会作用于 <code>&lt;option&gt;</code>.</p>

<p><strong>答</strong>: 错. CSS3 中, <a href="http://www.w3.org/TR/css3-selectors/#UIstates">6.6.4.2. The :checked pseudo-class</a> 中有如下描述:</p>

<blockquote><p>Radio and checkbox elements can be toggled by the user. Some menu items are &ldquo;checked&rdquo; when the user selects them. When such elements are toggled &ldquo;on&rdquo; the :checked pseudo-class applies. While the :checked pseudo-class is dynamic in nature, and can altered by user action, since it can also be based on the presence of semantic attributes in the document, it applies to all media. For example, the :checked pseudo-class initially applies to such elements that have the HTML4 selected and checked attributes as described in Section 17.2.1 of HTML4, but of course the user can toggle &ldquo;off&rdquo; such elements in which case the :checked pseudo-class would no longer apply.</p></blockquote>

<p>从上面的描述中可以看出, 除了 radio 和 checkbox 之外, 伪类 <code>:checked</code> 也可以作用于 HTML 标准中含有 <code>selected</code> 和 <code>checked</code> 属性的元素,  在 HTML4 <a href="http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.2.1">17.2.1 Control types</a> 一节的描述中包含 option, 因此 <code>:checked</code> 可以作用于 <code>&lt;option&gt;</code>.</p>

<h4>6) In a HTML document, the pseudo class <code>:root</code> always refers to the <code>&lt;html&gt;</code> element.</h4>

<p>在一个 HTML 文档中, 伪类 <code>:root</code> 总是代表 <code>&lt;html&gt;</code> 元素.</p>

<p><strong>答</strong>: 是. CSS3 <a href="http://www.w3.org/TR/css3-selectors/#root-pseudo">6.6.5.1. :root pseudo-class</a> 一节, 有如下描述:</p>

<blockquote><p>The :root pseudo-class represents an element that is the root of the document. In HTML 4, this is always the HTML element.</p></blockquote>

<p>而 HTML5 <a href="http://www.w3.org/TR/html5/semantics.html#the-root-element">4.1 The root element</a> 一节, 也有如下描述:</p>

<blockquote><p>The html element represents the root of an HTML document.</p></blockquote>

<p>所以, <code>:root</code> 就是 <code>&lt;html&gt;</code> 元素.</p>

<h4>7) The <code>translate()</code> function can move the position of an element on the z-axis.</h4>

<p>函数 <code>translate()</code> 可以在 z 轴上移动元素的位置.</p>

<p><strong>答</strong>: 错误. CSS Transforms Module Level 1 中 <a href="http://www.w3.org/TR/css3-transforms/#funcdef-translate">translate</a> 的定义如下:</p>

<p><code>translate() = translate( &lt;translation-value&gt; [, &lt;translation-value&gt; ]? )</code></p>

<blockquote><p>specifies a 2D translation by the vector [tx, ty], where tx is the first translation-value parameter and ty is the optional second translation-value parameter. If <ty> is not provided, ty has zero as a value.</p></blockquote>

<p>所以 <code>translate()</code> 函数是一个 2D 变换的函数, 仅仅能改变 x 与 y 轴的位置, 不能改变 z 轴的位置.</p>

<h4>8)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nt">li</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<p><strong>答</strong>: 蓝色.</p>

<p>首先来看一下标准中的描述, <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 中 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#cascading-order">3.2 Cascading order</a> 一节, 有如下描述.</p>

<blockquote><p>Conflicting rules are intrinsic to the CSS mechanism. To find the value for an element/property combination, the following algorithm must be followed:</p>

<ol>
<li><p> Find all declarations that apply to the element/property in question. Declarations apply if the selector matches the element in question. If no declarations apply, the inherited value is used. If there is no inherited value (this is the case for the &lsquo;HTML&rsquo; element and for properties that do not inherit), the initial value is used.</p></li>
<li><p>Sort the declarations by explicit weight: declarations marked &lsquo;!important&rsquo; carry more weight than unmarked (normal) declarations.</p></li>
<li><p>Sort by origin: the author&rsquo;s style sheets override the reader&rsquo;s style sheet which override the UA&rsquo;s default values. An imported style sheet has the same origin as the style sheet from which it is imported.</p></li>
<li><p>Sort by specificity of selector: more specific selectors will override more general ones. To find the specificity, count the number of ID attributes in the selector (a), the number of CLASS attributes in the selector (b), and the number of tag names in the selector (c). Concatenating the three numbers (in a number system with a large base) gives the specificity.</p></li>
<li><p>Sort by order specified: if two rules have the same weight, the latter specified wins. Rules in imported style sheets are considered to be before any rules in the style sheet itself.</p></li>
</ol>
</blockquote>

<p>第 4 条关于权重的细节跳过.</p>

<p>根据第 1 条, 显然 <code>li</code> 比 <code>ul</code> 元素匹配更精确, 因此选择 <code>li</code> 蓝色.</p>

<h4>9)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span> <span class="nt">li</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#must-buy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度, 两个一致, 都选择到了 <code>span</code> 的父元素 <code>li</code>.</li>
<li>显式声明的权重也一致.</li>
<li>这里不用考虑 CSS 文件, 用户, 以及浏览器默认的样式覆盖问题.</li>
<li>根据选择器的权重, <code>ID</code> 获胜.</li>
</ol>


<p>因此答案是: 蓝色.</p>

<h4>10)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.shopping-list</span> <span class="nc">.favorite</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#must-buy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度, 两个一致, 都选择到了 <code>span</code> 的父元素 <code>li</code>.</li>
<li>显式声明的权重也一致.</li>
<li>这里不用考虑 CSS 文件, 用户, 以及浏览器默认的样式覆盖问题.</li>
<li>根据选择器的权重, <code>ID</code> 获胜.</li>
</ol>


<p>因此答案是: 蓝色.</p>

<h4>11)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span><span class="nf">#awesome</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nt">ul</span><span class="nc">.shopping-list</span> <span class="nt">li</span><span class="nc">.favorite</span> <span class="nt">span</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度不一致, 虽然 <code>ul#awesome</code> 的权重很高, 但是只选到了 <code>span</code> 的父元素 <code>li</code>.</li>
</ol>


<p>因此答案是: 蓝色.</p>

<h4>12)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span><span class="nf">#awesome</span> <span class="nf">#must-buy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.favorite</span> <span class="nt">span</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="cp">!important</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度不一致, 虽然 <code>ul#awesome #must-buy</code> 的权重很高, 但是只选到了 <code>span</code> 的父元素 <code>li</code>.</li>
</ol>


<p>因此答案是: 蓝色. (即使没有 <code>!important</code> 也是蓝色.</p>

<h4>13)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span><span class="nc">.shopping-list</span> <span class="nt">li</span> <span class="nc">.highlight</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nt">ul</span><span class="nc">.shopping-list</span> <span class="nt">li</span> <span class="nc">.highlight</span><span class="nd">:nth-of-type</span><span class="o">(</span><span class="nt">odd</span><span class="o">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>答</strong>: 蓝色.</p>

<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度, 两个一致, 都选择到了 <code>span</code> 的父元素 <code>li</code>.</li>
<li>显式声明的权重也一致.</li>
<li>这里不用考虑 CSS 文件, 用户, 以及浏览器默认的样式覆盖问题.</li>
<li><code>ul.shopping-list li .highlight:nth-of-type(odd)</code> 多了一个伪类, 权重多 10.</li>
</ol>


<p>因此答案是: 蓝色.</p>

<h4>14)</h4>

<p>Given the HTML below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;shopping-list&quot;</span> <span class="na">id=</span><span class="s">&quot;awesome&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li&gt;&lt;span&gt;</span>Milk<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'>    <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;favorite&quot;</span> <span class="na">id=</span><span class="s">&quot;must-buy&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;highlight&quot;</span><span class="nt">&gt;</span>Sausage<span class="nt">&lt;/span&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the color of the text Sausage ?</p>

<p>Sausage 的颜色是 ?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#awesome</span> <span class="nc">.favorite</span><span class="nd">:not</span><span class="o">(</span><span class="nf">#awesome</span><span class="o">)</span> <span class="nc">.highlight</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#awesome</span> <span class="nc">.highlight</span><span class="nd">:nth-of-type</span><span class="o">(</span><span class="nt">1</span><span class="o">)</span><span class="nd">:nth-last-of-type</span><span class="o">(</span><span class="nt">1</span><span class="o">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据标准中的描述:</p>

<ol>
<li>元素选择的准确程度, 两个一致, 都选择到了 <code>span</code> 的父元素 <code>li</code>.</li>
<li>显式声明的权重也一致.</li>
<li>这里不用考虑 CSS 文件, 用户, 以及浏览器默认的样式覆盖问题.</li>
<li>这个题目是权重的题目, 但是 <code>#awesome .favorite:not(#awesome) .highlight</code> 的权重究竟是多少呢 ?</li>
</ol>


<p>CSS3 selectors <a href="http://www.w3.org/TR/css3-selectors/#specificity">9. Calculating a selector&rsquo;s specificity</a> 一节中有如下描述,</p>

<blockquote><p>Selectors inside the negation pseudo-class are counted like any other, but the negation itself does not count as a pseudo-class.</p></blockquote>

<p>所以, 很明显, <code>#awesome .favorite:not(#awesome) .highlight</code> 有两个 <code>ID</code> 两个 <code>class</code> 权重 220, 远远大于 <code>#awesome .highlight:nth-of-type(1):nth-last-of-type(1)</code> 的 130</p>

<p>因此答案是: 蓝色.</p>

<h4>15)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">&quot;example&quot;</span><span class="nt">&gt;</span>Hello<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#example</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">margin-bottom</span><span class="o">:</span> <span class="m">-5px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What will happen to the position of <code>#example</code> ?</p>

<p><code>#example</code> 的位置会有何变化 ?</p>

<p><strong>答</strong>: 后面的元素都向上移动 5px.</p>

<p>CSS2.1 标准 <a href="http://www.w3.org/TR/CSS21/box.html#padding-properties">8.4 Padding properties</a> 一节中有如下描述:</p>

<blockquote><p>Negative values for margin properties are allowed, but there may be implementation-specific limits.</p></blockquote>

<p>这个题目是 browser specific 的, 不过大部分主流的浏览器实现方式都是一致的. 可以参考这里: <a href="http://coding.smashingmagazine.com/2009/07/27/the-definitive-guide-to-using-negative-margins/">http://coding.smashingmagazine.com/2009/07/27/the-definitive-guide-to-using-negative-margins/</a></p>

<p><img src="https://xf8dta.by3302.livefilestore.com/y2p5iAEbpvpJ4V698_MY1TJEkWQirSTMe36n8ag5WbwJCdcv_U-_f76T_HKTl_5zhaqklMq_ND0fmuYxLBLT8RIEJi0rzr-pwYbmsK0WmxI_lc/margin-motion.gif" alt="" /></p>

<h4>16)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p</span> <span class="na">id=</span><span class="s">&quot;example&quot;</span><span class="nt">&gt;</span>Hello<span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#example</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">margin-left</span><span class="o">:</span> <span class="m">-5px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What will happen to the position of <code>#example</code> ?</p>

<p><code>#example</code> 的位置会有何变化 ?</p>

<p><strong>答</strong>: 像左←移动 5px. 证据同上一题.</p>

<h4>17)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;test1&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">&quot;test2&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#i-am-useless</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&#39;mypic.jpg&#39;)</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Are unused style resources still downloaded by the browser?</p>

<p>浏览器会下载未使用的样式资源吗 ?</p>

<p><strong>答</strong>: 不会. 这又是一个 browser specific 的题目. 不过主流的浏览器都会遵循 <code>lazy-loading</code> 的原则. 因此这个图片不会下载.</p>

<h4>18)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;test1&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">&quot;test2&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#test2</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&#39;mypic.jpg&#39;)</span><span class="p">;</span>
</span><span class='line'>    <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>On page load, will <code>mypic.jpg</code> get downloaded by the browser ?</p>

<p>页面加载时, 浏览器会下载图片 <code>mypic.jpg</code> 吗 ?</p>

<p><strong>答</strong>: 会. 虽然属性 <code>display</code> 的值为 <code>none</code>, 但是图片仍然会被下载, 因为 css 文件解析是自上而下的, 因此当解析到 <code>background-image</code> 时, 没有足够的信息表明 test2 将不会显示时, 因此图片会下载.</p>

<h4>19)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;test1&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">&quot;test2&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#test1</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#test2</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&#39;mypic.jpg&#39;)</span><span class="p">;</span>
</span><span class='line'>    <span class="k">visibility</span><span class="o">:</span> <span class="k">hidden</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>On page load, will <code>mypic.jpg</code> get downloaded by the browser ?</p>

<p>页面加载时, 浏览器会下载图片 <code>mypic.jpg</code> 吗 ?</p>

<p><strong>答</strong>: 不会. 与上面的分析一致, 只是此时已有足够的信息表明 <code>test2</code> 将不会显示.</p>

<h4>20)</h4>

<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="k">@media</span> <span class="nt">only</span> <span class="nt">screen</span> <span class="nt">and</span> <span class="o">(</span><span class="nt">max-width</span><span class="o">:</span> <span class="nt">1024px</span><span class="o">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">margin</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is the use of the <code>only</code> selector ?</p>

<p><code>only</code> 选择器的作用是什么 ?</p>

<p><strong>答</strong>: Stops older browsers from parsing the remainder of the selector. 是阻止旧浏览器解析后续的选择器的.</p>

<p>在 CSS3 <a href="http://www.w3.org/TR/css3-mediaqueries/#media0">Media Queries</a> 中有如下描述:</p>

<blockquote><p>The keyword ‘only’ can also be used to hide style sheets from older user agents. User agents must process media queries starting with ‘only’ as if the ‘only’ keyword was not present.</p></blockquote>

<p>所以, 关键字 <code>only</code> 就是为了不让旧浏览器正确解析的.</p>

<h4>21)</h4>

<p>HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;p&gt;</span>I am floated<span class="nt">&lt;/p&gt;</span>
</span><span class='line'>    <span class="nt">&lt;p&gt;</span>So am I<span class="nt">&lt;/p&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">div</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">overflow</span><span class="o">:</span> <span class="k">hidden</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nt">p</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">float</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Does <code>overflow: hidden</code> create a new block formatting context ?</p>

<p><code>overflow: hidden</code> 会创建一个新的块级格式化上下文吗 ?</p>

<p><strong>答</strong>: 会. CSS2.1 <a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting">9.4.1 Block formatting contexts</a> 一节中有如下描述:</p>

<blockquote><p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with &lsquo;overflow&rsquo; other than &lsquo;visible&rsquo; (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p></blockquote>

<p>因此, 只要 <code>overflow</code> 的值不是 <code>visible</code> 时, 都会创建一个新的块级格式化上下文.</p>

<h4>22)</h4>

<p>CSS:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="k">@media</span> <span class="nt">only</span> <span class="nt">screen</span> <span class="nt">and</span> <span class="o">(</span><span class="nt">max-width</span><span class="o">:</span> <span class="nt">1024px</span><span class="o">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">margin</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Does the <code>screen</code> keyword apply to the device&rsquo;s physical screen or the browser&rsquo;s viewport ?</p>

<p>关键字 <code>screen</code> 指的是设备的物理屏幕, 还是指的浏览器的 viewport ?</p>

<p><strong>答</strong>: CSS2 <a href="http://www.w3.org/TR/CSS2/media.html#media-types">Media types</a> 一节, 有如下描述,</p>

<blockquote><p><strong>screen</strong></p>

<p>Intended primarily for color computer screens.</p></blockquote>

<p>因此, 答案应该是设备的物理屏幕, 但是原作者给的答案是浏览器的 viewport. (不知所措. o(>﹏&lt;)o</p>

<p><code>HTML</code>, 以及 <code>Javascript</code> 的后续部分, 敬请期待 ~O(∩_∩)O~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[护照, 往来港澳通行证以及大陆居民往来台湾地区通行证办理记录]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/28/passport/"/>
    <updated>2014-01-28T19:20:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/28/passport</id>
    <content type="html"><![CDATA[<p>首先, 吐槽一下, 在自己国家的土地上都不能自由通行, 还需要办理各种证件. (╯‵□′)╯︵┻━┻</p>

<p>以西安为例, 西安市出入境管理中心在科技路二号(西斜七路十字西南角), 工作时间为法定工作日 9:00-17:00. 据说中午有休息时间. 由于本人 14:50 才到, 中午休息时间未知. (如果一次性需要办多个证件, 需要填多张表格, 所以即使中午休息时间到也没有关系, 领表格自行填写, 填写完之后再办手续).</p>

<p>表格的填写一般都有样例, 不过样例可能已经与现在填写的版本不一致, 这个不用担心, 主要填写基本信息, 不知如何填写的可以留空. 办理时, 工作人员会最后确认的. (这次给我办理的是个制服美女. O(∩_∩)O 哈哈~ 跑题了.</p>

<h2>护照</h2>

<p>护照是一个国家的公民出入本国国境和到国外旅行或居留时, 由本国发给的一种证明该公民国籍和身份的合法证件. 没有护照是没法出国的. 目前对大陆免签的国家非常少啊, 非常少. (╯‵□′)╯︵┻━┻</p>

<p>护照申请表格一式一份 2 张, 需要本人填写的只有一些基本信息, 办理过程需要录入指纹, 申请表格有一栏是需要工作人员确认信息完成后, 当面签字的. 如果需要邮寄的话, 需要在最后填写邮寄地址. 如果旧护照已过期, 那么与首次申请办理护照没有区别, 旧护照可以自己留作纪念.</p>

<h2>往来港澳通行证</h2>

<p>内地居民因私往来香港或澳门特别行政区旅游, 探亲, 从事商务, 培训, 就业等非公务活动, 向户口所在地的市, 县公安出入境管理部门提出申请, 凭公安出入境管理部门签发的往来港澳通行证及有效签注才能前往.</p>

<p>如果持有大陆护照, 以及入台的各种证件, 和香港转机机票, 则不需要往来港澳通行证即可在港澳最多停留 7 日.</p>

<p>由于西安目前还不是港澳自由行的城市, 因此还不能办理个人 G 签, 只能办理团队 L 签. 如果只想去香港, 那么只能从深圳找当地旅行团协助过关. 至于有效期及签注次数个人自行选择. 本人选择的是澳门 1 次有效签注, 有效期 1 年. 香港 2 次有效签注, 有效期 1年.</p>

<p>往来港澳通行证申请表格一式一份 1 张, 除了基本信息, 需要注意的是申请的签注类型, 首选个人 G 签, 如果所在城市不支持, 那工作人员会自动帮助你更改为团队 L 签. 如果需要邮寄的话, 需要在最后填写邮寄地址.</p>

<!-- more -->


<h2>大陆居民往来台湾地区通行证</h2>

<p>大陆居民往来台湾所持有的证件. 也被称做大通证, 大陆证, 陆胞证. 由大陆颁发. 申请的同时可以申请 G 签(必须是开放台湾自由行的城市). 1次有效签注, 有效期 6 个月.</p>

<p>想去台湾, 只有大陆居民往来台湾地区通行证和大陆的有效签注是不行的. 还需要台湾方面颁发的中华民国台湾地区入出境许可证. 这个证个人无法办理, 需要找有资质的旅行社代办, 具体细节以后更新.</p>

<p>大陆居民往来台湾地区通行证申请表格一式一份 1 张, 内容与往来港澳通行证区别不大. 开放台湾自由行的城市可以选择个人 G 签. 如果需要邮寄的话, 需要在最后填写邮寄地址.</p>

<h2>办理流程</h2>

<p>准备工作: <strong>黑色签字笔一支, 身份证原件, 户口本原件, 干净整洁的面容 (深色衣服, 照片是白底).</strong></p>

<p>2014 年 1 月 28 日, 14:50 到达西安市出入境管理中心, 先到西门上二楼,</p>

<ul>
<li>取表复印: 直接去取表复印处, 交出身份证以及户口本原件, 告诉工作人员需要办理的证件(本人一次办了护照, 港澳通行证, 台湾通行证), 专业人员, 直接把你的身份证, 户口本复印到表格相应的地方. 缴纳 1.5 元钱, 领表复印就结束了.</li>
<li>照相: 照相 30 元, 基本上是立等可取. 白底照片一共 5 张, 三个证件各用 1 张, 照片有个条形码, 办理手续的时候工作人员需要扫描.</li>
<li>填表: 等照片的过程可以先填表格, 3 个表格填起来还是需要些时间的. (PS: 取表复印, 照相顺序自行安排, 去的时候正是高峰期, 人山人海, 取表复印和照相都排队了一段时间. 表格填写好之后, 将剪裁完的照片成用浆糊贴到指定位置, 就可以排号准备办理了.)</li>
<li>办理, 拿申请回执单: 将三份贴好照片的申请表, 以及身份证原件, 户口本原件交给工作人员, 工作人员会核对信息开始办理, 护照的办理相对麻烦, 需要录入两个大拇指的指纹, 还需要用摄像头拍一下, 如果填写的信息都无误的话, 签字之后就可以拿着申请回执单去交费了. 回执单上写的取证日期是 2 月 14 日.</li>
<li>交费: 交费地点在东门一楼, 带着申请回执单去办理, 护照 220 元, 港澳通行证 160 元(根据签注次数, 以及有效期价格不同), 台湾通行证 70 元. 总计 450 元. <strong>不能现金</strong>, 刷了信用卡. 由于无法自取, 三个证件都办理了邮寄, 使用现金, 每个 22 元. 总计 66 元.</li>
<li>交还快递收据: 缴费, 办理邮寄时, 三个回执单都被收回, 拿到快递收据后, 再回到办理的工作人员那, 交出快递收据, 任务完成.</li>
</ul>


<p>任务达成时间 2014 年 1 月 28 日, 16:30</p>

<p>现在离出发去台湾还差一个台湾方面颁发的入台证了. 稍后更新. O(∩_∩)O~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]GotW #95 Solution: Thread Safety and Synchronization]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/19/gotw-95/"/>
    <updated>2014-01-19T23:54:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/19/gotw-95</id>
    <content type="html"><![CDATA[<p><em>原文地址: <a href="http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/">GotW #95 Solution: Thread Safety and Synchronization</a></em></p>

<p><em>这篇 GotW 是来回答一些关于线程安全与同步的问题的. 我们的讨论几乎适用于所有主流语言</em></p>

<h1>问题</h1>

<h2>JG 问题</h2>

<p><strong>1) 竞态条件(race condition)指的是什么? 它有很严重吗?</strong></p>

<p><strong>2) 什么是正确同步的程序? 你是如何实现的? 请具体说明.</strong></p>

<h2>Guru 问题</h2>

<p><strong>3) 考虑下面的代码, <code>some_obj</code> 是一个多个线程可见的共享变量.</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>如果线程 1 与线程 2 能够并行, 那么当 <code>some_ojb</code> 是如下类型时, 代码是否能够正确同步?</strong></p>

<ul>
<li>a) <code>int</code></li>
<li>b) <code>string</code></li>
<li>c) <code>vector&lt;map&lt;int,string&gt;&gt;</code></li>
<li>d) <code>shared_ptr&lt;widget&gt;</code></li>
<li>e) <code>mutex</code></li>
<li>f) <code>condition_variable</code></li>
<li>g) <code>atomic&lt;unsigned&gt;</code></li>
</ul>


<p><strong>提示: 虽然有 7 个类型, 但实际上答案只有两种.</strong></p>

<p><strong>4) 外部同步, 意味着使用共享对象的代码需要自己来保证对象的同步. 回答下面有关外部同步的问题:</strong></p>

<ul>
<li>a) 一般的外部同步的职责是什么?</li>
<li>b) 什么是&#8221;基本的线程安全保障&#8221;?</li>
<li>c) 哪些内部同步是在共享变量的实现中需要做的?</li>
</ul>


<p><strong>5) 完全的内部同步类型(线程安全类型), 意味着所有的同步在对象内部完成, 外部不需要再进行同步. 哪些类型是内部同步的, 为什么?</strong></p>

<!-- more -->


<h1>解决方案</h1>

<p><strong>1) 竞态条件(race condition)指的是什么? 它有很严重吗?</strong></p>

<p>当两个线程同时访问一个共享变量时, 并且至少有一个是 non-const 操作(写操作)时会发生竞态条件(race condition). 并发的 const 操作是允许的, 不会发生竞态条件.</p>

<p>如果发生了竞态条件, 那么你的程序会产生未定义行为 (undefined behavior).</p>

<p><em>准则: 针对共享变量的只读 (const) 操作, 在没有外部同步的情况下也是安全的.</em></p>

<p><strong>2) 什么是正确同步的程序? 你是如何实现的? 请具体说明.</strong></p>

<p>正确同步的程序指的是没有竞态条件的程序.</p>

<p>共享变量通常的保护方式有:</p>

<ul>
<li>通常使用 <code>mutex</code> 或其他类似的东西;</li>
<li>极少情况下使用 <code>atomic</code>;</li>
<li>极少情况下确认是内部同步的类型, 下面会讲到.</li>
</ul>


<p><strong>3) 考虑下面的代码, <code>some_obj</code> 是一个多个线程可见的共享变量.</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>如果线程 1 与线程 2 能够并行, 那么当 <code>some_ojb</code> 是如下类型时, 代码是否能够正确同步?</strong></p>

<ul>
<li>a) <code>int</code></li>
<li>b) <code>string</code></li>
<li>c) <code>vector&lt;map&lt;int,string&gt;&gt;</code></li>
<li>d) <code>shared_ptr&lt;widget&gt;</code></li>
</ul>


<p>不能. 代码中有一个线程对 some_obj 做读操作(const 操作), 而另一个线程对 <code>some_obj</code> 进行写操作. 如果这两个线程同时执行, 那么就有可能发生竞态条件.</p>

<p>要正确同步, 需要对 <code>some_obj</code> 的访问进行同步, 比如使用 <code>mutex</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span> <span class="n">hold</span><span class="p">(</span><span class="n">mut_some_obj</span><span class="p">);</span>     <span class="c1">// acquire lock</span>
</span><span class='line'>    <span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span> <span class="n">hold</span><span class="p">(</span><span class="n">mut_some_obj</span><span class="p">);</span>     <span class="c1">// acquire lock</span>
</span><span class='line'>    <span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>几乎所有类型, 包括 <code>shared_ptr</code> 以及 <code>vector</code> 以及其他类型, 他们的线程安全级别与 <code>int</code> 是一样的. 它们没有特别的为并行设计. 无论 <code>some_obj</code> 是一个 <code>int</code>, <code>string</code>, 容器, 还是智能指针类型, 并发读 (const 操作) 不需要同步也是安全的, 但是共享变量是可写的, 因此使用该变量的代码需要同步访问.</p>

<p>但是, 上面说的是 &ldquo;几乎所有类型&rdquo;, 指的是不包含内部同步的类, 那些类型设计的时候就是为了并发而来的.</p>

<p><strong>3) 考虑下面的代码, <code>some_obj</code> 是一个多个线程可见的共享变量.</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>如果线程 1 与线程 2 能够并行, 那么当 <code>some_ojb</code> 是如下类型时, 代码是否能够正确同步?</strong></p>

<ul>
<li>e) <code>mutex</code></li>
<li>f) <code>condition_variable</code></li>
<li>g) <code>atomic&lt;unsigned&gt;</code></li>
</ul>


<p>对上面的三个类型来说, 代码是 OK 的, 因为他们本身就是内部同步的, 所有不需要在外部再做同步.</p>

<p>实际上, 这些类型必须保证不需要外部同步时也是安全的, 因为这些同步原语, 是你用来保证其他变量同步的工具.</p>

<p><em>准则: 只有当一个类型的目的是线程间通讯 (如: 消息队列) 或同步(如: mutex)时, 这个类型才需要是内部同步的</em></p>

<p><strong>4) 外部同步, 意味着使用共享对象的代码需要自己来保证对象的同步. 回答下面有关外部同步的问题:</strong></p>

<p>a) 一般的外部同步的职责是什么?</p>

<p>同步的职责很简单: 当有可写的共享变量时, 需要同步访问它. 典型的做法是使用 <code>mutex</code> 或类似的东西, 或者如果可行的话将该类型变为 <code>atomic</code>.</p>

<p><em>准则: 如果代码中访问了可写的共享变量, 那么需要对他进行访问同步.</em></p>

<p>b) 什么是&#8221;基本的线程安全保障&#8221;?</p>

<p>如果要保证上面描述的东西是正确的, 那么对象本身必须有如下两个保证.</p>

<p>首先, 并行访问两个实例对象必须是安全的. 比如, 类 <code>X</code> 有两个对象 <code>x1</code> 和 <code>x2</code>, 每个对象都仅在自己的线程中使用. 考虑下面的情形:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case A: Using distinct objects</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">x1</span><span class="p">.</span><span class="n">something</span><span class="p">();</span>                   <span class="c1">// do something with x1</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">x2</span> <span class="o">=</span> <span class="n">something_else</span><span class="p">;</span>              <span class="c1">// do something else with x2</span>
</span></code></pre></td></tr></table></div></figure>


<p>这必须始终是正确同步的. 记住, 这里的 <code>x1</code> 和 <code>x2</code> 是两个对象, 而不是别名或类似的东西.</p>

<p>另外, 并发的 const 操作, 也就是只读操作必须是安全的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case B: const access to the same object</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">x</span><span class="p">.</span><span class="n">something_const</span><span class="p">();</span>              <span class="c1">// read from x (const operation)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">x</span><span class="p">.</span><span class="n">something_else_const</span><span class="p">();</span>         <span class="c1">// read from x (const operation)</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码也是正确同步的. 没有外部同步时他们也能很好的工作. 这不是一个竞态条件. 因为这两个线程都仅仅是对共享变量进行读操作.</p>

<p>这把我们带到了同时需要外部同步和内部同步的情形.</p>

<p>c) 哪些内部同步是在共享变量的实现中需要做的?</p>

<p>在某些类, 对象中表面上看起来他们是不同的, 但实际上仍然共享着某些状态, 而不需要调用者做任何事情来指定幕后的连接状态. 注意这不是前面准则的例外, 这是和前面一样的准则.</p>

<p><em>准则: 如果代码中访问了可写的共享变量, 那么需要对他进行访问同步. 这始终是正确的. 如果可写的共享变量隐藏在类实现的内部, 那么仅仅对那部分共享变量的访问做同步即可.</em></p>

<p>引用计数, 就是上面所描述的内部共享状态, 下面的两个例子是 <code>std::shared_ptr</code> 以及 copy-on-write. 下面来看 <code>shared_ptr</code> 的例子.</p>

<p>像 <code>shared_ptr</code> 一样的带有引用计数的智能指针会在对象内部保存引用计数信息. 下面来看两个不同的 <code>shared_ptr</code> 对象 <code>sp1</code> 与 <code>sp2</code>, 每一个都仅在自己的线程中使用. 考虑下面的情形:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case A: Using distinct objects</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sp1</span><span class="p">;</span>                      <span class="c1">// read from sp1 (writes the count!) </span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">sp2</span> <span class="o">=</span> <span class="n">something_else</span><span class="p">;</span>              <span class="c1">// write to sp2 (writes the count!)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个代码会正确同步, 而且完全不需要外部同步. 没错&hellip;</p>

<p>但是, 如果 <code>sp1</code> 与 <code>sp2</code> 指向同一个对象, 共享引用计数信息时呢? 这时, 引用计数信息是一个可写的共享变量, 它必须同步访问来避免竞态条件, 但是这基本是无法在外部调用代码中完成的, 因为我们甚至都感知不到它存在共享的内容. 我们看不到引用计数的大小, 也不知道他的变量名, 也不知道还有谁正在共享.</p>

<p>类似的, 我们看下面代码, 两个线程只从同一个变量 <code>sp</code> 中读取内容:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case B: const access to the same object</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">sp3</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>                     <span class="c1">// read from sp (writes the count!)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">sp4</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>                     <span class="c1">// read from sp (writes the count!)</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码不需要外部同步也可以正确同步. 这不是竞态条件, 因为这两个线程对 <code>sp</code> 都进行的是只读的 const 操作. 但在内部共享的引用计数是可写的, 它们需要正确同步来避免竞态条件, 像上面所说, 我们不可能在调用代码中保证它正确同步, 因为我们甚至不知道有共享的内容.</p>

<p>因此要处理这种情形, 以 <code>shared_ptr</code> 的引用计数为例, 典型的做法是将引用计数变量更改为 mutable atomic 类型.</p>

<p>为了完整, 我们再看需要外部同步的情形. 像上面说说的, 当多线程共享 <code>shared_ptr</code> 可写对象时, 仍然是需要外部同步的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Case C: External synchronization still required as usual</span>
</span><span class='line'><span class="c1">//         for non-const access to same visible shared object</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span> <span class="n">hold</span><span class="p">(</span><span class="n">mut_sp</span><span class="p">);</span>           <span class="c1">// acquire lock</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">sp3</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>                     <span class="c1">// read from sp</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">lock_guard</span> <span class="n">hold</span><span class="p">(</span><span class="n">mut_sp</span><span class="p">);</span>           <span class="c1">// acquire lock</span>
</span><span class='line'>    <span class="n">sp</span> <span class="o">=</span> <span class="n">something_else</span><span class="p">;</span>               <span class="c1">// modify sp</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以, <code>shared_ptr</code> 不是内部同步的类型, 如果调用者需要在多个线程中共享该类型的可写变量, 那么必须像问题 3(d) 中那样, 在外部做同步访问.</p>

<p>那么内部同步的目的是什么? 它仅仅做那些外部不可见, 外部无法做同步, 而内部需要共享的内容的同步. 这样一来外部就能使用通常的做法来保证正确同步了.</p>

<p>对于 copy-on-write 来说, 情况和引用计数也类似.</p>

<p><em>准则: 如果你设计一个类, 如果两个对象实例之间有外部看不到的 <code>mutable</code> 共享状态, 那么保证这个共享状态能够正确同步是你的职责, 因为这个共享状态对外部来说是未知的.</em></p>

<p>为什么内部共享状态是 <code>mutable</code> 的, 请看 GotW #6a 和 #6b.</p>

<p><strong>5) 完全的内部同步类型(线程安全类型), 意味着所有的同步在对象内部完成, 外部不需要再进行同步. 哪些类型是内部同步的, 为什么?</strong></p>

<p>只有一种类型需要完全的内部同步, 不需要外部的同步就能保证并发的安全, 那就是: 线程间同步和通讯的原语. 这包括标准库中的 <code>mutex</code>, <code>atomic</code>, 还有你可能自己会写的线程间通信的消息队列, 生产者/消费者的活动对象, 或者一个线程安全的计数器.</p>

<p>如果你想知道是否还有其他的类型也应该做成内部同步的话, 请考虑: 只有那些你能明确知道,这个类型一旦创建,  那它就是要共享给多个线程来做可写访问的时候, 你猜需要让这个类型是内部同步的&hellip; 这个语义同时也意味着这个类型就是为了线程间通讯以及同步而设计的.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[why make_shared ?]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/12/why-make-shared/"/>
    <updated>2014-01-12T21:01:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/12/why-make-shared</id>
    <content type="html"><![CDATA[<p>C++11 中引入了智能指针, 同时还有一个模板函数 <code>std::make_shared</code> 可以返回一个指定类型的 <code>std::shared_ptr</code>, 那与 <code>std::shared_ptr</code> 的构造函数相比它能给我们带来什么好处呢 ?</p>

<h2>优点</h2>

<h3>效率更高</h3>

<p><code>shared_ptr</code> 需要维护引用计数的信息,</p>

<ul>
<li>强引用, 用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放).</li>
<li>弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话).</li>
</ul>


<p>如果你通过使用原始的 new 表达式分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">widget</span><span class="p">();</span>
</span><span class='line'><span class="n">shared_ptr</span> <span class="n">sp1</span><span class="p">{</span> <span class="n">p</span> <span class="p">},</span> <span class="n">sp2</span><span class="p">{</span> <span class="n">sp1</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://y6bhba.bay.livefilestore.com/y1pDu8kORu85CKSKHFVBvapxrccVoMAjc8W0d6mScWwunuhqV8n25QZKgZhM6MPtFGV1c6dPgjil7g/sharedptr1.png" alt="" /></p>

<p>如果选择使用 <code>make_shared</code> 的话, 情况就会变成下面这样:</p>

<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">sp1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="p">(),</span> <span class="n">sp2</span><span class="p">{</span> <span class="n">sp1</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://y6yska.bay.livefilestore.com/y1p-Y0XAkcMZMrSdxkTa85nShcDkVKvqhMTFVGSDc0jURLybPXTGHPdWv9CZGgcGmvZwQQvd6Y1Qdg/sharedptr2.png" alt="" /></p>

<p>内存分配的动作, 可以一次性完成. 这减少了内存分配的次数, 而内存分配是代价很高的操作.</p>

<p>关于两种方式的性能测试可以看这里 <a href="http://tech-foo.blogspot.hk/2012/04/experimenting-with-c-stdmakeshared.html">Experimenting with C++ std::make_shared</a></p>

<h3>异常安全</h3>

<p>看看下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">F</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">F</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Lhs</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">)),</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Rhs</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++ 是不保证参数求值顺序, 以及内部表达式的求值顺序的, 所以可能的执行顺序如下:</p>

<ol>
<li>new Lhs(&ldquo;foo&rdquo;))</li>
<li>new Rhs(&ldquo;bar&rdquo;))</li>
<li>std::shared_ptr<Lhs></li>
<li>std::shared_ptr<Rhs></li>
</ol>


<p>好了, 现在我们假设在第 2 步的时候, 抛出了一个异常 (比如 out of memory, 总之, Rhs 的构造函数异常了), 那么第一步申请的 Lhs 对象内存泄露了. 这个问题的核心在于, shared_ptr 没有立即获得裸指针.</p>

<p>我们可以用如下方式来修复这个问题.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Lhs</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">));</span>
</span><span class='line'><span class="k">auto</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Rhs</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">));</span>
</span><span class='line'><span class="n">F</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然, 推荐的做法是使用 <code>std::make_shared</code> 来代替:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">F</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Lhs</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>缺点</h2>

<h3>构造函数是保护或私有时,无法使用 make_shared</h3>

<p><code>make_shared</code> 虽好, 但也存在一些问题, 比如, 当我想要创建的对象没有公有的构造函数时, <code>make_shared</code> 就无法使用了, 当然我们可以使用一些小技巧来解决这个问题, 比如这里 <a href="http://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const?rq=1">How do I call ::std::make_shared on a class with only protected or private constructors?</a></p>

<h3>对象的内存可能无法及时回收</h3>

<p><code>make_shared</code> 只分配一次内存, 这看起来很好. 减少了内存分配的开销. 问题来了, <code>weak_ptr</code> 会保持控制块(强引用, 以及弱引用的信息)的生命周期, 而因此连带着保持了对象分配的内存, 只有最后一个 <code>weak_ptr</code> 离开作用域时, 内存才会被释放. 原本强引用减为 0 时就可以释放的内存, 现在变为了强引用, 若引用都减为 0 时才能释放, 意外的延迟了内存释放的时间. 这对于内存要求高的场景来说, 是一个需要注意的问题. 关于这个问题可以看这里 <a href="http://lanzkron.wordpress.com/2012/04/22/make_shared-almost-a-silver-bullet/">make_shared, almost a silver bullet</a></p>

<h2>参考</h2>

<ul>
<li><a href="http://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/">GotW #89 Solution: Smart Pointers</a></li>
<li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">cppreference.com &ndash; std::make_shared</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当 Windows API 遇上 RAII]]></title>
    <link href="http://bitdewy.github.com/blog/2014/01/06/windows-api-raii/"/>
    <updated>2014-01-06T00:18:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2014/01/06/windows-api-raii</id>
    <content type="html"><![CDATA[<h2>什么是 RAII (Resource Acquisition Is Initialization) ?</h2>

<p>RAII (Resource Acquisition Is Initialization), 也称为&#8221;资源获取就是初始化&#8221;, 是 C++ 语言的一种管理资源, 避免泄漏的惯用法. C++ 标准保证任何情况下, 已构造的对象最终会销毁, 即它的析构函数最终会被调用. 简单的说, RAII 的做法是使用一个对象, 在其构造时获取资源, 在对象生命期控制对资源的访问使之始终保持有效, 最后在对象析构的时候释放资源.</p>

<p>RAII 是保证代码异常安全的重要基础设施. RAII 的使用场景有很多, 如: C++11 中的智能指针, scope lock, scope exit 等等. (早在2000年，<a href="http://erdani.com/">Andrei Alexandrescu</a> 就在DDJ杂志上发表了一篇文章，提出了这个叫做 <a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758">ScopeGuard</a> 的设施)</p>

<h2>当 Windows API 遇上 RAII</h2>

<p>Windows API 大多是 C 语言风格的函数和句柄, 或者是 COM 风格的接口, 这些用起来都不太方便, 需要进行一定的封装. 至于为什么要封装就不用多说了, 如果你想要异常安全, 想要不必在每个分支中都写清理代码的话, 你一定知道利用 RAII 封装的意义.</p>

<p>ATL 中有对 COM 接口的封装, 智能指针 <code>CComPtr</code>, <code>CComQIPtr</code> 解决了一遍遍的手工 <code>Release</code> 以及 <code>QueryInterface</code>. 但对于普通的 C 语言风格的函数和句柄呢? 难道还要一遍遍的 <code>CloseHandle</code> , <code>ReleaseDC</code>, <code>GlobalUnlock</code> 麽? 弱爆了.</p>

<p>借助 <code>ScopeGuard</code> 和 lambda 表达式(⊙_⊙)？ 可以是可以, 但是并不是所有的资源获取都会成功, 那么每次都要产生一个具名的 <code>ScopeGuard</code>, 在申请失败的时候调用 <code>Dismiss</code>, 取消清理的动作嘛? 像这样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Acquire</span> <span class="n">Resource1</span>
</span><span class='line'><span class="n">ScopeGuard</span> <span class="n">release1</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource1 */</span> <span class="p">})</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">release1</span><span class="p">.</span><span class="n">Dismiss</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Acquire</span> <span class="n">Resource2</span>
</span><span class='line'><span class="n">ScopeGuard</span> <span class="n">release2</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource2 */</span> <span class="p">})</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">release2</span><span class="p">.</span><span class="n">Dismiss</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>这样如果连续申请多个资源 <code>ScopeGuard</code> 对象命名都会成为问题. 又或者是先判断资源是否申请成功, 然后再使用匿名的 <code>ScopeGuard</code> 来保证正确释放资源? 像这样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Acquire</span> <span class="n">Resource1</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">ON_SCOPE_EXIT</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource1 */</span> <span class="p">})</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">Acquire</span> <span class="n">Resource2</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">ON_SCOPE_EXIT</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource2 */</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样好是好, 可是割裂了申请与释放的代码, 而且每申请一个资源就要至少写上 3 行或以上结构类似代码(可以考虑宏了) ?</p>

<p>当然, 我们是有追求的, 我们还需要更厉害的设施. 也许 <code>unique_ptr</code> 可以给我提供一些思路. 我们需要一个基本的类型, 也许是 <code>HANDLE</code>, 也许是 <code>HINTERNET</code> 等等, 同时我们还需要一个清理函数. 再加上一个资源是否可用的接口即可. 为了避免过多的模板参数, 我们把清理函数以及不可用资源封装到 <code>Traits</code> 类中, 下面是一个例子, 可以很好的完成我们的需求. 另外仿照 <code>unique_ptr</code> 加了一些 move 语义, 转移构造等东西. 下面的代码只实现了 <code>HANDLE</code> 的特化版本, 相信 <code>HINTERNET</code> 的版本, 大家写起来应该也是毫无压力了. 只需要写 <code>Traits</code> 类即可.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Traits</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">unique_handle</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">bool_struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">member</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">bool_type</span> <span class="o">=</span> <span class="kt">int</span> <span class="n">bool_struct</span><span class="o">::*</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">explicit</span> <span class="n">unique_handle</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Traits</span><span class="o">::</span><span class="n">invalid</span><span class="p">())</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">unique_handle</span><span class="p">(</span><span class="n">unique_handle</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">release</span><span class="p">())</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">unique_handle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_handle</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">reset</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">unique_handle</span><span class="p">()</span> <span class="p">{</span> <span class="n">close</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">T</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">reset</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Traits</span><span class="o">::</span><span class="n">invalid</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">value_</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">close</span><span class="p">();</span>
</span><span class='line'>      <span class="n">value_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">T</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value_</span><span class="p">;</span>
</span><span class='line'>    <span class="n">value_</span> <span class="o">=</span> <span class="n">Traits</span><span class="o">::</span><span class="n">invalid</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">operator</span> <span class="n">bool_type</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Traits</span><span class="o">::</span><span class="n">invalid</span><span class="p">()</span> <span class="o">!=</span> <span class="n">value_</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">bool_struct</span><span class="o">::</span><span class="n">member</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">unique_handle</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_handle</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">unique_handle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_handle</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_handle</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_handle</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">close</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">Traits</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">value_</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">handle_traits</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">HANDLE</span> <span class="n">invalid</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">void</span> <span class="n">close</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="n">unique_handle</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">handle_traits</span><span class="o">&gt;</span> <span class="n">handle</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用起来应该是这样的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">unique_handle</span><span class="o">&lt;</span><span class="n">SOCKET</span><span class="p">,</span> <span class="n">socket_traits</span><span class="o">&gt;</span> <span class="n">socket</span><span class="p">;</span>
</span><span class='line'><span class="n">unique_handle</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">handle_traits</span><span class="o">&gt;</span> <span class="n">event</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Are both valid?</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Is event invalid?</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">socket</span><span class="p">;</span> <span class="c1">// Compiler error!</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">==</span> <span class="n">event</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Compiler error!</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>int i = socket;</code> 这一句很有意思, 我们为了让它能够编译失败, 费了不少功夫. 内部类 <code>bool_struct</code> 就是完全为它而准备. 这也是为什么我们不直接提供 <code>operator bool</code> 的原因. 私有化 <code>operator==</code> 和 <code>operator!=</code> 是为了禁止两个资源进行比较. 而使用内部类成员指针就是为了提供 <code>operator bool</code> 类似功能的同时, 避免它能够提升为 <code>int</code> 等类型. 当然如果我们直接提供一个 <code>is_valid</code> 成员函数, 而不提供隐身转换, 那么就不会有这么多的问题了.</p>

<p>看起来还差错误处理的内容, 不过都到这个份上了, 错误处理就不是问题了吧. 我们可以写各种 <code>check</code> 函数的重载版本, 当 <code>check</code> 失败时抛出异常. 这样就大功告成了.</p>

<h2>参考</h2>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a></li>
<li><a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/">C++11（及现代C++风格）和快速迭代式开发</a></li>
<li><a href="http://msdn.microsoft.com/en-us/magazine/hh288076.aspx">C++ and the Windows API</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步编程和延续传递风格]]></title>
    <link href="http://bitdewy.github.com/blog/2013/12/23/cps-async/"/>
    <updated>2013-12-23T00:51:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/12/23/cps-async</id>
    <content type="html"><![CDATA[<h2>什么是延续传递风格(Continuation-passing Style)?</h2>

<p>Continuation-passing style(CPS) 是指将控制流 (Control flow) 显式的当做参数传递的编程风格. 函数的返回不在通过 return 语句, 而是将返回值当做参数, 调用控制流. 延续传递风格的函数都会有一个额外的参数k, 显式的表示了continuation (可以理解成控制流的流向, what comes next). 当延续传递风格函数需要返回的时候, 调用k, 并将返回值作为k的参数.</p>

<p>延续传递风格的函数都有一个额外的参数 k, 表示控制流. 函数需要返回, 必须显式的调用 k.
在函数的末尾调用了另外一个函数, 这种调用称为尾调用, tail call. 相应的在尾部递归调用, 称之为尾递归, tail recursion. 延续传递风格的所有函数都是尾调用.</p>

<p>看一个实际的例子, 假设我们有一个函数 <code>show</code> 可以用来打印一些东西, 通常的做法是我们调用一个函数然后存储或者修改它的返回值, 然后把它传给下一个函数,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">show</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">make_one</span> <span class="o">=</span> <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// prints 1</span>
</span><span class='line'><span class="n">show</span><span class="p">(</span><span class="n">make_one</span><span class="p">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>在延续传递风格中, 函数需要增加一个参数用来处理函数返回的结果, 它是这个函数处理完之后需要的后续处理,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">one_cont</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">k</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Also prints 1</span>
</span><span class='line'><span class="n">one_cont</span><span class="p">(</span><span class="n">show</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用延续传递风格最初主要用于编译高级语言时一种中间代码表示, 有了这种中间代码, 编译器的复杂度大大降低. 各种的控制流都能变为 CPS. 有很多办法可以将非 CPS 代码自动转换为 CPS 的代码. 有兴趣可以去研究下 <a href="http://book.douban.com/subject/1762126/">Compiling with Continuations</a> 这本书.</p>

<!-- more -->


<h2>函数式编程与延续传递风格</h2>

<p>函数式编程的控制流就是靠 CPS 实现的.</p>

<p>数学上的 “函数” 简而言之是 “集到集的映射”, 而指令式编程语言的 “函数” 与之有大不同. 数学关心返回集是什么, 而指令式编程语言根本不在乎有没有值返回, 它关心的是过程控制权的返回.其实, 指令式编程语言中 “函数” 本质是 “子过程”.</p>

<p>指令式编程语言本质上是 “子过程” 的 “函数” 是有状态的, 这就决定了它永远无法消除副作用 (side-effect), 这是多线程应用的巨大隐患. 而 CPS (函数式编程)在异步编程里, 分布式编程里大显身手.指令式编程语言对程序员的洗脑使计算机专业的学生的思维背离了人类应有的数学性和抽象性. 太多的人专注于前置自增与后置自增的区别, 专注于常指针与指针常量的区别, 专注于是用 if-else 还是用 switch-case 的问题, 等等. 这些本不应该是让程序员费心的问题却牵扯了程序员太多的心力. 虽然 C++ 引入了 lambda, 但依然把上述的问题留了下来.</p>

<h2>异步编程与延续传递风格</h2>

<p>多线程异步调用是 CPS 一展身手的地方. 闭包封闭处理过程, 却对线程开放. 闭包安排好线程间数据处理的顺序, 于是线程间便不用轮询等待, 就可以分步按序完成一系列操作. 目前比较火的 node.js 最大的优点就是 non-blocking programming. 在 node.js中, 所有原本可能阻塞的操作全部都接受一个 callback, 当请求完成的时候调用 callback. 这种通过 callback 进行异步编程的风格是不完全的 CPS, callback 可以看成 continuation.</p>

<p>当然 javascript 这种 callback 机制有一个很大的问题就是容易陷入 callback hell, 现在已经有很多异步的库可以帮助程序员远离 callback hell, 据说 coffeescript 也在这方面提供了支持.</p>

<p>在 C++11 引入 lambda 之后我们也可以这么干, 但我们有更好用的, 那就是 <code>std::future</code> 以及 <code>std::promise</code> 了 (不过 <code>future.then</code> 可能要等到 C++17 才能成为标准), 之所以说更好用是因为 promise 以一种全新的方式对问题建模, 它的作用不仅是给基于 callback 的异步实现找一个语法更清晰的写法. 它要比语法层面的变化更深入, 实际上是在语义层上改变了解决问题的方式. 有兴趣可以看看这篇 <a href="http://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/">Promises are the monad of asynchronous programming</a>. 关于什么是 monad 可以看看这篇 <a href="http://zhuoqiang.me/what-is-monad.html">Monad 最简介绍</a>, 总之基于 callback 的函数接受一些输入和一个 callback, 然后用它的输出调用这个 callback 函数, 而基于 promise 的函数接受输入, 返回输出的 promise 值, 基于 callback 的函数返回的那些 null 值就是基于 callback 编程之所以艰难的源头, 基于 callback 的函数什么都不返回, 所以难以把它们组装到一起. 没有返回值的函数, 执行它仅仅是因为它的副作用&mdash;没有返回值或副作用的函数就是个黑洞. 所以用 callback 编程天生就是指令式的, 是编写以副作用为主的过程的执行顺序, 而不是像函数应用那样把输入映射到输出. 是手工编排控制流, 而不是通过定义值之间的关系来解决问题. 因此使编写正确的并发程序变得艰难.</p>

<p>而基于 promise 的函数与之相反, 你总能把函数的结果当作一个与时间无关的值. 在调用基于 callback 的函数时, 在你调用这个函数和它的 callback 被调用之间要经过一段时间, 而在这段时间里, 程序中的任何地方都找不到表示结果的值. 所以尽管 <code>then()</code> 这个方法的名字让人觉得它跟某种顺序化的操作有关, 并且那确实是它所承担的职责的副产品, 但你真的可以把它当作 unwrap 来看待. promise 是一个存放未知值的容器, 而 then 的任务就是把这个值从 promise 中提取出来, 把它交给另一个函数, 从 monad 的角度来看就是 bind 函数. 总之它才是更函数式的解决方案.</p>

<p>但是, 当到处充斥着 <code>.then()</code> 的时候我们的脑细胞肯定会死的非常快, 之前在这篇 <a href="http://bitdewy.github.io/blog/2013/08/20/async-and-await/">异步编程 async &amp; await</a> 中提到过, Sutter 在 <a href="http://channel9.msdn.com/Events/Build/2013/2-306">The future of C++</a>中提到了类似的问题, 我们可能会写出这样的代码, 貌似也进入了 callback hell 类似的情景,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'>   <span class="p">.</span><span class="n">then</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">fi</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span>
</span><span class='line'>         <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">task</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span>
</span><span class='line'>      <span class="p">[</span><span class="o">=</span><span class="p">]{</span>
</span><span class='line'>         <span class="n">fi</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
</span><span class='line'>         <span class="p">.</span><span class="n">then</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span> <span class="n">chunk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>               <span class="o">*</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
</span><span class='line'>               <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)();</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
</span><span class='line'>         <span class="p">});</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)();</span>
</span><span class='line'>   <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>好在我们有解决方案, 像写同步代码一样来写异步代码,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span> <span class="p">)</span> <span class="n">__async</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">__await</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">,</span> <span class="n">chunk</span><span class="p">;</span>
</span><span class='line'>   <span class="k">while</span><span class="p">((</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">__await</span> <span class="n">fi</span><span class="p">.</span><span class="n">read</span><span class="p">()).</span><span class="n">size</span><span class="p">())</span>
</span><span class='line'>      <span class="n">ret</span> <span class="o">+=</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a> 提案相信也会成为 C++17 的标准. 而本质上这只是把 CPS 变成了编译器要做的事情而已.</p>

<h2>参考</h2>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Continuation-passing_style">Continuation-passing style</a></li>
<li><a href="http://channel9.msdn.com/Events/Build/2013/2-306">The future of C++</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 std::tuple 和它的应用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/12/08/cpp11-tuple/"/>
    <updated>2013-12-08T17:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/12/08/cpp11-tuple</id>
    <content type="html"><![CDATA[<p>模板类 <code>std::tuple</code> 是一个固定大小, 存储元素类型不同的集合. 它是 <code>std::pair</code> 的泛化版本.</p>

<p>一个 tuple 可以显示的声明它每个元素的类型, 也可以用 <code>std::make_tuple</code> 模板函数来实现自动类型推导. 可以用 <code>std::get</code> 指定索引来访问 tuple 中的元素. 如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">(</span><span class="s">&quot;bitdewy&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;bitdewy&quot;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">);</span>   <span class="c1">// t will be of type tuple&lt;string, int, double&gt;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'><span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当编译期我们需要一个存放不同类型数据的集合, 但又不想定义一个具名的类时 tuple 是非常有用的. 例如 <code>std::function</code> 和 <code>std::bind</code> 就使用 tuple 来存放参数(我们都知道 <code>std::bind</code> 从第二个参数开始, 就是函数的参数了, 参数个数是不定的, 类型也是不定的, 这太适合用 <code>tuple</code> 来定义以及存储函数参数列表了). 尤其是 C++11 开始支持变长模板参数了, 这样一来 tuple 就变得更方便了.</p>

<h2>std::tie</h2>

<p>很多时候我们都希望函数能够返回两个或者更多个值, <code>std::tie</code> 可以帮助我们解决这个问题. <code>std::tie</code> 会构造一个每个元素都是左值引用的 <code>std::tuple</code>. 所以当一个函数返回一个 <code>std::tuple</code> 时, 我们可以使用 <code>std::tie</code> 构造一个 <code>std::tuple</code> 来接收这些返回值. 同时, 如果我们的类的每个元素都支持比较的话, 我们还可以直接使用它来构造一个 <code>std::tuple</code> 来使用 <code>std::tuple</code> 的比较函数. 如下:</p>

<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="cp">#include &lt;set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;tuple&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">n</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">s</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">d</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">set_of_s</span><span class="p">;</span> <span class="c1">// S is LessThanComparable</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">S</span> <span class="n">value</span><span class="p">{</span> <span class="mi">42</span><span class="p">,</span> <span class="s">&quot;Test&quot;</span><span class="p">,</span> <span class="mf">3.14</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">inserted</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// unpacks the return value of insert into iter and inserted</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">inserted</span><span class="p">)</span> <span class="o">=</span> <span class="n">set_of_s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">inserted</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Value was inserted successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>tuple_visitor</h2>

<p>visitor 模式是 GoF 书中描述的 23 种设计模式中最难懂的一个. 这个模式甚至让 <a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">Scott Meyers</a> 都困惑了一阵, 显然这个模式的名字没有取好, 而且例子中继承过来继承过去的绕了很多道弯很容易就让你搞不清楚它到底是在做什么的了.</p>

<p>回顾一下我们熟悉的虚函数, 本质上虚函数的作用是<strong>在不改变行为的基础上可以任意扩展类型</strong>, 也就是说我们可以在不更改原有代码的情况下, 将新的类型插入到我们原有的系统中而不需要更改原有系统的代码.</p>

<p>而 visitor 模式只是从另一个角度进行了解耦, 本质上 visitor 模式的作用是<strong>在不改变类型的基础上可以任意扩展对类型的操作</strong>.</p>

<p>不明白上面两句话的可以看看这两篇<a href="http://www.cnblogs.com/geniusvczh/archive/2013/05/25/3098496.html">如何设计一门语言（五）——面向对象和消息发送</a>, <a href="http://www.cnblogs.com/geniusvczh/p/3416833.html">如何设计一门语言（十二）——设计可扩展的类型</a>文章.</p>

<p>之前介绍过 <a href="http://bitdewy.github.io/blog/2013/07/15/static-visitor/">boost.variant.static_visitor</a>, 没有了一个一个的继承,写起来比原始的 visitor 模式简单很多, 如果写过 parser 生成过 AST 然后对它操作的话, 那么你可能对 visitor 有更深刻的理解, 本质上它就是函数式语言中含有<strong>模式匹配</strong>的递归函数.</p>

<p>模式匹配不是什么新玩意儿, 事实上, 它甚至和函数式编程的关系都不大. 把产生模式匹配归因于函数式编程的唯一的原因是函数式语言早就提供了模式匹配, 然而现在的命令式语言还大多做不到. C++ 中的模板特化实际上就是一种模式匹配(类型模式). 比如 <code>std::enable_if</code> 里面经常要用到的 type traits. 下面是一个最简单的模式匹配的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Factorial</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Base case via template specialization:</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这可能是每一个介绍模板元编程都要使用的一个例子, 它利用模式匹配成功的消灭了分支, 进行了编译期的运算, 当然这是个只能演示而没有什么实际意义的代码. 但是表达了模式匹配的意义,</p>

<p>回到正题, 继续我们的 visitor, 有时候我们有遍历 <code>tuple</code> 中存储元素的需求, 最简单的比如按顺序打印, 也许还有其他的针对每个元素的操作, 理论上这和 visitor 模式是类似的. 简单的实现如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;tuple&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">int_</span><span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Functor</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">tuple_visitor_impl</span><span class="p">(</span><span class="n">Functor</span><span class="o">&amp;&amp;</span> <span class="n">functor</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">int_</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">functor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Functor</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Pos</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">tuple_visitor_impl</span><span class="p">(</span><span class="n">Functor</span><span class="o">&amp;&amp;</span> <span class="n">functor</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">int_</span><span class="o">&lt;</span><span class="n">Pos</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">functor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">-</span> <span class="n">Pos</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span><span class='line'>  <span class="n">tuple_visitor_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">functor</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">int_</span><span class="o">&lt;</span><span class="n">Pos</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Functor</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">tuple_visitor</span><span class="p">(</span><span class="n">Functor</span><span class="o">&amp;&amp;</span> <span class="n">functor</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">tuple_visitor_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">functor</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">int_</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">F</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;unexpect type: &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void F::operator()(int): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void F::operator()(double): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void F::operator()(const std::string&amp;): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">),</span> <span class="mf">3.14</span><span class="p">);</span>
</span><span class='line'>  <span class="n">F</span> <span class="n">f</span><span class="p">;</span>
</span><span class='line'>  <span class="n">tuple_visitor</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然 F 中要有针对每个类型的 <code>operator()</code>, 这样才能保证每个类型的 <code>tuple</code> 元素都能得到正确的处理, 当然由于我们有泛型版本的 <code>operator()</code> 所以任何类型都能正确接收, 只是行为不正确而已, 上面的代码中是打印出了数据类型, 更好的做法可能是抛出一个异常. 例子中的 <code>operator()</code> 都是重载, 实际上改为特化会更具通用性, 因为一旦改为特化, 那么 <code>struct F</code> 就可以变成框架内的细节, 可以做一些额外的工作. 当用户想要使用 <code>tuple_visitor</code> 的时候, 只需要针对 <code>tuple</code> 中的元素类型, 特化自己的 <code>F::operator()</code> 就可以了.</p>

<h2>tuple_expander</h2>

<p>还记得最上面介绍 <code>tuple</code> 的时候说的, <code>std::bind</code> 是用 <code>tuple</code> 来存储函数参数的吗? 那么由参数构造一个 <code>tuple</code> 是很显而易见的, 那么如何展开一个 <code>tuple</code> 呢?
这里有一个实现, 可以作为参考. <a href="https://github.com/bitdewy/snippet/blob/master/utility/expander.hpp">snippet/utility/expander.hpp</a></p>

<h2>参考</h2>

<ul>
<li>cppreference.com <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crypto++ 试用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/11/18/cryptopp-aes-rsa/"/>
    <updated>2013-11-18T00:04:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/11/18/cryptopp-aes-rsa</id>
    <content type="html"><![CDATA[<p>由于某些需求, 需要研究一下加密解密的相关内容, 于是找到了 crypto++, 常见的加密算法, 这里面差不多都有了, 但是想用的话, 还是需要先补一下密码学相关的基础知识.</p>

<h2>对等加密</h2>

<p>对等加密 (Reciprocal cipher) 又称为对称密钥加密 (Symmetric-key algorithm), 对称加密, 私钥加密, 共享密钥加密, 是密码学中的一类加密算法. 该类密码的加密算法是它自己本身的逆反函数, 所以其解密算法等同于加密算法, 也就是说, 要还原对等加密的密文, 套用加密同样的算法即可得到明文. 换句话说, 若参数 (或密钥) 合适的话, 两次连续的对等加密运算后会回复原始文字. 在数学上, 这有时称之为对合. 在实际应用中, 体现为加密和解密使用同一个密钥, 或者知道一方密钥能够轻易计算出另一方密钥.</p>

<p>常见的对称加密算法有 DES, 3DES, AES, Blowfish, IDEA, RC4, RC5, RC6.</p>

<p>在对称钥匙密码学中, 加密和解密使用相同的钥匙, 也许对不同的信息使用不同的钥匙, 但都面临钥匙管理的难题. 由于每对通讯方都必须使用异于他组的钥匙, 当网络成员的数量增加时, 钥匙数量成二次方增加. 更尴尬的难题是: 当安全的通道不存在于双方时, 如何建立一个共有的钥匙以利安全的通讯? 如果有通道可以安全地建立钥匙, 何不使用现有的通道. 这个 &ldquo;鸡生蛋, 蛋生鸡&rdquo; 的矛盾是长年以来密码学无法在真实世界应用的阻碍.</p>

<h2>公开密钥加密</h2>

<p>公开密钥加密 (英语: Public-key cryptography, 也称为非对称(密钥)加密), 该思想最早由雷夫·莫寇 (Ralph C. Merkle) 在 1974 年提出, 之后在 1976 年. 狄菲 (Whitfield Diffie) 与赫尔曼 (Martin Hellman) 两位学者以单向函数与单向暗门函数为基础, 为发讯与收讯的两方创建密钥.</p>

<p>非对称密钥, 是指一对加密密钥与解密密钥, 这两个密钥是数学相关, 用某用户密钥加密后所得的信息, 只能用该用户的解密密钥才能解密. 如果知道了其中一个, 并不能计算出另外一个. 因此如果公开了一对密钥中的一个, 并不会危害到另外一个的秘密性质. 称公开的密钥为公钥; 不公开的密钥为私钥.</p>

<!-- more -->


<p>如果加密密钥是公开的, 这用于客户给私钥所有者上传加密的数据, 这被称作为公开密钥加密 (狭义). 例如, 网络银行的客户发给银行网站的账户操作的加密数据.</p>

<p>如果解密密钥是公开的, 用私钥加密的信息, 可以用公钥对其解密, 用于客户验证持有私钥一方发布的数据或文件是完整准确的, 接收者由此可知这条信息确实来自于拥有私钥的某人, 这被称作数字签名, 公钥的形式就是数字证书. 例如, 从网上下载的安装程序, 一般都带有程序制作者的数字签名, 可以证明该程序的确是该作者 (公司) 发布的而不是第三方伪造的且未被篡改过 (身份认证/验证).</p>

<p>常见的公钥加密算法有: RSA, ElGamal, 背包算法, Rabin (RSA的特例), 迪菲－赫尔曼密钥交换协议中的公钥加密算法, 椭圆曲线加密算法 (英语: Elliptic Curve Cryptography, ECC). 使用最广泛的是 RSA 算法 (由发明者 Rivest, Shmir 和 Adleman 姓氏首字母缩写而来) 是著名的公开金钥加密算法, ElGamal 是另一种常用的非对称加密算法。</p>

<p>与对称密钥加密相比, 优点在于无需共享的通用密钥, 解密的私钥不发往任何用户. 即使公钥在网上被截获, 如果没有与其匹配的私钥, 也无法解密, 所截获的公钥是没有任何用处的.</p>

<p>由于公开密钥加密能加密的数据与密钥长度相关, 所以通常不会直接使用公开密钥加密的方式来加密数据, 在数字签名中, RSA 是用来加密/解密原始数据的散列值的(如 MD5, SHA1). 而在加密数据时, 公开密钥加密是用来加密对等加密的密钥的. 下面来看 crypto++ 中具体的加密算法的应用.</p>

<h2>AES</h2>

<p>AES, 高级加密标准 (Advanced Encryption Standard，AES), 在密码学中又称 Rijndael 加密法, 是美国联邦政府采用的一种区块加密标准. 这个标准用来替代原先的 DES, 已经被多方分析且广为全世界所使用. 经过五年的甄选流程, 高级加密标准由美国国家标准与技术研究院 (NIST) 于 2001 年 11 月 26 日发布于 FIPS PUB 197, 并在 2002 年 5 月 26 日成为有效的标准. 2006 年, 高级加密标准已然成为对称密钥加密中最流行的算法之一.</p>

<p>分组加密 (Block cipher, 又称分块加密), 是一种对称密钥算法. 它将明文分成多个等长的模块 (block), 使用确定的算法和对称密钥对每组分别加密解密.</p>

<p>分组加密就要涉及到块密码的工作模式, AES 有 5 种块密码的工作模式, 分别是: 电子密码本 (ECB), 密码块链接 (CBC), 密文反馈 (CFB), 输出反馈 (OFB), 计数器模式(CTR), 各种优缺点详见<a href="http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">块密码的工作模式</a>.</p>

<p>下面是利用 crypto++ 实现 CBC 模式的 AES 加密/解密测试程序</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &quot;aes.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;modes.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;filters.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;osrng.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;hex.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">CryptoPP</span><span class="p">;</span>
</span><span class='line'>  <span class="n">AutoSeededRandomPool</span> <span class="n">r</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">byte</span> <span class="n">key</span><span class="p">[</span><span class="n">AES</span><span class="o">::</span><span class="n">DEFAULT_KEYLENGTH</span><span class="p">];</span>
</span><span class='line'>  <span class="n">byte</span> <span class="n">iv</span><span class="p">[</span><span class="n">AES</span><span class="o">::</span><span class="n">BLOCKSIZE</span><span class="p">];</span>
</span><span class='line'>  <span class="n">r</span><span class="p">.</span><span class="n">GenerateBlock</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="o">::</span><span class="n">DEFAULT_KEYLENGTH</span><span class="p">);</span>
</span><span class='line'>  <span class="n">r</span><span class="p">.</span><span class="n">GenerateBlock</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">AES</span><span class="o">::</span><span class="n">BLOCKSIZE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">origin</span> <span class="o">=</span> <span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ciphertext</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">origin</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">AES</span><span class="o">::</span><span class="n">Encryption</span> <span class="n">aes_encryption</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="o">::</span><span class="n">DEFAULT_KEYLENGTH</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CBC_Mode_ExternalCipher</span><span class="o">::</span><span class="n">Encryption</span> <span class="n">cbc_encryption</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">,</span> <span class="n">iv</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">StreamTransformationFilter</span> <span class="n">encryptor</span><span class="p">(</span><span class="n">cbc_encryption</span><span class="p">,</span> <span class="k">new</span> <span class="n">StringSink</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">));</span>
</span><span class='line'>  <span class="n">encryptor</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="n">c_str</span><span class="p">()),</span> <span class="n">origin</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
</span><span class='line'>  <span class="n">encryptor</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">encoded</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HexEncoder</span> <span class="n">encoder</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">encoder</span><span class="p">.</span><span class="n">Put</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">ciphertext</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">ciphertext</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">encoder</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">word64</span> <span class="n">encoder_size</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">.</span><span class="n">MaxRetrievable</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">encoder_size</span> <span class="o">&amp;&amp;</span> <span class="n">encoder_size</span> <span class="o">&lt;=</span> <span class="n">SIZE_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">encoded</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">encoder_size</span><span class="p">);</span>
</span><span class='line'>      <span class="n">encoder</span><span class="p">.</span><span class="n">Get</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">encoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">encoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">encoded</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// send encoded to server</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">decoded</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HexDecoder</span> <span class="n">decoder</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">decoder</span><span class="p">.</span><span class="n">Put</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">encoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">encoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">decoder</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">word64</span> <span class="n">decoder_size</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">.</span><span class="n">MaxRetrievable</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">decoder_size</span> <span class="o">&amp;&amp;</span> <span class="n">decoder_size</span> <span class="o">&lt;=</span> <span class="n">SIZE_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">decoded</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">decoder_size</span><span class="p">);</span>
</span><span class='line'>      <span class="n">decoder</span><span class="p">.</span><span class="n">Get</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">decoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">decoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">decoded</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">AES</span><span class="o">::</span><span class="n">Decryption</span> <span class="n">aes_decryption</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="o">::</span><span class="n">DEFAULT_KEYLENGTH</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CBC_Mode_ExternalCipher</span><span class="o">::</span><span class="n">Decryption</span> <span class="n">cbc_decryption</span><span class="p">(</span><span class="n">aes_decryption</span><span class="p">,</span> <span class="n">iv</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">decrypted</span><span class="p">;</span>
</span><span class='line'>  <span class="n">StreamTransformationFilter</span> <span class="n">decryptor</span><span class="p">(</span><span class="n">cbc_decryption</span><span class="p">,</span> <span class="k">new</span> <span class="n">StringSink</span><span class="p">(</span><span class="n">decrypted</span><span class="p">));</span>
</span><span class='line'>  <span class="n">decryptor</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">decoded</span><span class="p">.</span><span class="n">c_str</span><span class="p">()),</span> <span class="n">decoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">decryptor</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">decrypted</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>RSA</h2>

<p>RSA 加密算法是一种非对称加密算法. 在公开密钥加密和电子商业中 RSA 被广泛使用. RSA 是 1977 年由罗纳德·李维斯特 (Ron Rivest), 阿迪·萨莫尔 (Adi Shamir) 和伦纳德·阿德曼 (Leonard Adleman) 一起提出的. 当时他们三人都在麻省理工学院工作. RSA 就是他们三人姓氏开头字母拼在一起组成的.</p>

<p>1973 年, 在英国政府通讯总部工作的数学家克利福德·柯克斯 (Clifford Cocks) 在一个内部文件中提出了一个相同的算法, 但他的发现被列入机密, 一直到1997年才被发表.</p>

<p>对极大整数做因数分解的难度决定了 RSA 算法的可靠性. 换言之, 对一极大整数做因数分解愈困难, RSA 算法愈可靠. 尽管如此, 只有一些 RSA 算法的变种被证明为其安全性依赖于因数分解. 假如有人找到一种快速因数分解的算法的话, 那么用 RSA 加密的信息的可靠性就肯定会极度下降. 但找到这样的算法的可能性是非常小的. 今天只有短的 RSA 钥匙才可能被强力方式解破. 到 2008 年为止, 世界上还没有任何可靠的攻击 RSA 算法的方式. 只要其钥匙的长度足够长, 用 RSA 加密的信息实际上是不能被解破的.</p>

<p>下面是利用 crypto++ 实现的 RSA 测试程序</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &quot;hex.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;osrng.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;rsa.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">CryptoPP</span><span class="p">;</span>
</span><span class='line'>  <span class="n">AutoSeededRandomPool</span> <span class="n">r</span><span class="p">;</span>
</span><span class='line'>  <span class="n">InvertibleRSAFunction</span> <span class="n">params</span><span class="p">;</span>
</span><span class='line'>  <span class="n">params</span><span class="p">.</span><span class="n">GenerateRandomWithKeySize</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">origin</span> <span class="o">=</span> <span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ciphertext</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">origin</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">RSA</span><span class="o">::</span><span class="n">PrivateKey</span> <span class="n">private_key</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
</span><span class='line'>  <span class="n">RSA</span><span class="o">::</span><span class="n">PublicKey</span> <span class="n">public_key</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">RSAES_OAEP_SHA_Encryptor</span> <span class="n">e</span><span class="p">(</span><span class="n">public_key</span><span class="p">);</span>
</span><span class='line'>  <span class="n">StringSource</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="k">new</span> <span class="n">CryptoPP</span><span class="o">::</span><span class="n">PK_EncryptorFilter</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="k">new</span> <span class="n">CryptoPP</span><span class="o">::</span><span class="n">StringSink</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">encoded</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HexEncoder</span> <span class="n">encoder</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">encoder</span><span class="p">.</span><span class="n">Put</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">ciphertext</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">ciphertext</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">encoder</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">word64</span> <span class="n">encoder_size</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">.</span><span class="n">MaxRetrievable</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">encoder_size</span> <span class="o">&amp;&amp;</span> <span class="n">encoder_size</span> <span class="o">&lt;=</span> <span class="n">SIZE_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">encoded</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">encoder_size</span><span class="p">);</span>
</span><span class='line'>      <span class="n">encoder</span><span class="p">.</span><span class="n">Get</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">encoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">encoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">encoded</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// send encoded to server</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">decoded</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HexDecoder</span> <span class="n">decoder</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">decoder</span><span class="p">.</span><span class="n">Put</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">encoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">encoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="n">decoder</span><span class="p">.</span><span class="n">MessageEnd</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">word64</span> <span class="n">decoder_size</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">.</span><span class="n">MaxRetrievable</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">decoder_size</span> <span class="o">&amp;&amp;</span> <span class="n">decoder_size</span> <span class="o">&lt;=</span> <span class="n">SIZE_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">decoded</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">decoder_size</span><span class="p">);</span>
</span><span class='line'>      <span class="n">decoder</span><span class="p">.</span><span class="n">Get</span><span class="p">((</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">decoded</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">decoded</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">decoded</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">decrypted</span><span class="p">;</span>
</span><span class='line'>  <span class="n">RSAES_OAEP_SHA_Decryptor</span> <span class="n">d</span><span class="p">(</span><span class="n">private_key</span><span class="p">);</span>
</span><span class='line'>  <span class="n">StringSource</span><span class="p">(</span><span class="n">decoded</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="k">new</span> <span class="n">CryptoPP</span><span class="o">::</span><span class="n">PK_DecryptorFilter</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="k">new</span> <span class="n">CryptoPP</span><span class="o">::</span><span class="n">StringSink</span><span class="p">(</span><span class="n">decrypted</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">decrypted</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://www.cryptopp.com/">Crypto++ HomePage</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a></li>
<li><a href="http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">Block cipher mode of operation</a></li>
<li><a href="http://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">RSA</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理(一)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理(二)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[返回值类型推导]]></title>
    <link href="http://bitdewy.github.com/blog/2013/11/11/return-type-resolver/"/>
    <updated>2013-11-11T10:21:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/11/11/return-type-resolver</id>
    <content type="html"><![CDATA[<p>模版函数的参数类型可以自动推导, 它可以让我们在调用函数的时候不必写丑陋的<code>&lt;&gt;</code>, 但如果是返回值类型需要自动推导, 似乎就没有那么容易了. 虽然语言本身不支持返回值的类型自动推导, 但我们可以尝试其他的办法来完成这项任务.</p>

<h2>目的</h2>

<p>在使用函数返回值初始化变量或给变量赋值时模版函数能够自动推导出类型.</p>

<h2>例子</h2>

<p>在某些情况下, 明确被初始化的变量类型是有用的. 考虑下面的例子, 我们使用随机数来初始化 STL 容器. 但是我们不知道用户会选择哪个具体的容器类型. 它可能是 <code>std::list</code>, <code>std::vector</code> 或者其他的行为像 STL 容器的自定义类型. 最直接的方法如下所示:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;random&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">Container</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>我们可以注意到, 代码中必须显示的指定返回值的类型, 很显然我们必须写两次返回值类型, 类型声明写一次, 函数调用又写了一次. 返回值类型推导可以帮助我们解决这个问题, 当然 C++11 中的 auto 类型也可以解决.</p>

<h2>解决方案 &amp; 示例代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'><span class="cp">#include &lt;set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;random&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">GetRandomN</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">GetRandomN</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">operator</span> <span class="n">Container</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">());</span> <span class="c1">// push_back is not supported by all standard containers.</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_s</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_v</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_l</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类 GetRandomN 有一个构造函数, 以及一个模版的类型隐式转换函数. 初始化的时候, 会产生一个 GetRandomN 类的临时对象, 当赋值给 STL 容器类型时, 编译器会去尝试将对象隐式转换. 而隐式转换的途径就是取寻找隐式转换函数, 这样就完成了返回值自动推导. 有了返回值类型自动推导, 我们就不必手写返回值类型参数了. 唔… 再注意一点, 为了支持 <code>std::set</code> 我们将原始的 <code>push_back</code> 函数改为了 <code>insert</code>.</p>

<p><em>注: 在 C++11 引入 <code>nullptr</code> 之前, 手工实现一个 <code>nullptr</code> 的惯用法就使用了返回值类型推导.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向切面编程(AOP)]]></title>
    <link href="http://bitdewy.github.com/blog/2013/10/20/aop/"/>
    <updated>2013-10-20T13:58:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/10/20/aop</id>
    <content type="html"><![CDATA[<p>上周同事问了个没法回答的问题, <em>“统计, 日志应该放到哪一层, 或者哪个模块中?”</em></p>

<p>首先, 所有的编程范式都不是万能的, 更不用说<a href="http://existentialtype.wordpress.com/2011/03/15/teaching-fp-to-freshmen/">反并发、反模块化</a>的面向对象范式了. 我们不能总是以同一种编程范式来思考问题. 类似日志, 权限验证, 事务管理等会横跨多个模块的东西, 我们需要新的思路来解决代码割裂的问题.</p>

<h2>面向切面编程</h2>

<p>面向切面编程 (AOP), 不是什么新玩意儿, 早在 199x 年开始, 研究人员就对面向对象思想的局限性进行了分析. 研究出了一种新的编程思想, 借助这一思想可以通过减少代码重复模块从而帮助开发人员提高工作效率. 随着研究的逐渐深入, AOP 也逐渐发展成一套完整的程序设计思想, 各种应用 AOP 的技术也应运而生. 比较著名的有 Java 阵营的 AspectJ 和 Spring AOP, C++ 中也有 AspectC++.</p>

<h3>AOP 中的概念</h3>

<ul>
<li>cross-cutting concerns, (横切关注点)指的是一些具有横越多个模块的行为, 使用传统的软件开发方法不能够达到有效的模块化的一类特殊关注点. 如日志, 权限验证等不属于业务逻辑, 但多个模块都需要插入的东西, 即属于横切关注点.</li>
<li>advice, (通知)指的是切面中的具体逻辑. 如打印日志, 验证权限.</li>
<li>pointcut, (切入点)指的是切面代码要插入的位置.</li>
<li>aspect, (切面)指的是通知以及切入点模块化之后的整体.</li>
</ul>


<p>上面的内容都属于动态横切, 基本上所作的工作就是方法拦截, 插入指定的代码. 还有一种静态横切, Mixin 它可以可以在不修改原有职责的基础上增加新的职责, 可以模拟多继承, 而不增加耦合性, 不过这就不是本文所要讨论的内容了.</p>

<p>看下面的伪代码来感受一下 AOP:</p>

<!-- more -->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function mainProgram()
</span><span class='line'>{
</span><span class='line'>  var x =  foo();
</span><span class='line'>  doSomethingWith(x);
</span><span class='line'>  return x;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>aspect logging
</span><span class='line'>{
</span><span class='line'>  before (mainProgram is called):
</span><span class='line'>  {
</span><span class='line'>    log.Write("entering mainProgram");
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  after (mainProgram is called):
</span><span class='line'>  {
</span><span class='line'>    log.Write("exiting mainProgram with return value of "
</span><span class='line'>              + mainProgram.returnValue);
</span><span class='line'>  }
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>aspect verification
</span><span class='line'>{
</span><span class='line'>  before (doSomethingWith is called):
</span><span class='line'>  {
</span><span class='line'>    if (doSomethingWith.arguments[0] == null) 
</span><span class='line'>    {
</span><span class='line'>      throw NullArgumentException();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (!doSomethingWith.caller.isAuthenticated)
</span><span class='line'>    {
</span><span class='line'>      throw Securityexception();
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>有了业务代码, 并且定义好了切面, 以及切入点等一切 AOP 所需的内容之后, 通过一些神奇的办法, 我们最终生成的代码看起来应该和下面的差不多:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function mainProgram()
</span><span class='line'>{
</span><span class='line'>  log.Write("entering mainProgram");
</span><span class='line'>
</span><span class='line'>  var x = foo();   
</span><span class='line'>
</span><span class='line'>  if (x == null) throw NullArgumentException();
</span><span class='line'>  if (!mainProgramIsAuthenticated()) throw Securityexception();
</span><span class='line'>  doSomethingWith(x);   
</span><span class='line'>
</span><span class='line'>  log.Write("exiting mainProgram with return value of "+ x);
</span><span class='line'>  return x;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样就解决了文中开头提的问题. 日志, 权限验证这些会分散在各个模块中的东西, 通过 AOP 避免了割裂, 保持了完整性.</p>

<p>在 C++ 中, 可以使用 template 来模拟切面, 类似《Modern C++ Design》中所讲述的基于 policy 的设计.</p>

<p>在纯函数式的编程语言中, 也许用高阶函数就可以直接模拟 AOP ?</p>

<h2>参考</h2>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-oriented programming</a></li>
<li>Java: <a href="http://docs.spring.io/spring/docs/2.5.x/reference/aop.html">Spring AOP</a></li>
<li><a href="http://www.lisha.ufsc.br/teaching/sce/aop_with_c++.pdf">Aspect-Oriented Programming with C++</a></li>
<li><a href="http://www.aspectc.org/">AspectC++</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异常与多线程]]></title>
    <link href="http://bitdewy.github.com/blog/2013/09/23/exception-and-multithread/"/>
    <updated>2013-09-23T23:30:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/09/23/exception-and-multithread</id>
    <content type="html"><![CDATA[<p>C++ 的异常机制为程序员提供了一种处理错误的方式, 使程序员可以用更自然的方式处理错误.(但 C++ 的异常存在各种坑, 参考《More Effective C++》Item 13: Catch exceptions by reference).</p>

<p>有些时候, 我们不得不使用多线程来提高工作的执行效率, 但由于异常都是基于线程的, 如何在线程间传递异常, 就成为了一个问题. C++11 之前异常是无法在线程之前传递的, C++11 在这方面提供了支持.</p>

<h2>使用 C++11 中的异常相关内容实现在线程间传递异常</h2>

<p>相关类如下:</p>

<p><code>std::exception_ptr</code></p>

<ul>
<li>一个智能指针类型的异常对象, 支持 bool 操作符, 可以存储空异常 (null) 对象. 也支持比较 (operator==).</li>
</ul>


<p><code>std::current_exception</code></p>

<ul>
<li>当在异常处理块中 (catch块) 调用时, 会捕获当前异常对象并由被捕获的对象创建一个 <code>std::exception_ptr</code> 对象并返回.</li>
</ul>


<p><code>std::make_exception_ptr</code></p>

<ul>
<li>接受一个 Exception 对象参数, 并由这个异常对象创建一个 <code>std::exception_ptr</code> 对象</li>
</ul>


<p><code>std::rethrow_exception</code></p>

<ul>
<li>接受一个 <code>std::exception_ptr</code> 参数, 重新抛出这个异常</li>
</ul>


<p>(<em>以上的一切, 很大一部分都是因为 C++ 的值传递特性引起的一系列不适!!!</em>, !!(╯&#8217; &ndash; &lsquo;)╯︵ ┻━┻)</p>

<!-- more -->


<p>示例代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;exception&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">calc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&amp;</span> <span class="n">eptr</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="n">s</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// throw out of range exception</span>
</span><span class='line'>    <span class="n">eptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_exception_ptr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">());</span> <span class="c1">// if no exception use default</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">eptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">eptr</span><span class="p">;</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">calc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">eptr</span><span class="p">)));</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">eptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">eptr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如代码所示:</p>

<p>函数 calc 在子线程中工作, 并有可能抛出异常. 主线程中, 等待子线程返回结果, 并在返回后检测是否有异常, 如果有异常, 则重新抛出异常. 主线程将上述工作都放到 try 块中, 如果有异常则打印. 这样, 子线程 calc 函数的异常就被成功的转移到了主线程中.</p>

<h2>参考</h2>

<ul>
<li>《More Effective C++》Item 13: Catch exceptions by reference</li>
<li>Cppreference.com <a href="http://en.cppreference.com/w/cpp/error">http://en.cppreference.com/w/cpp/error</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11中的原子操作 (atomic operation)]]></title>
    <link href="http://bitdewy.github.com/blog/2013/09/02/atomic-operation/"/>
    <updated>2013-09-02T23:34:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/09/02/atomic-operation</id>
    <content type="html"><![CDATA[<p>所谓的原子操作, 取的就是 “原子是最小的, 不可分割的最小个体” 的意义, 它表示在多个线程访问同一个全局资源的时候, 能够确保所有其他的线程都不在同一时间内访问相同的资源. 也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问. 这有点类似互斥对象对共享资源的访问的保护, 但是原子操作更加接近底层, 因而效率更高.</p>

<p>在以往的 C++ 标准中并没有对原子操作进行规定, 我们往往是使用汇编语言, 或者是借助第三方的线程库, 例如 intel 的 pthread 来实现. 在新标准 C++11, 引入了原子操作的概念, 并通过这个新的头文件提供了多种原子操作数据类型, 例如, atomic_bool, atomic_int 等等, 如果我们在多个线程中对这些类型的共享资源进行操作, 编译器将保证这些操作都是原子性的, 也就是说, 确保任意时刻只有一个线程对这个资源进行访问, 编译器将保证, 多个线程访问这个共享资源的正确性. 从而避免了锁的使用, 提高了效率.</p>

<p>我们还是来看一个实际的例子. 假若我们要设计一个广告点击统计程序, 在服务器程序中, 使用多个线程模拟多个用户对广告的点击:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;time.h&gt;</span>
</span><span class='line'><span class="c1">// 全局的结果数据</span>
</span><span class='line'><span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 点击函数</span>
</span><span class='line'><span class="kt">void</span> <span class="n">click</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 对全局数据进行无锁访问</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 计时开始</span>
</span><span class='line'>  <span class="n">clock_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// 创建100个线程模拟点击统计</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threads</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">click</span><span class="p">);</span>
</span><span class='line'>    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">swap</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// 计时结束</span>
</span><span class='line'>  <span class="n">clock_t</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// 输出结果</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;result:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">total</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;duration:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">finish</span> <span class="o">-</span><span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ms&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>执行结果如下:</p>

<blockquote><p>result: 955700</p>

<p>duration: 49ms</p></blockquote>

<p>从执行的结果来看, 这样的方法虽然非常快, 但是结果不正确.</p>

<p>很自然地, 我们会想到使用互斥对象来对全局共享资源的访问进行保护, 于是有了下面的实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 点击函数</span>
</span><span class='line'><span class="kt">void</span> <span class="n">click</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 对全局数据进行无锁访问</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">///</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果如下:</p>

<blockquote><p>result: 1000000</p>

<p>duration: 32350ms</p></blockquote>

<p>互斥对象的使用, 保证了同一时刻只有唯一的一个线程对这个共享进行访问, 从执行的结果来看, 互斥对象保证了结果的正确性, 但是也有非常大的性能损失, 从刚才的 49ms 变成了现在的 32350ms. 这 TMD 差距也太大了.(感觉有些异常，差距没理由这么大的, 可能是线程太多, CPU 光忙着线程切换了 = =!)</p>

<p>如果是在 C++11 之前, 我们的解决方案也就到此为止了. 但是, C++ 对性能的追求是永无止境的, 他总是想尽一切办法榨干 CPU 的性能. 在 C++11 中, 实现了原子操作的数据类型 (atomic_bool, atomic_int, atomic_long 等等), 对于这些原子数据类型的共享资源的访问, 无需借助 mutex 等锁机制, 也能够实现对共享资源的正确访问.</p>

<p>将原本的 long 类型改为 std::atomic_long 类型即可</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">//long total = 0;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">atomic_long</span> <span class="n">total</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>运行结果如下:</p>

<blockquote><p>result: 1000000</p>

<p>duration: 117ms</p></blockquote>

<p>结果正确, 时间上仅仅是不采用任何保护机制时的 3 倍左右, 和使用 mutex 做同步的版本不知差了几个数量级了.</p>

<p>原子操作的实现跟普通数据类型类似, 但是它能够在保证结果正确的前提下, 提供比 mutex 等锁机制更好的性能, 如果我们要访问的共享资源可以用原子数据类型表示, 那么在多线程程序中使用这种新的等价数据类型, 是一个不错的选择.</p>

<p>但值得注意的是, <code>std::atomic</code> 只能作用于基本类型以及 POD 类型上.</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/atomic/atomic">CppReference.com &ndash; atomic</a></li>
<li><a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2">C++ and Beyond 2012: Herb Sutter &ndash; atomic&lt;> Weapons</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步编程 async & await]]></title>
    <link href="http://bitdewy.github.com/blog/2013/08/20/async-and-await/"/>
    <updated>2013-08-20T01:17:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/08/20/async-and-await</id>
    <content type="html"><![CDATA[<h2>使用异步编程</h2>

<p>使用异步编程, 可以避免性能瓶颈和增强应用程序的总体响应能力. 但是编写异步程序在以前技术上比较复杂, 使得它们难以编写, 调试以及维护.</p>

<p>在 .NET Framework 4.5 中, 引入了简化的异步编程方式, 编译器帮我们实现了之前需要实现的异步操作, 程序员只需要关注自己的代码逻辑即可. 程序员可以更专注到业务逻辑当中.</p>

<h2>async &amp; await</h2>

<p>在 C# 中, 关键字 async 和 await 是异步编程的核心, 当使用这两个关键字的时候, 我们可以直接创建一个异步函数, 就像创建一个同步函数一样简单. 看下面的例子, 所有的东西看起来都是那么的熟悉.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Three things to note in the signature: </span>
</span><span class='line'><span class="c1">//  - The method has an async modifier.  </span>
</span><span class='line'><span class="c1">//  - The return type is Task or Task&lt;T&gt;. (See &quot;Return Types&quot; section.)</span>
</span><span class='line'><span class="c1">//    Here, it is Task&lt;int&gt; because the return statement returns an integer. </span>
</span><span class='line'><span class="c1">//  - The method name ends in &quot;Async.&quot;</span>
</span><span class='line'><span class="n">async</span> <span class="n">Task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">AccessTheWebAsync</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// You need to add a reference to System.Net.Http to declare client.</span>
</span><span class='line'>    <span class="n">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// GetStringAsync returns a Task&lt;string&gt;. That means that when you await the </span>
</span><span class='line'>    <span class="c1">// task you&#39;ll get a string (urlContents).</span>
</span><span class='line'>    <span class="n">Task</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">getStringTask</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">(</span><span class="s">&quot;http://msdn.microsoft.com&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// You can do work here that doesn&#39;t rely on the string from GetStringAsync.</span>
</span><span class='line'>    <span class="n">DoIndependentWork</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The await operator suspends AccessTheWebAsync. </span>
</span><span class='line'>    <span class="c1">//  - AccessTheWebAsync can&#39;t continue until getStringTask is complete. </span>
</span><span class='line'>    <span class="c1">//  - Meanwhile, control returns to the caller of AccessTheWebAsync. </span>
</span><span class='line'>    <span class="c1">//  - Control resumes here when getStringTask is complete.  </span>
</span><span class='line'>    <span class="c1">//  - The await operator then retrieves the string result from getStringTask. </span>
</span><span class='line'>    <span class="n">string</span> <span class="n">urlContents</span> <span class="o">=</span> <span class="n">await</span> <span class="n">getStringTask</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The return statement specifies an integer result. </span>
</span><span class='line'>    <span class="c1">// Any methods that are awaiting AccessTheWebAsync retrieve the length value. </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">urlContents</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h2>async 方法中到底发生了什么？</h2>

<p>在异步编程中, 最重要的需要了解的事情是, 方法与方法之间的执行流程是什么. 下面的图可以帮助我们理解执行流程.</p>

<p><img src="https://qhphgq.bay.livefilestore.com/y2pPcdpEqnMPWdvKOr5yjswLE7F201mPiHRsjrk0PteSCWt9jdSWQxA3Tgkas4qOECf2vishbMkp4GnpFvE_ZQJcMwRppgT7hM0UrQxVevorwg/async.png" alt="" /></p>

<p>图上的标记对应以下步骤</p>

<ol>
<li>事件处理程序调用并等待 AccessTheWebAsync 异步方法.</li>
<li>AccessTheWebAsync 创建 HttpClient 实例并调用GetStringAsync 异步方法下载网页内容, 作为字符串.</li>
<li>GetStringAsync 会造成挂起, 这时会发生一些事情. 可能它必须等待网页下载完成或者其他一些会阻塞的事情. 为了避免阻塞, GetStringAsync 会交出控制权给他的调用者, AccessTheWebAsync. AccessTheWebAsync 是返回一个模板参数是 string 的 Task 对象, 赋值给 getStringTask 变量. task 不会因为 GetStringAsync 的调用而阻塞当前进程, 而是当任务实际执行完成时, 再提交.</li>
<li>由于 getStringTask 此时还没有 await, AccessTheWebAsync 可以继续执行一些不依赖 GetStringAsync 结果的一些操作. 这些工作在一个同步的叫做 DoIndependentWork 函数中执行.</li>
<li>DoIndependentWork 是一个同步函数, 当它的工作做完之后会将结果返回给调用者.</li>
<li><p>AccessTheWebAsync 做完了不依赖 getStringTask 的所有事情, AccessTheWekAsync 接下来需要计算 getStringTask 的结果, 但是此时函数还没有返回. 因此, AccessTheWebAsync 使用了 await 将当前的操作挂起, 然后将控制权移交到 AccessTheWebAsync 的调用者. AccessTheWebAsync 返回一个 task<int> 给调用者. 这个 task 给了外部一个承诺 (promise) 当计算完成时会返回给调用者一个整数, 这个整数就是下载的数据量的长度. <em>注意: 如果 GetStringAsync (以及 getStringTask) 在 AccessTheWebAsync await 之前就完成了, 那么控制权会仍然在 AccessTheWebAsync 中. 如果在不需要 await 时, 还继续进行代价很高的控制权转移的话, 是严重的浪费.</em> 在调用者中 (本例的 event handler), 这个过程会重复多次. 调用者可能会在 await 之前, 做一些其他的不依赖 AccessTheWebAsync 的操作, 或者直接 await. 当 event handler 执行到 await 语句时, 应用程序正在等待 AccessTheWebAsync, 同时 AccessTheWebAsync 正在等待 GetStringAsync.</p></li>
<li><p>GetStringAsync 完成工作并返回了字符串结果. 这个字符串不是直接由 GetStringAsync 调用返回的. (在第 3 步的时候我们就已经返回了一个 task). 取而代之, 这个字符串是存储在已完成的 task 中的, getStringTask. await 会得到 getStringTask 的结果. 赋值语句会将得到的结果赋值给 urlContents.</p></li>
<li>当 AccessTheWebSync 得到了结果之后, 他就可以计算字符串的长度了. 然后 AccessTheWebAsync 的任务就全部完成了. 正在等待的 event handler 就可以恢复工作了.</li>
</ol>


<h2>C++ 中的 async 以及 await</h2>

<p>上面是一个 C# 的例子, C++11 中虽然对线程的支持作了相当多的工作, 但是异步编程方面还没有引入与 C# 中的 async 以及 await 类似的东西. 但标准委员会正在做这方面的工作, 提案名字叫做 Resumable Functions (n3650), 虽然 C++14 中不会引入这个特性 (这个特性应该是 C++1y 中的特性 (y应该等于7)), 但微软会很快的将该特性的实现引入到新版的 visual studio 中.</p>

<p>一个例子感受一下没有 async 以及 await 时我们是如何做异步编程的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'>   <span class="p">.</span><span class="n">then</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">fi</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span>
</span><span class='line'>         <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">task</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span>
</span><span class='line'>      <span class="p">[</span><span class="o">=</span><span class="p">]{</span>
</span><span class='line'>         <span class="n">fi</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
</span><span class='line'>         <span class="p">.</span><span class="n">then</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span> <span class="n">chunk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>               <span class="o">*</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
</span><span class='line'>               <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)();</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
</span><span class='line'>         <span class="p">});</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)();</span>
</span><span class='line'>   <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看看上面的一堆代码，WTF，谁能快速的搞明白？？？？？</p>

<p>再看看下面清爽的代码吧…</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span> <span class="p">)</span> <span class="n">__async</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">__await</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">,</span> <span class="n">chunk</span><span class="p">;</span>
</span><span class='line'>   <span class="k">while</span><span class="p">((</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">__await</span> <span class="n">fi</span><span class="p">.</span><span class="n">read</span><span class="p">()).</span><span class="n">size</span><span class="p">())</span>
</span><span class='line'>      <span class="n">ret</span> <span class="o">+=</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是迫不及待的想要尝试了呢？</p>

<h2>参考</h2>

<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx">Asynchronous Programming with Async and Await (C# and Visual Basic)</a></li>
<li><a href="http://channel9.msdn.com/Events/Build/2013/2-306">The future of C++</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Attorney Client]]></title>
    <link href="http://bitdewy.github.com/blog/2013/08/14/attorney-client/"/>
    <updated>2013-08-14T00:45:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/08/14/attorney-client</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>控制访问一个类内部实现细节的粒度.</p>

<h2>动机</h2>

<p>C++ 的友元申明可以完全访问一个类的内部细节. 所以, 唔, 友元太邪恶了, 它破坏了精心的封装. C++ 中不提供选择性的授权访问类私有成员子集的方式. 在 C++ 中要么使用友元, 可以访问一个类的全部细节, 要么不用友元, 只能访问公有接口.</p>

<p>看下面的例子, 下面的类 Foo 中声明了 Bar 友元. 因此 Bar 类可以访问 Foo 的全部私有成员. 这不可取, 因为它增加了耦合. Bar 类会变得没有 Foo 类就无法单独使用.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">B</span><span class="p">(</span><span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">C</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="c1">// This class needs access to Foo::A and Foo::B only.</span>
</span><span class='line'><span class="c1">// C++ friendship rules, however, give access to all the private members of Foo.</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>提供选择性访问成员子集的功能, 是可取的. 这样的话, 剩余的私有成员如果需要的话, 可以更改接口. 它有助于减少两个类之间的耦合. Attorney-Client 可以精确控制它的友元能够访问的成员的数量.</p>

<!-- more -->


<h2>解决方案 &amp; 示例代码</h2>

<p>Attorney-Client 通过增加一个间接层来解决上面描述的问题. 想要访问一个类的实现细节, 我们需要一个 Attorney 类, 一个真正的 C++ 友元. Attorney 类是精心设计的一个代理类. 和一般的代理类不同, Attorney 类只负责复制 Foo 类的内部实现的接口的子集. 为了更好的描述, 我们把 Foo 类重新命名为 Client, Client 仅仅想通过 Attorney 提供 Client::A 以及 Client::B 的访问权限.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Client</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">B</span><span class="p">(</span><span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">C</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Attorney</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Attorney</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">void</span> <span class="n">callA</span><span class="p">(</span><span class="n">Client</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span><span class="p">.</span><span class="n">A</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">void</span> <span class="n">callB</span><span class="p">(</span><span class="n">Client</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span><span class="p">.</span><span class="n">B</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="c1">// Bar now has access to only Client::A and Client::B through the Attorney.</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Attorney 类限制仅能访问部分函数, Attorney 类中仅函数静态内联成员函数, 每个都需要一个 Client 类实例的引用, 然后将调用转到这个实例上. 他的实现是完全私有的. 这可以禁止其他类去访问 Client 内部. Attorney 可以决定哪些类, 成员函数, 以及自由函数可以访问 Client. 它只需要将能访问这些细节的东西声明为友元即可. 如果没有 Attorney 类, Client 也需要子集来做.</p>

<p>它也可以有多个 attorney 类来提供访问 Client 的不同细节. 比如 AttorneyC 类只提供 Client::C 的访问.</p>

<p>在下面的例子中, Attorney-client 用在了 类 Base 和 main 函数中间. Derived::Func 函数通过多态性得以访问. 不过如果想要再访问 Derived 类的一些细节的时候, 那就需要再次使用 Attorney 了.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;cstdio&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Attorney</span><span class="p">;</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Derived::Func</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="c1">// This is called even though main is not a friend of Derived.</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="o">~</span><span class="n">Derived</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Attorney</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">void</span> <span class="n">callFunc</span><span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">Func</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">friend</span> <span class="kt">int</span> <span class="n">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Attorney</span><span class="o">::</span><span class="n">callFunc</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>已知的应用</h2>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_50_0/libs/iterator/doc/iterator_facade.html#iterator-core-access">Boost.Iterators library</a></li>
<li><a href="http://www.boost.org/doc/libs/1_50_0/libs/serialization/doc/serialization.html#member">Boost.Serialization: class boost::serialization::access</a></li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="http://drdobbs.com/184402053">Friendship and the Attorney-Client Idiom (Dr. Dobb&rsquo;s Journal)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
