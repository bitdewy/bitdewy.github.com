<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bitdewy]]></title>
  <link href="http://bitdewy.github.com/atom.xml" rel="self"/>
  <link href="http://bitdewy.github.com/"/>
  <updated>2013-11-11T13:17:36+08:00</updated>
  <id>http://bitdewy.github.com/</id>
  <author>
    <name><![CDATA[bitdewy]]></name>
    <email><![CDATA[bitdewy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[返回值类型推导]]></title>
    <link href="http://bitdewy.github.com/blog/2013/11/11/return-type-resolver/"/>
    <updated>2013-11-11T10:21:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/11/11/return-type-resolver</id>
    <content type="html"><![CDATA[<p>模版函数的参数类型可以自动推导, 它可以让我们在调用函数的时候不必写丑陋的<code>&lt;&gt;</code>, 但如果是返回值类型需要自动推导, 似乎就没有那么容易了. 虽然语言本身不支持返回值的类型自动推导, 但我们可以尝试其他的办法来完成这项任务.</p>

<h2>目的</h2>

<p>在使用函数返回值初始化变量或给变量赋值时模版函数能够自动推导出类型.</p>

<h2>例子</h2>

<p>在某些情况下, 明确被初始化的变量类型是有用的. 考虑下面的例子, 我们使用随机数来初始化 STL 容器. 但是我们不知道用户会选择哪个具体的容器类型. 它可能是 <code>std::list</code>, <code>std::vector</code> 或者其他的行为像 STL 容器的自定义类型. 最直接的方法如下所示:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;random&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">Container</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>我们可以注意到, 代码中必须显示的指定返回值的类型, 很显然我们必须写两次返回值类型, 类型声明写一次, 函数调用又写了一次. 返回值类型推导可以帮助我们解决这个问题, 当然 C++11 中的 auto 类型也可以解决.</p>

<h2>解决方案 &amp; 示例代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'><span class="cp">#include &lt;set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;random&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">GetRandomN</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">GetRandomN</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">operator</span> <span class="n">Container</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">());</span> <span class="c1">// push_back is not supported by all standard containers.</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_s</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_v</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">random_l</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类 GetRandomN 有一个构造函数, 以及一个模版的类型隐式转换函数. 初始化的时候, 会产生一个 GetRandomN 类的临时对象, 当赋值给 STL 容器类型时, 编译器会去尝试将对象隐式转换. 而隐式转换的途径就是取寻找隐式转换函数, 这样就完成了返回值自动推导. 有了返回值类型自动推导, 我们就不必手写返回值类型参数了. 唔… 再注意一点, 为了支持 <code>std::set</code> 我们将原始的 <code>push_back</code> 函数改为了 <code>insert</code>.</p>

<p><em>注: 在 C++11 引入 <code>nullptr</code> 之前, 手工实现一个 <code>nullptr</code> 的惯用法就使用了返回值类型推导.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向切面编程(AOP)]]></title>
    <link href="http://bitdewy.github.com/blog/2013/10/20/aop/"/>
    <updated>2013-10-20T13:58:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/10/20/aop</id>
    <content type="html"><![CDATA[<p>上周同事问了个没法回答的问题, <em>“统计, 日志应该放到哪一层, 或者哪个模块中?”</em></p>

<p>首先, 所有的编程范式都不是万能的, 更不用说<a href="http://existentialtype.wordpress.com/2011/03/15/teaching-fp-to-freshmen/">反并发、反模块化</a>的面向对象范式了. 我们不能总是以同一种编程范式来思考问题. 类似日志, 权限验证, 事务管理等会横跨多个模块的东西, 我们需要新的思路来解决代码割裂的问题.</p>

<h2>面向切面编程</h2>

<p>面向切面编程 (AOP), 不是什么新玩意儿, 早在 199x 年开始, 研究人员就对面向对象思想的局限性进行了分析. 研究出了一种新的编程思想, 借助这一思想可以通过减少代码重复模块从而帮助开发人员提高工作效率. 随着研究的逐渐深入, AOP 也逐渐发展成一套完整的程序设计思想, 各种应用 AOP 的技术也应运而生. 比较著名的有 Java 阵营的 AspectJ 和 Spring AOP, C++ 中也有 AspectC++.</p>

<h3>AOP 中的概念</h3>

<ul>
<li>cross-cutting concerns, (横切关注点)指的是一些具有横越多个模块的行为, 使用传统的软件开发方法不能够达到有效的模块化的一类特殊关注点. 如日志, 权限验证等不属于业务逻辑, 但多个模块都需要插入的东西, 即属于横切关注点.</li>
<li>advice, (通知)指的是切面中的具体逻辑. 如打印日志, 验证权限.</li>
<li>pointcut, (切入点)指的是切面代码要插入的位置.</li>
<li>aspect, (切面)指的是通知以及切入点模块化之后的整体.</li>
</ul>


<p>上面的内容都属于动态横切, 基本上所作的工作就是方法拦截, 插入指定的代码. 还有一种静态横切, Mixin 它可以可以在不修改原有职责的基础上增加新的职责, 可以模拟多继承, 而不增加耦合性, 不过这就不是本文所要讨论的内容了.</p>

<p>看下面的伪代码来感受一下 AOP:</p>

<!-- more -->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function mainProgram()
</span><span class='line'>{
</span><span class='line'>  var x =  foo();
</span><span class='line'>  doSomethingWith(x);
</span><span class='line'>  return x;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>aspect logging
</span><span class='line'>{
</span><span class='line'>  before (mainProgram is called):
</span><span class='line'>  {
</span><span class='line'>    log.Write("entering mainProgram");
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  after (mainProgram is called):
</span><span class='line'>  {
</span><span class='line'>    log.Write("exiting mainProgram with return value of "
</span><span class='line'>              + mainProgram.returnValue);
</span><span class='line'>  }
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>aspect verification
</span><span class='line'>{
</span><span class='line'>  before (doSomethingWith is called):
</span><span class='line'>  {
</span><span class='line'>    if (doSomethingWith.arguments[0] == null) 
</span><span class='line'>    {
</span><span class='line'>      throw NullArgumentException();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (!doSomethingWith.caller.isAuthenticated)
</span><span class='line'>    {
</span><span class='line'>      throw Securityexception();
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>有了业务代码, 并且定义好了切面, 以及切入点等一切 AOP 所需的内容之后, 通过一些神奇的办法, 我们最终生成的代码看起来应该和下面的差不多:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function mainProgram()
</span><span class='line'>{
</span><span class='line'>  log.Write("entering mainProgram");
</span><span class='line'>
</span><span class='line'>  var x = foo();   
</span><span class='line'>
</span><span class='line'>  if (x == null) throw NullArgumentException();
</span><span class='line'>  if (!mainProgramIsAuthenticated()) throw Securityexception();
</span><span class='line'>  doSomethingWith(x);   
</span><span class='line'>
</span><span class='line'>  log.Write("exiting mainProgram with return value of "+ x);
</span><span class='line'>  return x;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样就解决了文中开头提的问题. 日志, 权限验证这些会分散在各个模块中的东西, 通过 AOP 避免了割裂, 保持了完整性.</p>

<p>在 C++ 中, 可以使用 template 来模拟切面, 类似《Modern C++ Design》中所讲述的基于 policy 的设计.</p>

<p>在纯函数式的编程语言中, 也许用高阶函数就可以直接模拟 AOP ?</p>

<h2>参考</h2>

<ul>
<li>wikipedia: <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-oriented programming</a></li>
<li>Java: <a href="http://docs.spring.io/spring/docs/2.5.x/reference/aop.html">Spring AOP</a></li>
<li><a href="http://www.lisha.ufsc.br/teaching/sce/aop_with_c++.pdf">Aspect-Oriented Programming with C++</a></li>
<li><a href="http://www.aspectc.org/">AspectC++</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异常与多线程]]></title>
    <link href="http://bitdewy.github.com/blog/2013/09/23/exception-and-multithread/"/>
    <updated>2013-09-23T23:30:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/09/23/exception-and-multithread</id>
    <content type="html"><![CDATA[<p>C++ 的异常机制为程序员提供了一种处理错误的方式, 使程序员可以用更自然的方式处理错误.(但 C++ 的异常存在各种坑, 参考《More Effective C++》Item 13: Catch exceptions by reference).</p>

<p>有些时候, 我们不得不使用多线程来提高工作的执行效率, 但由于异常都是基于线程的, 如何在线程间传递异常, 就成为了一个问题. C++11 之前异常是无法在线程之前传递的, C++11 在这方面提供了支持.</p>

<h2>使用 C++11 中的异常相关内容实现在线程间传递异常</h2>

<p>相关类如下:</p>

<p><code>std::exception_ptr</code></p>

<ul>
<li>一个智能指针类型的异常对象, 支持 bool 操作符, 可以存储空异常 (null) 对象. 也支持比较 (operator==).</li>
</ul>


<p><code>std::current_exception</code></p>

<ul>
<li>当在异常处理块中 (catch块) 调用时, 会捕获当前异常对象并由被捕获的对象创建一个 <code>std::exception_ptr</code> 对象并返回.</li>
</ul>


<p><code>std::make_exception_ptr</code></p>

<ul>
<li>接受一个 Exception 对象参数, 并由这个异常对象创建一个 <code>std::exception_ptr</code> 对象</li>
</ul>


<p><code>std::rethrow_exception</code></p>

<ul>
<li>接受一个 <code>std::exception_ptr</code> 参数, 重新抛出这个异常</li>
</ul>


<p>(<em>以上的一切, 很大一部分都是因为 C++ 的值传递特性引起的一系列不适!!!</em>, !!(╯&#8217; &ndash; &lsquo;)╯︵ ┻━┻)</p>

<!-- more -->


<p>示例代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;exception&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">calc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&amp;</span> <span class="n">eptr</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="n">s</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// throw out of range exception</span>
</span><span class='line'>    <span class="n">eptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_exception_ptr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">());</span> <span class="c1">// if no exception use default</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">eptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">eptr</span><span class="p">;</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">calc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">eptr</span><span class="p">)));</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">eptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">eptr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如代码所示:</p>

<p>函数 calc 在子线程中工作, 并有可能抛出异常. 主线程中, 等待子线程返回结果, 并在返回后检测是否有异常, 如果有异常, 则重新抛出异常. 主线程将上述工作都放到 try 块中, 如果有异常则打印. 这样, 子线程 calc 函数的异常就被成功的转移到了主线程中.</p>

<h2>参考</h2>

<ul>
<li>《More Effective C++》Item 13: Catch exceptions by reference</li>
<li>Cppreference.com <a href="http://en.cppreference.com/w/cpp/error">http://en.cppreference.com/w/cpp/error</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11中的原子操作 (atomic operation)]]></title>
    <link href="http://bitdewy.github.com/blog/2013/09/02/atomic-operation/"/>
    <updated>2013-09-02T23:34:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/09/02/atomic-operation</id>
    <content type="html"><![CDATA[<p>所谓的原子操作, 取的就是 “原子是最小的, 不可分割的最小个体” 的意义, 它表示在多个线程访问同一个全局资源的时候, 能够确保所有其他的线程都不在同一时间内访问相同的资源. 也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问. 这有点类似互斥对象对共享资源的访问的保护, 但是原子操作更加接近底层, 因而效率更高.</p>

<p>在以往的 C++ 标准中并没有对原子操作进行规定, 我们往往是使用汇编语言, 或者是借助第三方的线程库, 例如 intel 的 pthread 来实现. 在新标准 C++11, 引入了原子操作的概念, 并通过这个新的头文件提供了多种原子操作数据类型, 例如, atomic_bool, atomic_int 等等, 如果我们在多个线程中对这些类型的共享资源进行操作, 编译器将保证这些操作都是原子性的, 也就是说, 确保任意时刻只有一个线程对这个资源进行访问, 编译器将保证, 多个线程访问这个共享资源的正确性. 从而避免了锁的使用, 提高了效率.</p>

<p>我们还是来看一个实际的例子. 假若我们要设计一个广告点击统计程序, 在服务器程序中, 使用多个线程模拟多个用户对广告的点击:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;time.h&gt;</span>
</span><span class='line'><span class="c1">// 全局的结果数据</span>
</span><span class='line'><span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 点击函数</span>
</span><span class='line'><span class="kt">void</span> <span class="n">click</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 对全局数据进行无锁访问</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 计时开始</span>
</span><span class='line'>  <span class="n">clock_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// 创建100个线程模拟点击统计</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threads</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">click</span><span class="p">);</span>
</span><span class='line'>    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">swap</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// 计时结束</span>
</span><span class='line'>  <span class="n">clock_t</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// 输出结果</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;result:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">total</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;duration:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">finish</span> <span class="o">-</span><span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ms&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>执行结果如下:</p>

<blockquote><p>result: 955700</p>

<p>duration: 49ms</p></blockquote>

<p>从执行的结果来看, 这样的方法虽然非常快, 但是结果不正确.</p>

<p>很自然地, 我们会想到使用互斥对象来对全局共享资源的访问进行保护, 于是有了下面的实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 点击函数</span>
</span><span class='line'><span class="kt">void</span> <span class="n">click</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 对全局数据进行无锁访问</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">///</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果如下:</p>

<blockquote><p>result: 1000000</p>

<p>duration: 32350ms</p></blockquote>

<p>互斥对象的使用, 保证了同一时刻只有唯一的一个线程对这个共享进行访问, 从执行的结果来看, 互斥对象保证了结果的正确性, 但是也有非常大的性能损失, 从刚才的 49ms 变成了现在的 32350ms. 这 TMD 差距也太大了.(感觉有些异常，差距没理由这么大的, 可能是线程太多, CPU 光忙着线程切换了 = =!)</p>

<p>如果是在 C++11 之前, 我们的解决方案也就到此为止了. 但是, C++ 对性能的追求是永无止境的, 他总是想尽一切办法榨干 CPU 的性能. 在 C++11 中, 实现了原子操作的数据类型 (atomic_bool, atomic_int, atomic_long 等等), 对于这些原子数据类型的共享资源的访问, 无需借助 mutex 等锁机制, 也能够实现对共享资源的正确访问.</p>

<p>将原本的 long 类型改为 std::atomic_long 类型即可</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">//long total = 0;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">atomic_long</span> <span class="n">total</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>运行结果如下:</p>

<blockquote><p>result: 1000000</p>

<p>duration: 117ms</p></blockquote>

<p>结果正确, 时间上仅仅是不采用任何保护机制时的 3 倍左右, 和使用 mutex 做同步的版本不知差了几个数量级了.</p>

<p>原子操作的实现跟普通数据类型类似, 但是它能够在保证结果正确的前提下, 提供比 mutex 等锁机制更好的性能, 如果我们要访问的共享资源可以用原子数据类型表示, 那么在多线程程序中使用这种新的等价数据类型, 是一个不错的选择.</p>

<p>但值得注意的是, <code>std::atomic</code> 只能作用于基本类型以及 POD 类型上.</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/atomic/atomic">CppReference.com &ndash; atomic</a></li>
<li><a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2">C++ and Beyond 2012: Herb Sutter &ndash; atomic&lt;> Weapons</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步编程 async & await]]></title>
    <link href="http://bitdewy.github.com/blog/2013/08/20/async-and-await/"/>
    <updated>2013-08-20T01:17:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/08/20/async-and-await</id>
    <content type="html"><![CDATA[<h2>使用异步编程</h2>

<p>使用异步编程, 可以避免性能瓶颈和增强应用程序的总体响应能力. 但是编写异步程序在以前技术上比较复杂, 使得它们难以编写, 调试以及维护.</p>

<p>在 .NET Framework 4.5 中, 引入了简化的异步编程方式, 编译器帮我们实现了之前需要实现的异步操作, 程序员只需要关注自己的代码逻辑即可. 程序员可以更专注到业务逻辑当中.</p>

<h2>async &amp; await</h2>

<p>在 C# 中, 关键字 async 和 await 是异步编程的核心, 当使用这两个关键字的时候, 我们可以直接创建一个异步函数, 就像创建一个同步函数一样简单. 看下面的例子, 所有的东西看起来都是那么的熟悉.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Three things to note in the signature: </span>
</span><span class='line'><span class="c1">//  - The method has an async modifier.  </span>
</span><span class='line'><span class="c1">//  - The return type is Task or Task&lt;T&gt;. (See &quot;Return Types&quot; section.)</span>
</span><span class='line'><span class="c1">//    Here, it is Task&lt;int&gt; because the return statement returns an integer. </span>
</span><span class='line'><span class="c1">//  - The method name ends in &quot;Async.&quot;</span>
</span><span class='line'><span class="n">async</span> <span class="n">Task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">AccessTheWebAsync</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// You need to add a reference to System.Net.Http to declare client.</span>
</span><span class='line'>    <span class="n">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// GetStringAsync returns a Task&lt;string&gt;. That means that when you await the </span>
</span><span class='line'>    <span class="c1">// task you&#39;ll get a string (urlContents).</span>
</span><span class='line'>    <span class="n">Task</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">getStringTask</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">(</span><span class="s">&quot;http://msdn.microsoft.com&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// You can do work here that doesn&#39;t rely on the string from GetStringAsync.</span>
</span><span class='line'>    <span class="n">DoIndependentWork</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The await operator suspends AccessTheWebAsync. </span>
</span><span class='line'>    <span class="c1">//  - AccessTheWebAsync can&#39;t continue until getStringTask is complete. </span>
</span><span class='line'>    <span class="c1">//  - Meanwhile, control returns to the caller of AccessTheWebAsync. </span>
</span><span class='line'>    <span class="c1">//  - Control resumes here when getStringTask is complete.  </span>
</span><span class='line'>    <span class="c1">//  - The await operator then retrieves the string result from getStringTask. </span>
</span><span class='line'>    <span class="n">string</span> <span class="n">urlContents</span> <span class="o">=</span> <span class="n">await</span> <span class="n">getStringTask</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The return statement specifies an integer result. </span>
</span><span class='line'>    <span class="c1">// Any methods that are awaiting AccessTheWebAsync retrieve the length value. </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">urlContents</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h2>async 方法中到底发生了什么？</h2>

<p>在异步编程中, 最重要的需要了解的事情是, 方法与方法之间的执行流程是什么. 下面的图可以帮助我们理解执行流程.</p>

<p><img src="https://qhphgq.bay.livefilestore.com/y2pPcdpEqnMPWdvKOr5yjswLE7F201mPiHRsjrk0PteSCWt9jdSWQxA3Tgkas4qOECf2vishbMkp4GnpFvE_ZQJcMwRppgT7hM0UrQxVevorwg/async.png" alt="" /></p>

<p>图上的标记对应以下步骤</p>

<ol>
<li>事件处理程序调用并等待 AccessTheWebAsync 异步方法.</li>
<li>AccessTheWebAsync 创建 HttpClient 实例并调用GetStringAsync 异步方法下载网页内容, 作为字符串.</li>
<li>GetStringAsync 会造成挂起, 这时会发生一些事情. 可能它必须等待网页下载完成或者其他一些会阻塞的事情. 为了避免阻塞, GetStringAsync 会交出控制权给他的调用者, AccessTheWebAsync. AccessTheWebAsync 是返回一个模板参数是 string 的 Task 对象, 赋值给 getStringTask 变量. task 不会因为 GetStringAsync 的调用而阻塞当前进程, 而是当任务实际执行完成时, 再提交.</li>
<li>由于 getStringTask 此时还没有 await, AccessTheWebAsync 可以继续执行一些不依赖 GetStringAsync 结果的一些操作. 这些工作在一个同步的叫做 DoIndependentWork 函数中执行.</li>
<li>DoIndependentWork 是一个同步函数, 当它的工作做完之后会将结果返回给调用者.</li>
<li><p>AccessTheWebAsync 做完了不依赖 getStringTask 的所有事情, AccessTheWekAsync 接下来需要计算 getStringTask 的结果, 但是此时函数还没有返回. 因此, AccessTheWebAsync 使用了 await 将当前的操作挂起, 然后将控制权移交到 AccessTheWebAsync 的调用者. AccessTheWebAsync 返回一个 task<int> 给调用者. 这个 task 给了外部一个承诺 (promise) 当计算完成时会返回给调用者一个整数, 这个整数就是下载的数据量的长度. <em>注意: 如果 GetStringAsync (以及 getStringTask) 在 AccessTheWebAsync await 之前就完成了, 那么控制权会仍然在 AccessTheWebAsync 中. 如果在不需要 await 时, 还继续进行代价很高的控制权转移的话, 是严重的浪费.</em> 在调用者中 (本例的 event handler), 这个过程会重复多次. 调用者可能会在 await 之前, 做一些其他的不依赖 AccessTheWebAsync 的操作, 或者直接 await. 当 event handler 执行到 await 语句时, 应用程序正在等待 AccessTheWebAsync, 同时 AccessTheWebAsync 正在等待 GetStringAsync.</p></li>
<li><p>GetStringAsync 完成工作并返回了字符串结果. 这个字符串不是直接由 GetStringAsync 调用返回的. (在第 3 步的时候我们就已经返回了一个 task). 取而代之, 这个字符串是存储在已完成的 task 中的, getStringTask. await 会得到 getStringTask 的结果. 赋值语句会将得到的结果赋值给 urlContents.</p></li>
<li>当 AccessTheWebSync 得到了结果之后, 他就可以计算字符串的长度了. 然后 AccessTheWebAsync 的任务就全部完成了. 正在等待的 event handler 就可以恢复工作了.</li>
</ol>


<h2>C++ 中的 async 以及 await</h2>

<p>上面是一个 C# 的例子, C++11 中虽然对线程的支持作了相当多的工作, 但是异步编程方面还没有引入与 C# 中的 async 以及 await 类似的东西. 但标准委员会正在做这方面的工作, 提案名字叫做 Resumable Functions (n3650), 虽然 C++14 中不会引入这个特性 (这个特性应该是 C++1y 中的特性 (y应该等于7)), 但微软会很快的将该特性的实现引入到新版的 visual studio 中.</p>

<p>一个例子感受一下没有 async 以及 await 时我们是如何做异步编程的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'>   <span class="p">.</span><span class="n">then</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">fi</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span>
</span><span class='line'>         <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">task</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span>
</span><span class='line'>      <span class="p">[</span><span class="o">=</span><span class="p">]{</span>
</span><span class='line'>         <span class="n">fi</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
</span><span class='line'>         <span class="p">.</span><span class="n">then</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span> <span class="n">chunk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>               <span class="o">*</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
</span><span class='line'>               <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)();</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
</span><span class='line'>         <span class="p">});</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)();</span>
</span><span class='line'>   <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看看上面的一堆代码，WTF，谁能快速的搞明白？？？？？</p>

<p>再看看下面清爽的代码吧…</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span> <span class="p">)</span> <span class="n">__async</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">__await</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">,</span> <span class="n">chunk</span><span class="p">;</span>
</span><span class='line'>   <span class="k">while</span><span class="p">((</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">__await</span> <span class="n">fi</span><span class="p">.</span><span class="n">read</span><span class="p">()).</span><span class="n">size</span><span class="p">())</span>
</span><span class='line'>      <span class="n">ret</span> <span class="o">+=</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是迫不及待的想要尝试了呢？</p>

<h2>参考</h2>

<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx">Asynchronous Programming with Async and Await (C# and Visual Basic)</a></li>
<li><a href="http://channel9.msdn.com/Events/Build/2013/2-306">The future of C++</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Attorney Client]]></title>
    <link href="http://bitdewy.github.com/blog/2013/08/14/attorney-client/"/>
    <updated>2013-08-14T00:45:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/08/14/attorney-client</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>控制访问一个类内部实现细节的粒度.</p>

<h2>动机</h2>

<p>C++ 的友元申明可以完全访问一个类的内部细节. 所以, 唔, 友元太邪恶了, 它破坏了精心的封装. C++ 中不提供选择性的授权访问类私有成员子集的方式. 在 C++ 中要么使用友元, 可以访问一个类的全部细节, 要么不用友元, 只能访问公有接口.</p>

<p>看下面的例子, 下面的类 Foo 中声明了 Bar 友元. 因此 Bar 类可以访问 Foo 的全部私有成员. 这不可取, 因为它增加了耦合. Bar 类会变得没有 Foo 类就无法单独使用.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">B</span><span class="p">(</span><span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">C</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="c1">// This class needs access to Foo::A and Foo::B only.</span>
</span><span class='line'><span class="c1">// C++ friendship rules, however, give access to all the private members of Foo.</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>提供选择性访问成员子集的功能, 是可取的. 这样的话, 剩余的私有成员如果需要的话, 可以更改接口. 它有助于减少两个类之间的耦合. Attorney-Client 可以精确控制它的友元能够访问的成员的数量.</p>

<!-- more -->


<h2>解决方案 &amp; 示例代码</h2>

<p>Attorney-Client 通过增加一个间接层来解决上面描述的问题. 想要访问一个类的实现细节, 我们需要一个 Attorney 类, 一个真正的 C++ 友元. Attorney 类是精心设计的一个代理类. 和一般的代理类不同, Attorney 类只负责复制 Foo 类的内部实现的接口的子集. 为了更好的描述, 我们把 Foo 类重新命名为 Client, Client 仅仅想通过 Attorney 提供 Client::A 以及 Client::B 的访问权限.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Client</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">B</span><span class="p">(</span><span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">C</span><span class="p">(</span><span class="kt">double</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Attorney</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Attorney</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">void</span> <span class="n">callA</span><span class="p">(</span><span class="n">Client</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span><span class="p">.</span><span class="n">A</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">void</span> <span class="n">callB</span><span class="p">(</span><span class="n">Client</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span><span class="p">.</span><span class="n">B</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="c1">// Bar now has access to only Client::A and Client::B through the Attorney.</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Attorney 类限制仅能访问部分函数, Attorney 类中仅函数静态内联成员函数, 每个都需要一个 Client 类实例的引用, 然后将调用转到这个实例上. 他的实现是完全私有的. 这可以禁止其他类去访问 Client 内部. Attorney 可以决定哪些类, 成员函数, 以及自由函数可以访问 Client. 它只需要将能访问这些细节的东西声明为友元即可. 如果没有 Attorney 类, Client 也需要子集来做.</p>

<p>它也可以有多个 attorney 类来提供访问 Client 的不同细节. 比如 AttorneyC 类只提供 Client::C 的访问.</p>

<p>在下面的例子中, Attorney-client 用在了 类 Base 和 main 函数中间. Derived::Func 函数通过多态性得以访问. 不过如果想要再访问 Derived 类的一些细节的时候, 那就需要再次使用 Attorney 了.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;cstdio&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Attorney</span><span class="p">;</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Derived::Func</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="c1">// This is called even though main is not a friend of Derived.</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="o">~</span><span class="n">Derived</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Attorney</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">void</span> <span class="n">callFunc</span><span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">Func</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">friend</span> <span class="kt">int</span> <span class="n">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Attorney</span><span class="o">::</span><span class="n">callFunc</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>已知的应用</h2>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_50_0/libs/iterator/doc/iterator_facade.html#iterator-core-access">Boost.Iterators library</a></li>
<li><a href="http://www.boost.org/doc/libs/1_50_0/libs/serialization/doc/serialization.html#member">Boost.Serialization: class boost::serialization::access</a></li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="http://drdobbs.com/184402053">Friendship and the Attorney-Client Idiom (Dr. Dobb&rsquo;s Journal)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IO 模型]]></title>
    <link href="http://bitdewy.github.com/blog/2013/08/05/io-model/"/>
    <updated>2013-08-05T15:24:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/08/05/io-model</id>
    <content type="html"><![CDATA[<h2>阻塞 I/O</h2>

<p>考虑到应用进程与内核的区别, 我们将函数 recvfrom 视为系统调用. 不管函数 recvfrom 如何实现, 一般都有一个从应用进程中运行到内核中运行的切换, 一段时间后再跟着一个返回到应用进程的切换.</p>

<p><img src="http://bitdewy.github.io/static/2013-08-05-io-model/1.svg" alt="" /></p>

<p>如图, 进程调用 recvfrom, 此时系统调用直到数据报到达且拷贝到应用缓冲区, 或者出错才返回. 我们所说的进程阻塞的整段时间是指从调用 recvfrom 开始到它返回的这段时间, 当进程返回成功指示时, 应用进程开始处理数据报.</p>

<!-- more -->


<h2>非阻塞 I/O</h2>

<p>当我们把一个套接字设置成非阻塞方式时, 即通知内核: 当请求的 I/O 操作必须让进程睡眠, 不能完成, 这是不要让进程睡眠, 而应返回一个错误. 如下图所示, 前三次调用 recvfrom 时都没有数据返回, 因此内核会立刻返回一个 EWOULDBLOCK 错误. 第四次调用 recvfrom 时, 数据报已准备好, 被拷贝到应用缓冲区, recvfrom 返回成功指示, 接着我们就可以处理数据了.</p>

<p><img src="http://bitdewy.github.io/static/2013-08-05-io-model/2.svg" alt="" /></p>

<p>当一个应用进程像这个样对一个非阻塞描述符循环调用 recvfrom 时, 我们称此过程为轮询 (polling). 应用进程连续不断的查询内核, 看看某个操作是否准备好, 这对 CPU 时间来说是极大的浪费. 这种模型只是偶尔才遇到, 一般是在专门提供某种苟能的系统中才有.</p>

<h2>I/O 复用</h2>

<p>假设一个 TCP 客户端同时在处理两个输入: 标准书输入和 TCP 套接字. 我们遇到了这么一个问题, 客户端正阻塞在标准输入上, 等待用户输入, 同时服务器进程又被杀死. 服务器 TCP 正确地给客户发了一个 FIN, 但客户端进程正阻塞于从标准输入读入. 它只能等待从标准输入读入完成之后才能从套接读数据时发现文件结束符 (这可能已经过了非常长的时间). 我们需要这样的功能: 如果一个或多个 I/O 条件满足 (比如, 输入已准备好被读, 或者描述符可以接受更多的输出) 时, 我们会得到通知, 这个能力被称为 I/O 复用.</p>

<p>I/O 复用的典型应用场景:
1. 当客户端处理多个描述符时 (一般是交互式输入和网络套接字), 必须使用 I/O 复用.
2. 一个客户端处理多个套接字是可能的, 但很少出现.
3. 如果一个 TCP 服务器纪要处理监听套接字, 又要处理已连接的套接字, 一般也要用到 I/O 复用.
4. 如果一个服务器既要处理 TCP 又要处理 UDP, 一般也要使用 I/O 复用.
5. 如果一个服务器要处理多个服务, 或者多个协议, 一般要使用 I/O 复用.</p>

<p>I/O 复用并非只限于网络编程, 许多其他的应用程序也需要使用这项技术.</p>

<p>有了 I/O 复用, 我们就可以调用 select 或 poll, 在这两个系统调用中的某一个上阻塞, 而不是阻塞于真正的 I/O 系统调用. 如下图, 我们阻塞于 select 调用, 等待数据报套接字可读, 当 select 返回套接字可读条件时, 我们调用 recvfrom 将数据拷贝到应用缓冲区中.</p>

<p><img src="http://bitdewy.github.io/static/2013-08-05-io-model/3.svg" alt="" /></p>

<p>将上图与阻塞 I/O 模型的图进行比较, 似乎没有显示出优越性, 并且由于使用了系统调用 select, 要求两次系统调用而不是一次, 好像变得还有点差. 但是, 使用 select 的好处在于我们可以等待多个描述符准备好.</p>

<h2>信号驱动 I/O (SIGIO)</h2>

<p>我们也可以用信号, 让内核在描述符准备好时用信号 SIGIO 通知我们, 我们将此方法成为信号驱动 I/O, 如下图.</p>

<p><img src="http://bitdewy.github.io/static/2013-08-05-io-model/4.svg" alt="" /></p>

<p>首先我们允许套接字进行信号驱动I/O, 并通过系统调用 sigaction 安装一个信号处理程序. 此系统调用立即返回, 进程继续工作, 它是非阻塞的. 当数据报准备好被读时, 就为该进程生成一个 SIGIO 信号. 我们随即可以在信号处理程序中调用 recvfrom 来读数据报, 并通知主循环数据已经准备好被处理, 也可以通知主循环来让它读数据报.</p>

<p>无论我们如何处理 SIGIO 信号, 这种模型的好处是当等待数据报到达时, 可以不阻塞. 主循环可以继续执行, 只是等待信号处理程序的通知, 或者数据已准备好被处理, 或者数据报已准备好被读.</p>

<h2>异步 I/O (Posix.1 的 aio_* 系类函数)</h2>

<p>异步 I/O 是 posix.1 的1993版本中的新内容 (“实时”扩展). 我们让内核启动操作, 并在整个操作完成后 (包括将数据从内核拷贝到我们自己的缓冲区) 通知我们. 这种模型与前一种型号驱动模型的主要区别在于: 信号驱动 I/O 是由内核通知我们何时可以启动一个 I/O 操作, 而异步 I/O 模型是由内核通知我们 I/O 操作何时完成.</p>

<p><img src="http://bitdewy.github.io/static/2013-08-05-io-model/5.svg" alt="" /></p>

<p>我们调用函数 aio_read (posix 异步 I/O函数以 aio<em> 或 lion</em> 开头), 给内核传递描述符, 缓冲区指针, 缓冲区大小, 文件偏移, 并告诉内核当整个操作完成时如何通知我们. 此系统调用立即返回, 我们的进程不阻塞于等待 I/O 操作的完成. 在这个例子中, 我们假设要求内核在操作完成时生成一个信号, 此信号直到数据已拷贝到应用缓冲区才产生, 这一点是与信号驱动 I/O 模型不同的.</p>

<h2>同步 I/O 与异步 I/O</h2>

<p>posix.1 定义的两个术语如下:
1. 同步 I/O 操作引起请求进程阻塞, 直到 I/O 操作完成.
2. 异步 I/O 操作不引起请求进程阻塞.</p>

<p>根据上述定义, 我们的前四个模型——阻塞 I/O 模型, 非阻塞 I/O 模型, I/O 复用模型和信号驱动 I/O 模型都是同步 I/O 模型, 因为真正的 I/O 操作 (recvfrom) 阻塞进程, 只有异步 I/O 模型与 posix.1 中定义的异步 I/O 概念相符.</p>

<h2>各种 I/O 模型的比较</h2>

<p>下面是五种不同的 I/O 模型的比较, 可以看出, 前四种模型的主要区别都在于第一阶段, 他们的第二阶段基本相同, 在数据从内核拷贝到调用者缓冲区时, 进程阻塞于 recvfrom 调用. 然后, 异步 I/O 模型处理的两个阶段都不同于前四个模型.</p>

<p><img src="http://bitdewy.github.io/static/2013-08-05-io-model/6.svg" alt="" /></p>

<p>在 windows 系统中, select 与 unix 中的类似, 属于 I/O 复用, WSAAsyncSelect 与 WSAEventSelect 和信号驱动模型类似, 而 重叠 I/O, 以及建立在重叠 I/O 之上的完成端口都属于异步 I/O 模型.</p>

<p>linux 上的 epoll 以及 freebsd 的 kqueue 理论上还是属于 I/O 复用模型, 但它们没有轮询, 而是使用了 callback 机制, 从而使得效率大大的提升. Linux Kernel 2.6 提供了对 AIO 的有限支持 —— 仅支持文件系统. libc 也能通过来线程来模拟 socket 的 AIO, 不过这对性能没意义. 总的来说 Linux 的 aio 还不成熟.</p>

<h2>参考</h2>

<ul>
<li>《Unix 网络编程》</li>
<li>C10K问题 <a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></li>
</ul>


<p><del><em>文中使用的图做完之后就后悔了… 先这样吧, 下次一定要用矢量图, SVG 什么的… 现在完全看不清啊,还有不和谐的纯白底色, 魂淡…</em> (╯‵□′)╯︵┻━┻</del></p>

<p>实在是无法忍受看不清的图片, 全都换成 svg 了, 这下整个人都舒服了. O(∩_∩)O 哈!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型选择]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/30/type-selection/"/>
    <updated>2013-07-30T18:26:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/30/type-selection</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>在编译期间, 根据一些条件, 决定类型.</p>

<h2>动机</h2>

<p>在编译期根据一些信息来做出决议是元编程的一个强大工具. 其中一种就是在编译期决定类型, 比如根据一些列的条件最后决定具体的类型.</p>

<p>例如, 考虑一个 Queue 的实现, 这个模板类有一个静态数组, 模板参数作为这个 Queue 类型的最大容量. Queue 类同时需要存储当前元素的个数, 从 0 开始. 可能的优化方案是用不同的类型, 来存储 size 值. 比如当 Queue 的最大容量小于 256 时, 存储容量的类型是 unsigned char, 当容量小于 65536 时, 存储容量的类型是 unsigned short, 更大的容量时使用 unsigned int 类型. 类型选择可以在这个时候发挥作用.</p>

<h2>解决方案以及代码示例</h2>

<p>一个简单的解决方案是使用 IF 模板. IF 模板有三个模板参数, 第一个参数是编译期的 bool 表达式. 如果表达式为 true 那么第二个模板参数类型将被选中, 否则会选中第三个模板参数. IF 模板由下面的一个模板和一个模板偏特化构成.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="k">class</span> <span class="nc">L</span><span class="p">,</span> <span class="k">class</span> <span class="nc">R</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">IF</span>  <span class="c1">// primary template</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">R</span> <span class="n">type</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">L</span><span class="p">,</span> <span class="k">class</span> <span class="nc">R</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">IF</span><span class="o">&lt;</span><span class="kc">true</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="c1">// partial specialization</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">L</span> <span class="n">type</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">IF</span><span class="o">&lt;</span><span class="kc">false</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// is equivalent to long i;</span>
</span><span class='line'><span class="n">IF</span><span class="o">&lt;</span><span class="kc">true</span><span class="p">,</span>  <span class="kt">int</span><span class="p">,</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// is equivalent to int i;</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>下面就是使用类型选择实现的 Queue 类:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">CAPACITY</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Queue</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">T</span> <span class="n">array</span><span class="p">[</span><span class="n">CAPACITY</span><span class="p">];</span>
</span><span class='line'>  <span class="k">typename</span> <span class="n">IF</span><span class="o">&lt;</span><span class="p">(</span><span class="n">CAPACITY</span> <span class="o">&lt;=</span> <span class="mi">256</span><span class="p">),</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span>
</span><span class='line'>      <span class="k">typename</span> <span class="n">IF</span><span class="o">&lt;</span><span class="p">(</span><span class="n">CAPACITY</span> <span class="o">&lt;=</span> <span class="mi">65536</span><span class="p">),</span>
</span><span class='line'>                  <span class="kt">unsigned</span> <span class="kt">short</span><span class="p">,</span>
</span><span class='line'>                  <span class="kt">unsigned</span> <span class="kt">int</span>
</span><span class='line'>                 <span class="o">&gt;::</span><span class="n">type</span>
</span><span class='line'>    <span class="o">&gt;::</span><span class="n">type</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>模板类 Queue 声明了一个类型为 T 的数组, 数据成员 size 的类型由两个 IF 模板的结果来决定. 注意, 这些比较不是在运行时而是在编译期.</p>

<h2>已知的应用</h2>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_54_0/libs/mpl/doc/index.html">Boost.MPL Library</a></li>
</ul>


<h2>参考</h2>

<ul>
<li>《Modern C++ design》(2.6 型别选择 (type selection)) Andrei Alexandrescu</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 condition variable 实现生产者 消费者模型]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/22/resolve-producer-consumer-problem-with-cond/"/>
    <updated>2013-07-22T00:05:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/22/resolve-producer-consumer-problem-with-cond</id>
    <content type="html"><![CDATA[<h2>什么是生产者-消费者问题?</h2>

<p>生产者消费者问题 (英语: Producer-consumer problem), 也称有限缓冲问题 (英语: Bounded-buffer problem), 是一个多线程同步问题的经典案例. 该问题描述了两个共享固定大小缓冲区的线程 —— 即所谓的 “生产者” 和 “消费者” —— 在实际运行时会发生的问题. 生产者的主要作用是生成一定量的数据放到缓冲区中, 然后重复此过程. 与此同时, 消费者也在缓冲区消耗这些数据. 该问题的关键就是要保证生产者不会在缓冲区满时加入数据, 消费者也不会在缓冲区中空时消耗数据.</p>

<p>要解决该问题, 就必须让生产者在缓冲区满时休眠 (要么干脆就放弃数据), 等到下次消费者消耗缓冲区中的数据的时候, 生产者才能被唤醒, 开始往缓冲区添加数据. 同样, 也可以让消费者在缓冲区空时进入休眠, 等到生产者往缓冲区添加数据之后, 再唤醒消费者. 通常采用进程间通信的方法解决该问题, 常用的方法有信号量等. 如果解决方法不够完善, 则容易出现死锁的情况. 出现死锁时, 两个线程都会陷入休眠, 等待对方唤醒自己. 该问题也能被推广到多个生产者和消费者的情形.</p>

<!-- more -->


<h2>使用 condition variable 实现生产者-消费者模型</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;condition_variable&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;mutex&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sstream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">buffer_mutex</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">buffer_not_empty</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">buffer_not_full</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">kBufferMaxSize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">();</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span> <span class="n">s</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">send</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">buffer_mutex</span><span class="p">);</span>
</span><span class='line'>  <span class="n">buffer_not_full</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]{</span> <span class="k">return</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">kBufferMaxSize</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'>  <span class="n">buffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;produce: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">buffer_not_empty</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">receive</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">buffer_mutex</span><span class="p">);</span>
</span><span class='line'>  <span class="n">buffer_not_empty</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]{</span> <span class="k">return</span> <span class="o">!</span><span class="n">buffer</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span><span class='line'>  <span class="n">buffer</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;consume: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">buffer_not_full</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">future_producer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">send</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">future_consumer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">receive</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="n">future_producer</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="n">future_consumer</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">wikipedia: Producer–consumer problem</a></li>
<li><a href="http://en.cppreference.com/w/cpp/thread/condition_variable">cppreference.com: std::condition_variable</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visitor 模式与 boost.variant.static_visitor]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/15/static-visitor/"/>
    <updated>2013-07-15T00:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/15/static-visitor</id>
    <content type="html"><![CDATA[<h2>visitor 模式</h2>

<p>visitor 模式是一种将算法与对象结构分离的软件设计模式.</p>

<p>这个模式的基本想法如下: 首先我们拥有一个由许多对象构成的对象结构, 这些对象的类都拥有一个 accept 方法用来接受访问者对象; 访问者是一个接口, 它拥有一个 visit 方法, 这个方法对访问到的对象结构中不同类型的元素作出不同的反应; 在对象结构的一次访问过程中, 我们遍历整个对象结构, 对每一个元素都实施 accept 方法, 在每一个元素的 accept 方法中回调访问者的 visit 方法, 从而使访问者得以处理对象结构的每一个元素. 我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作.</p>

<p>访问者模式使得我们可以在传统的单分派语言 (如 Smalltalk, Java 和 C++) 中模拟双分派技术.</p>

<!-- more -->


<h2>传统的 visitor 模式实现</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;memory&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;tuple&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// original visitor pattern</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Wheel</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Engine</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Body</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Car</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">CarElementVisitor</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">CarElement</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Wheel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElement</span><span class="p">,</span>
</span><span class='line'>              <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElement</span><span class="p">,</span>
</span><span class='line'>               <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Body</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElement</span><span class="p">,</span>
</span><span class='line'>             <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElement</span><span class="p">,</span>
</span><span class='line'>            <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Elements</span><span class="p">;</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Car</span><span class="p">()</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">elements_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElementVisitor</span><span class="o">&gt;&amp;</span> <span class="n">visitor</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elements_</span><span class="p">));</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elements_</span><span class="p">));</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elements_</span><span class="p">));</span>
</span><span class='line'>    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Elements</span> <span class="n">elements_</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PrintVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElementVisitor</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintVisitor::visit(std::shared_ptr&lt;Wheel&gt; wheel) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintVisitor::visit(std::shared_ptr&lt;Engine&gt; engine) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintVisitor::visit(std::shared_ptr&lt;Body&gt; body) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintVisitor::visit(std::shared_ptr&lt;Car&gt; car) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">OtherVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarElementVisitor</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="o">&gt;&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherVisitor::visit(std::shared_ptr&lt;Wheel&gt; wheel) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherVisitor::visit(std::shared_ptr&lt;Engine&gt; engine) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherVisitor::visit(std::shared_ptr&lt;Body&gt; body) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherVisitor::visit(std::shared_ptr&lt;Car&gt; car) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CarElement</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'>  <span class="n">car</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">PrintVisitor</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'>  <span class="n">car</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">OtherVisitor</span><span class="o">&gt;</span><span class="p">());</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>boost.variant.static_visitor 的实现</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/variant.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/variant/static_visitor.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/variant/apply_visitor.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Wheel</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Engine</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Body</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Car</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// boost static visitor</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Wheel</span><span class="p">,</span> <span class="n">Engine</span><span class="p">,</span> <span class="n">Body</span><span class="p">,</span> <span class="n">Car</span><span class="o">&gt;</span> <span class="n">CarElement</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PrintVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">boost</span><span class="o">::</span><span class="n">static_visitor</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Wheel</span><span class="o">&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintStaticVisitor::operator()(const Wheel&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Engine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintStaticVisitor::operator()(const Engine&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Body</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintStaticVisitor::operator()(const Body&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Car</span><span class="o">&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// bla bla bla</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void PrintStaticVisitor::operator()(const Car&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">OtherVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">boost</span><span class="o">::</span><span class="n">static_visitor</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Wheel</span><span class="o">&amp;</span> <span class="n">wheel</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherStaticVisitor::operator()(const Wheel&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Engine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherStaticVisitor::operator()(const Engine&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Body</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherStaticVisitor::operator()(const Body&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Car</span><span class="o">&amp;</span> <span class="n">car</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// bla bla bla</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;void OtherStaticVisitor::operator()(const Car&amp;) const&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CarElement</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Car</span><span class="p">();</span>
</span><span class='line'>  <span class="n">PrintVisitor</span> <span class="n">print_visitor</span><span class="p">;</span>
</span><span class='line'>  <span class="n">OtherVisitor</span> <span class="n">other_visitor</span><span class="p">;</span>
</span><span class='line'> <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">print_visitor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'>  <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">other_visitor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_54_0/doc/html/variant/reference.html#header.boost.variant.static_visitor_hpp">boost.variant.static_visitor</a></li>
<li><a href="http://en.wikipedia.org/wiki/Visitor_pattern">维基百科: visitor 模式</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 完美转发]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/08/cpp11-perfect-forward/"/>
    <updated>2013-07-08T22:09:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/08/cpp11-perfect-forward</id>
    <content type="html"><![CDATA[<h2>动机</h2>

<p>在泛型编码中经常出现的一个问题是: 如何将一组参数原封不动的转发给另一个函数? 这里的原封不动指的是: 保持参数的左值 (右值), const (non-const) 属性不变.</p>

<h2>C++03 中参数转发存在的问题</h2>

<p>下面来看一个例子, 对于表达式 <code>E(a, b, …, c)</code> 我们希望它与 <code>f(a, b, …, c)</code> 完全等价. 在 C++03 中这是不可能的. 下面是几种设计方案, 但所有的都会在某些条件下失效.</p>

<p>最简单的, 使用引用参数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">E</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很遗憾, 函数 f 无法处理临时变量, 例如 <code>f(1, 2, 3)</code>; 会编译失败. 这三个参数都无法绑定到引用.</p>

<p>再来看看 const 引用:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">E</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>这解决了上面的问题, 但是又引入了新的问题, 现在我们无法让 E 接收 non-const 参数了, 下面的代码也会产生一个编译失败.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">E</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// oops! E cannot modify these</span>
</span></code></pre></td></tr></table></div></figure>


<p>嗯, 再来个尝试, 解决上面的问题, 我们接收 const 引用, 然后使用 const_cast 来去掉 const 属性.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">E</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后来终极解决方案吧, 利用重载, 根据重载决议, 我们可以使用 const 引用和 non-const 引用来进行参数重载, 对于上面的例子, 我们的实现如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>n 个参数的函数, 就需要 2<sup>n</sup> 个重载版本, 这太恐怖了, 我们非常需要自动完成这些工作. 这个问题在 C++11 中的到了完美的解决.</p>

<h2>完美转发</h2>

<p>C++11 新标准给了我们修复这个问题的机会 (这里有一个破坏性的解决方案, 虽然解决了完美转发的问题, 但是破坏了现有的类型推导规则<a href="http://stackoverflow.com/questions/3591832/perfect-forwarding-in-c03/3591909#3591909">《Perfect Forwarding in C++03》</a>).</p>

<p>C++11 中引入了新的概念, 右值引用. 我们可以在不破坏现有代码的情况下, 定义右值引用的推导规则, 来解决完美转发的问题.</p>

<p>看下面的表格, (TR 表示 T 引用类型)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">TR</span>   <span class="n">R</span>
</span><span class='line'>
</span><span class='line'><span class="n">T</span><span class="o">&amp;</span>   <span class="o">&amp;</span>  <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;</span>  <span class="c1">// lvalue reference to cv TR -&gt; lvalue reference to T</span>
</span><span class='line'><span class="n">T</span><span class="o">&amp;</span>   <span class="o">&amp;&amp;</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;</span>  <span class="c1">// rvalue reference to cv TR -&gt; TR (lvalue reference to T)</span>
</span><span class='line'><span class="n">T</span><span class="o">&amp;&amp;</span>  <span class="o">&amp;</span>  <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;</span>  <span class="c1">// lvalue reference to cv TR -&gt; lvalue reference to T</span>
</span><span class='line'><span class="n">T</span><span class="o">&amp;&amp;</span>  <span class="o">&amp;&amp;</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="c1">// rvalue reference to cv TR -&gt; TR (rvalue reference to T)</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后, 模板参数推导时, 如果参数是左值, 那么就推导为左值引用. 否则使用正常的类型推导. 这里又引入了一个新的概念, “全局引用” (universal references), 具体细节详见: <a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11">C++ and Beyond 2012: Scott Meyers &ndash; Universal References in C++11</a></p>

<p>为什么这样就能解决问题? 因为我们保持了参数的类型: 如果参数是一个左值, 我们得到的是左值引用的参数, 否则我们得到的是右值引用类型的参数, 看下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">deduce</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="n">deduce</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// deduce&lt;int&amp;&gt;(int&amp; &amp;&amp;) -&gt; deduce&lt;int&amp;&gt;(int&amp;)</span>
</span><span class='line'><span class="n">deduce</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// deduce&lt;int&gt;(int&amp;&amp;)</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后就是要做“转发”了. 需要注意的是, 在函数内参数类型是一个左值类型.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">deduce</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">){</span>
</span><span class='line'>    <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// fine, foo can refer to x</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">deduce</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// okay, foo operates on x which has a value of 1</span>
</span></code></pre></td></tr></table></div></figure>


<p>这还不足够. foo 需要拿到和 deduce 一样的参数类型, 解决方案如下.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这行代码做了什么呢? 我们在 deduce 函数中, 且我们接收了一个左值类型的参数, 这意味着 T 是 A&amp; 类型, 经过静态类型转换 A&amp; &amp;&amp; 仍然是 A&amp; 类型. 因此, 加入 x 以及是一个 A&amp; 类型, 那么我们什么也没有做, 它仍然是一个左值引用类型.</p>

<p>当我们接收的是一个右值, T 就是 A 类型, 因此我们转换后的类型为 A&amp;&amp;. 转换后的类型是一个右值表达式, 这样就不会再作为左值参数了. 我们保持住了参数的类型. 将上面的组合到一起, 我们就得到了“完美转发”:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">E</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当 f 接收到一个左值, 那么 E 也接收一个左值, 当 f 接收的是一个右值, 那么 E 接受到的也是一个右值, 完美了.</p>

<p>当然, 上面的代码是有一点丑陋. <code>static_cast&lt;T&amp;&amp;&gt;</code> 古怪而且不容易记住. 标准库中提供了一个工具函数, 叫做 forward, 它所做的事情与类型转换完全一致.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'><span class="c1">// is the same as</span>
</span><span class='line'><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">C++标准提案(N1385)：The Forwarding Problem: Arguments</a></li>
<li><a href="http://blog.csdn.net/pongba/article/details/1697636">《C++0x漫谈》系列之：右值引用(或“move语意与完美转发”)(下)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 右值引用]]></title>
    <link href="http://bitdewy.github.com/blog/2013/07/02/cpp11-rvalue-ref/"/>
    <updated>2013-07-02T22:49:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/07/02/cpp11-rvalue-ref</id>
    <content type="html"><![CDATA[<h2>什么是右值引用?</h2>

<p>在一般情况下, C++ 不把表达式的左值属性作为类型的一部分, 比如下面的变量声明:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么变量 n 的类型是 int. 另外常量 3 也是 int 类型. 虽然他们有相同的类型, 不过这并不是说 n 和 3 总是可以互换的. 比如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// OK</span>
</span><span class='line'><span class="kt">int</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// Error</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是因为标准中规定, 当定义一个引用时, 我们必须使用一个左值来初始化它. 在上面的代码中, n 是一个左值, 而 3 不是. 所以我们不能用 3 来初始化 s. 这个规定可以帮助编译器来捕捉错误, 比如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// equals std::cin.operator&gt;&gt;(3);</span>
</span></code></pre></td></tr></table></div></figure>


<p>简单的说, 上面的代码调用了 std::cin 的名为 operator>> 的成员函数, 并使用 3 作为参数. operator>> 是重载函数, 虽然它有接受一个 int&amp; 参数的重载版本, 但是没有能接受一个简单的 int 常量, 或者 int 右值作为参数的重载. 因此, 编译器会检查出我们无法使用 int 的右值作为参数来调用 operator>>.</p>

<!-- more -->


<p>C++11 扩展了引用的概念, 增加了右值引用. 右值引用也是一个引用, 但与普通的引用不同, 它只能绑定到右值上. 下面是一个右值引用的声明:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个普通的引用只能绑定左值, 一个右值引用只能绑定到右值, 也就是说如果我们写了下面的代码, 编译器会报一个错误.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">// Error: n is an lvalue</span>
</span></code></pre></td></tr></table></div></figure>


<p>右值引用是一个有趣的组合, 虽然你只能绑定右值到右值引用, 但是你使用时它却是一个左值.</p>

<p>例如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="o">++</span><span class="n">t</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通常情况下, 程序员不能修改右值. 但是通过右值引用, 获得了左值, 这样我们就能修改它的值了. 另外, 右值在通过右值引用绑定之后, 这个右值就不在可访问, 它使用了转移语义来代替拷贝操作.</p>

<p>定义一个接收右值引用参数的函数, 那么函数就会使用转移语义来替代拷贝操作. 但是这样会禁止接收左值参数.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</span><span class='line'><span class="n">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>        <span class="c1">// OK;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="n">foo</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>         <span class="c1">// Error: n is an lvalue</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们当然可以定义一个左值的版本来解决上面的问题:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'><span class="n">bar</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>             <span class="c1">// calls bar(int&amp;&amp;)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="n">bar</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>               <span class="c1">// calls bar(const int&amp;)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个技术有个值得记住的地方是, 通过 const 引用和右值引用的两个重载版本, 你告诉了编译器哪个修改参数是安全的, 哪个不是. 此外, 编译器在编译期就决定了使用哪个, 从而避免了运行时的开销.</p>

<h2>Move 语义</h2>

<p>右值引用的引入, 从语言层面提升了性能, 提高了内存与时间上的效率.</p>

<p>在 C++03 及之前的标准中, 临时对象 (称为右值 &ldquo;R-values&rdquo;, 位于赋值运算符之右) 无法被改变, 在 C 中亦同 (且被视为无法和 const T&amp; 做出区分). 虽然在某些情况下临时对象的确会被改变, 甚至也被视为是一个有用的漏洞.</p>

<p>C++11 增加一个新的非常数引用 (reference) 类型, 称作右值引用 (R-value reference), 标记为 <code>T&amp;&amp;</code>. 右值引用所引用的临时对象可以在该临时对象被初始化之后做修改, 这是为了允许 move 语义.</p>

<p>C++03 性能上被长期被诟病的其中之一, 就是其耗时且不必要的深度拷贝. 深度拷贝会发生在当对象是以传值的方式传递. 举例而言, <code>std::vector&lt;T&gt;</code> 是内部保存了 C-style 数组的一个包装, 如果一个 <code>std::vector&lt;T&gt;</code> 的临时对象被建构或是从函数返回, 要将其存储只能通过生成新的 <code>std::vector&lt;T&gt;</code>并且把该临时对象所有的数据复制进去. 该临时对象和其拥有的內存会被摧毁. (为了讨论上的方便，这里忽略返回值优化)</p>

<p>在 C++11 中, 一个 <code>std::vector</code> 的 &ldquo;move 构造函数&rdquo; 对某个 vector 的右值引用可以单纯地从右值复制其内部 C-style 数组的指针到新的 vector, 然后留下空的右值. 这个操作不需要数组的复制, 而且空的临时对象的析构也不会摧毁内存. 传回 vector 临时对象的函数不需要显式地传回 <code>std::vector&lt;T&gt;&amp;&amp;</code>. 如果 vector 没有 move 构造函数, 那么复制构造函数将被调用, 以 <code>const std::vector&lt;T&gt; &amp;</code> 的正常形式. 如果它确实有 move 构造函数, 那么就会调用 move 构造函数, 这能够免除大幅的内存配置.</p>

<p>基于安全的理由, 具名的参数将永远不被认定为右值, 即使它是被如此声明的; 为了获得右值必须使用 <code>std::move&lt;T&gt;()</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">bool</span> <span class="n">is_r_value</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">is_r_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">is_r_value</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// i 为具名变量，即使被声明成右值也不會被认为是右值。</span>
</span><span class='line'>    <span class="n">is_r_value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="c1">// 使用 std::move&lt;T&gt;() 取得右值。</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于右值引用的用语特性以及对于左值引用 (L-value references;regular references) 的某些用语修正, 右值引用允许开发者提供完美转发 (perfect function forwarding). 当与变长参数模板结合, 这项能力允许函数模板能够完美地转送引数给其他接受这些特定引数的函数. 最大的用处在于转发构造函数参数, 创造出能够自动为这些特定引数调用正确建构式的工厂函数 (factory function).</p>

<h2>参考</h2>

<ul>
<li><a href="http://blog.csdn.net/pongba/article/details/1684519">《C++0x漫谈》系列之：右值引用(或“move语意与完美转发”)(上)</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/C%2B%2B11#.E5.8F.B3.E5.80.BC.E5.BC.95.E7.94.A8.E5.92.8C_move_.E8.AA.9E.E6.84.8F">维基百科C++11: 右值引用和 move 语义</a></li>
<li><a href="http://stackoverflow.com/questions/3106110/what-are-move-semantics/3109981">Stackoverflow：What are move semantics？</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics">标准文档提案：Move Semantics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 泛型编程之 SFINAE]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/25/cpp-template-sfinae/"/>
    <updated>2013-06-25T23:01:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/25/cpp-template-sfinae</id>
    <content type="html"><![CDATA[<h2>什么是 SFINAE?</h2>

<p>(Substitution Failure Is Not An Error) 匹配失败不是错误. 它可以从一组重载函数中剪裁掉不需要的模板实例.</p>

<p>SFINAE 是 C++ 模板的一个特性, 这个特性在 std::enable_if 中使用的非常广泛. 模板参数推导过程中, C++ 编译器会试图实例化一些候选的函数签名, 以确保函数调用时模板的精确匹配, 当找到一个不合适的匹配时(例如无效的参数或范围值), 则会将这个不合适的匹配从重载决议中删除, 而不是产生一个编译错误. 如果有且只有一个函数的话, 才会产生一个编译错误.</p>

<p>考虑下面的简单的乘法计数器</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">long</span> <span class="n">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">multiplication_result</span> <span class="n">multiply</span><span class="p">(</span><span class="n">T</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T</span> <span class="n">t2</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">t2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">multiply</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 main 函数中的函数调用 multiply, 会导致编译器对模板参数的实例化, 虽然第一个非模板函数 multiply 明显是一个更佳的匹配. 在实例化的过程中, 会产生一个非法的类型 int::multiplication_result. 根据 SFINAE, 这个非法的实例化会被自动丢弃. 最终, 非模板的 multiply 会被调用. 编译通过.</p>

<!-- more -->


<h2>SFINAE 的应用</h2>

<p>SFINAE 通常被用作编译时期的类型属性检查. 比如下面的 is_pointer 元函数, 它可以在编译期检查参数类型是否是一个指针.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">is_pointer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">U</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">Y</span> <span class="n">X</span><span class="o">::*</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">U</span> <span class="p">(</span><span class="o">*</span><span class="p">)());</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">static</span> <span class="kt">double</span> <span class="n">is_ptr</span><span class="p">(...);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">static</span> <span class="n">T</span> <span class="n">t</span><span class="p">;</span>
</span><span class='line'>  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">is_ptr</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">bar</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">IntPtr</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">Foo</span><span class="o">::*</span> <span class="n">FooMemberPtr</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncPtr</span><span class="p">)();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">IntPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>         <span class="c1">// prints 1</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">FooMemberPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>  <span class="c1">// prints 1</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">FuncPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>        <span class="c1">// prints 1</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果没有 SFINAE 的话, 元函数 is_pointer 是无法正常工作的. 在 is_pointer 中, 有四个模板函数 is_ptr, 其中三个都会返回一个 char, 这是经过精心设计的. 这三个分别接收不同的参数类型, 一个接受指针变量, 一个接受一个成员指针, 以及一个简单的函数指针类型. 最后一个 is_ptr 是接收任意类型的(使用了省略号), 它的返回值类型是 double, 它的大小始终会大于 char 类型.</p>

<p>当传递一个指针类型(例如上面的 IntPtr)给 is_pointer 时, value 的值将会初始化为 true (因为 sizeof 两边是相等的). 第一个 sizeof 表达式调用 is_ptr, 如果它是一个指针类型, 那么只有一个模板的重载版本会匹配. 根据 SFINAE, 编译不会报错，因为至少有一个函数被匹配上了.  如果没有合适的实例化版本, 那么会选择那个省略号的版本. 不过那个版本会返回 double 类型, 会导致 value 值被初始化为 false (因为 sizeof(double) != sizeof(char)).</p>

<p>需要注意的是, is_ptr 只有声明, 没有定义. 因为声明足以引发 SFINAE 规则, 但是这些必须都是模板函数。一个模板类的非模板函数是不会参与 SFINAE 的, 只有模板函数才会遵循 SFINAE 规则.</p>

<p>在标准库中, 有大量的 SFINAE 应用, 比如 type traits. 有了 SFINAE 我们就可以根据自己的需求, 为我们所关心的特定类型, 写相应的函数重载函数版本, 也可以在编译期判断类型是否符合我们的需求.</p>

<h2>参考</h2>

<ul>
<li>Wikipedia：<a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">Substitution failure is not an error</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 多线程, std::future & std::promise]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/14/cpp11-multithread-promise-future/"/>
    <updated>2013-06-14T22:36:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/14/cpp11-multithread-promise-future</id>
    <content type="html"><![CDATA[<p>C++11 中最让人高兴的新特性中线程库的支持一定榜上有名. C++11 中提供了 future 和 promise 来简化任务线程间的返回值操作; 同时为启动任务线程提供了 <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">packaged_task</a> 以方便操作.</p>

<h2>std::packaged_task</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a> 可以包装任何可调用的对象(函数, lambda 表达式, std::bind, 或其他函数对象), 以便异步调用, 调用结果保存在 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中, 可以通过成员函数 get_future 访问. 需要注意的是, <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a> 是不可拷贝的(move only).</p>

<p>示例代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cmath&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">task_lambda</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">([](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span><span class='line'>    <span class="n">task</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;task_lambda:</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">task_bind</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">));</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span><span class='line'>    <span class="n">task</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;task_bind:</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">task_thread</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">task_td</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span><span class='line'>    <span class="n">task_td</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;task_thread:</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">task_lambda</span><span class="p">();</span>
</span><span class='line'>    <span class="n">task_bind</span><span class="p">();</span>
</span><span class='line'>    <span class="n">task_thread</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>仅仅有 packaged_task 还远远不够, 我们还需要更强大的 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 和 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a>.</p>

<p>基本思路很简单: 当一个任务需要向父线程(启动它的线程)返回值时, 它把这个值放到 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 中. 之后, 这个返回值会出现在和此 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 关联的 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 中.于是父线程就能读到返回值. 更简单点的方法, 参看 <a href="http://en.cppreference.com/w/cpp/thread/async">async()</a>.</p>

<p>如果我们有一个 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> f, 通过 get() 可以获得它的值:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">X</span> <span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>  <span class="c1">// if necessary wait for the value to get computed</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果它的返回值还没有到达, 调用线程会进行阻塞等待. 要是等啊等啊, 等到花儿也谢了的话, get() 会抛出异常的(从标准库或等待的线程那个线程中抛出).</p>

<p>如果我们不需要等待返回值(非阻塞方式), 可以简单询问一下 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a>, 看返回值是否已经到达:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">// there is a value to get()</span>
</span><span class='line'>    <span class="c1">// do something</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// do something else</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 最主要的用途是一个简单的获取返回值的方法: get().</p>

<p><a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 的主要用途是提供一个 &ldquo;put&#8221;（或&#8221;get&#8221;，随你）操作, 以和 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 的 get() 对应.</p>

<p><a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 为 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 传递的结果类型有 2 种: 传一个普通值或者抛出一个异常</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">X</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// compute a value for res</span>
</span><span class='line'>    <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>   <span class="c1">// oops: couldn&#39;t compute res </span>
</span><span class='line'>    <span class="n">p</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>到目前为止还不错, 不过我们如何匹配 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> / <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 对呢? 一个在我的线程, 另一个在别的啥线程中吗? 是这样: 既然 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 和 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 可以被到处移动(不是拷贝), 那么可能性就挺多的. 最普遍的情况是父子线程配对形式, 父线程用 <a href="http://en.cppreference.com/w/cpp/thread/future">future</a> 获取子线程 <a href="http://en.cppreference.com/w/cpp/thread/promise">promise</a> 返回的值. 在这种情况下, 使用 <a href="http://en.cppreference.com/w/cpp/thread/async">async()</a> 是很优雅的方法.</p>

<h2>std::promise</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 提供一个存储设施, 当一个异步任务通过 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 来获取结果时, <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 可以提供.</p>

<h2>std::future</h2>

<p>模板类 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 提供了一种机制来访问异步操作的结果:
由 <a href="http://en.cppreference.com/w/cpp/thread/async">std::async</a>, <a href="http://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task</a>, 或者 <a href="http://en.cppreference.com/w/cpp/thread/promise">std::promise</a> 创建的异步操作, 可以提供一个 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 对象, 给创建者, 用来访问异步操作的结果.</p>

<p>异步操作的创建者, 可以使用各种不同的操作来查询, 等待, 或者从 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中取到异步操作的结果. 如果异步操作还没有执行完的话, 这些操作有可能会阻塞.
当一个异步操作完成时可以通过更改(例如使用 <code>std::promise::set_value</code>) 共享状态(该状态保存在 <a href="http://en.cppreference.com/w/cpp/thread/future">std::future</a> 中) 将结果返回给异步操作的创建者.</p>

<p>示例代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;future&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// future from a packaged_task</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">([](){</span> <span class="k">return</span> <span class="mi">7</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// wrap the function</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>  <span class="c1">// get a future</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">)).</span><span class="n">detach</span><span class="p">();</span> <span class="c1">// launch on a thread</span>
</span><span class='line'>    <span class="c1">// future from an async()</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[](){</span> <span class="k">return</span> <span class="mi">8</span><span class="p">;</span> <span class="p">});</span>
</span><span class='line'>    <span class="c1">// future from a promise</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">){</span> <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span> <span class="p">},</span>
</span><span class='line'>                 <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">p</span><span class="p">)).</span><span class="n">detach</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Waiting...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
</span><span class='line'>    <span class="n">f1</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>   <span class="n">f2</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>    <span class="n">f3</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Done!</span><span class="se">\n</span><span class="s">Results are: &quot;</span>
</span><span class='line'>              <span class="o">&lt;&lt;</span> <span class="n">f1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">f2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">f3</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/thread">Cppreference：Thread support library</a></li>
<li><a href="http://en.wikipedia.org/wiki/Futures_and_promises">wikipedia: futures and promises</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++14 std::optional<T>]]></title>
    <link href="http://bitdewy.github.com/blog/2013/06/04/cpp14-optional/"/>
    <updated>2013-06-04T01:54:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/06/04/cpp14-optional</id>
    <content type="html"><![CDATA[<p>C++11已经发布将近2年时间, 各编译器也陆续有了较好的支持. C++14 也已经有相当多的提案被接受, 包括 std::optional, 泛型 lambda, make_unique, 动态数组等, 肯定会出现在下一个标准中. 关于新标准中的提案, 以及已经被接受的提案，详细信息可以参考, wikipedia：<a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14</a>, 以及 open-std 中的 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">C++ 标准草案</a>.</p>

<h2>“无意义”的值</h2>

<p>函数并不总能返回有效的返回值, 很多时候函数可能返回&#8221;无意义&#8221;的值, 这不意味着函数执行失败, 而是表明函数正确执行了, 但结果却不是有用的值.
表示返回值无意义最常用的做法是增加一个&#8221;哨兵&#8221;的角色, 它位于解空间之外, 比如 <code>NULL, -1, EOF, std::string::npos, vector::end()</code>等. 但这些做法不够通用, 而且很多时候不存在解空间之外的&#8221;哨兵&#8221;.</p>

<h2>std::optional<T></h2>

<p>optional 库使用&#8221;容器&#8221;语义, 包装了&#8221;可能产生无效值&#8221;的对象, 实现了&#8221;未初始化&#8221;的概念. (在新标准未正式发布之前，可以参考 <a href="http://www.boost.org/doc/libs/1_54_0/libs/optional/doc/html/index.html">boost::optional</a> 的实现.)</p>

<p>optional 使用&#8221;容器&#8221;语义, 为这种&#8221;无效值&#8221;的情形提供了一个较好的解决方案. 它很像一个仅能存放一个元素的容器, 它实现了&#8221;未初始化&#8221;的概念: 如果元素未初始化, 那么容器就是空的, 否则, 容器内就是有效的, 已经初始化的值.</p>

<!-- more  -->


<h2>操作函数</h2>

<p>optional 的模板类型参数 T 可以使任何类型， 就如同一个标准容器对元素的要求, 并不需要T具有缺省构造函数, 但必须是可拷贝构造的.
optional 采用了指针语义来访问内部保存的元素, 这使得 optional 未初始化时的行为就像一个空指针. 它重载了 <code>operator*</code> 和 <code>operator-&gt;</code> 以实现与指针相同的操作, <code>get()</code> 和 <code>get_ptr()</code> 可以以函数的操作形式获得元素的引用和指针. 成员函数 <code>get_value_or(default)</code> 是一个特别的访问函数, 可以保证返回一个有效的值, 如果 optional 已初始化, 那么返回内部的元素, 否则返回 default. optional 也可以用隐式类型转换进行 bool 测试(用于条件判断), 就像一个对指针的判断. optional 还全面支持比较运算，包括 <code>==, !=, &lt;, &lt;=, &gt;, &gt;=</code>. (详细接口参考 <a href="http://en.cppreference.com/w/cpp/utility/optional">cppreference: std::optional</a>)</p>

<h2>用法</h2>

<p>optional 的接口简单明了, 把它认为是一个大小为 1 并且行为类似指针的容器就可以了, 或者把它想象成是一个类似 scoped_ptr, shared_ptr 的智能指针(注意, optional 不是智能指针, 用法类似但用途不同).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="cp">#include &quot;boost/optional.hpp&quot;</span>
</span><span class='line'><span class="cp">#include &quot;boost/lexical_cast.hpp&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// converts int to string if possible</span>
</span><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">str2int</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">lexical_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bad_lexical_cast</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">get_int_form_user</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">o</span> <span class="o">=</span> <span class="n">str2int</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// &#39;o&#39; may or may not contain an int</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>                                 <span class="c1">// does optional contain a value?</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>                             <span class="c1">// use the value</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get_int_form_user</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上面的代码所示: 使用 optional, 非法的 int 类型, 就不需要定义一个特别的错误码作为无意义值了.</p>

<h2>参考</h2>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/utility/optional">cppreference.com: optional</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">A proposal to add a utility class to represent optional objects (Revision 4)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模板方法模式]]></title>
    <link href="http://bitdewy.github.com/blog/2013/05/28/template-method-pattern/"/>
    <updated>2013-05-28T01:26:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/05/28/template-method-pattern</id>
    <content type="html"><![CDATA[<h2>意图</h2>

<ol>
<li>定义一个操作中的算法骨架, 将一些步骤延迟到子类中定义. 模板方法模式, 可以让子类不改变算法的结构重新定义算法的某些步骤.</li>
<li>基类声明算法的“占位符”, 子类来实现这个“占位符”.</li>
</ol>


<h2>讨论</h2>

<p>组件设计者决定哪些算法的步骤是不变的? 哪些是会变化的? 不变的步骤在抽象类中直接实现, 可能变化的步骤给出默认的实现, 或者完全不实现. 变化的部分代表“hooks”, 或占位符. 可以在使用组件时, 在派生类中实现.</p>

<p>组件设计者设计算法的步骤, 步骤的顺序, 但同时允许用户来扩展或替换算法中的某些步骤.</p>

<p>模板方法模式在框架中的使用非常广泛. 每个框架都会实现框架的主要结构, 然后定义一系列的“占位符”给用户, 让用户有机会来自定义一些操作.这么做时, 框架就变成了核心部分, 用户自定义的操作就会变得容易. 这使得控制结构发生反转, 这个方式有一个很好的名字, “好莱坞原则”——“不要给我们打电话, 我们会打电话给你.”</p>

<!-- more  -->


<h2>结构</h2>

<p><img src="https://qhphgq.bay.livefilestore.com/y2pBx_PXPtSilwtV5sYskGDPJkXjmpbdLnwAeT9H_7drKPs4-4_-pm3OfDw58eFEjaFRaa2LSKhbnJODUkyO8CpuQRq8iF306c3KF6Ix_M1zWA/image002.gif" alt="" /></p>

<p>template_method() 的实现如下: 调用 step_one(), 调用 step_two(), 然后调用 step_three(). step_two() 是一个 “hook” 方法——一个占位符. 它在基类中声明, 然后在派生类中实现. 框架中使用模板方法模式非常的频繁. 所有可重用的代码都定义在框架的基类中, 框架的用户可以通过派生类来定制一些想要的行为.</p>

<p><img src="https://qhphgq.bay.livefilestore.com/y2pMCc56J8x2oBUDmOTnSI3RIm-N5Gtpyj355-us-8Rj6CwVbNzQfiEJyprTSAXmCS8rG0MbCE-qwP-Y65dPUdVWyXU8V2FC4IWhzy_2WBvDZA/image003.gif" alt="" /></p>

<h2>做法</h2>

<ol>
<li>检测算法, 决定哪些步骤是标准的通用的, 哪些是特有的.</li>
<li>定义一个抽象类, 用来实现依赖的反转.</li>
<li>将算法的壳以及所有的标准（公共）的步骤移到基类中.</li>
<li>在基类中给那些需要不同实现的步骤定义一个占位符或者“hook”方法, 这些方法可以有默认实现, 也可以完全没有. (C++中的纯虚函数, Java中的抽象方法）</li>
<li>在模板方法中调用这些“占位符”.</li>
<li>所有现有的类都继承于现在的抽象类.</li>
<li>将基类中已经实现的现有的类中的细节全部移除.</li>
<li>那些不同的部分仍然留在这些派生类中，用来实现每个派生类中不同的操作.</li>
</ol>


<h2>经验</h2>

<p>除了粒度的区别之外, 策略模式与模板方法模式非常类似.
模板方法使用继承来改变算法的某个部分, 而策略模式改变整个算法.
策略模式改变单个对象的逻辑. 模板方法修改了整个类的逻辑.
工厂方法模式是一个特化的模板方法模式.</p>

<h2>例子</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">a</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;a  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">c</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;c  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">e</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;e  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 2. Steps requiring peculiar implementations are &quot;placeholders&quot; in base class</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ph1</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ph2</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// 1. Standardize the skeleton of an algorithm in a base class &quot;template method&quot;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">a</span><span class="p">();</span>
</span><span class='line'>        <span class="n">ph1</span><span class="p">();</span>
</span><span class='line'>        <span class="n">c</span><span class="p">();</span>
</span><span class='line'>        <span class="n">ph2</span><span class="p">();</span>
</span><span class='line'>        <span class="n">e</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">One</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 3. Derived classes implement placeholder methods</span>
</span><span class='line'>    <span class="cm">/*virtual*/</span><span class="kt">void</span> <span class="n">ph1</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;b  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="cm">/*virtual*/</span><span class="kt">void</span> <span class="n">ph2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;d  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Two</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/*virtual*/</span><span class="kt">void</span> <span class="n">ph1</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;2  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="cm">/*virtual*/</span><span class="kt">void</span> <span class="n">ph2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;4  &quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Base</span><span class="o">*</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">One</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Two</span><span class="p">()</span> <span class="p">};</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
</span><span class='line'>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 关键字 using]]></title>
    <link href="http://bitdewy.github.com/blog/2013/05/21/cpp11-keywords-using/"/>
    <updated>2013-05-21T00:45:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/05/21/cpp11-keywords-using</id>
    <content type="html"><![CDATA[<p><em>这个特性, 10年前就已经有提案了, 直到 C++11 中才正式加入标准. ⊙﹏⊙b汗</em></p>

<h2>使用小技巧来声明函数指针</h2>

<p>在 c++03 中, 函数指针要这么写:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">FunctionPtr</span><span class="p">)();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个声明读起来相当的费劲, C 语言的初学者会很难理解上面的 typedef 表达的意思.</p>

<p>在 C++11 中, 我们可以使用更易读懂的方式来表达, 利用 using 关键字:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">using</span> <span class="n">FunctionPtr</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)();</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你想去除丑陋的 * 号, 还可以利用类型特化这么来写:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;type_traits&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="n">FunctionPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">add_pointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>新关键字 using 当然不仅仅是为了这个简单的功能了, 最主要的目的是为了模板别名.</p>

<!-- more -->


<h2>模板别名</h2>

<p>在进入这个主题之前, 应该先弄清楚“模板类”和“类模板”本质上的不同. class template (类模板，是模板)是用来产生 template class (模板类, 是类型)的.
在标准 C++, typedef 可定义模板类一个新的类型名称, 但是不能够使用 typedef 来定义模板的别名. 举例来说:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">first</span><span class="p">,</span> <span class="k">typename</span> <span class="n">second</span><span class="p">,</span> <span class="kt">int</span> <span class="n">third</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">SomeType</span><span class="p">;</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">second</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">SomeType</span><span class="o">&lt;</span><span class="n">OtherType</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">TypedefName</span><span class="p">;</span> <span class="c1">// 在C++03是不合法的</span>
</span></code></pre></td></tr></table></div></figure>


<p>这不能够通过编译.
为了定义模板的别名, C++11 增加了以下的语法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">first</span><span class="p">,</span> <span class="k">typename</span> <span class="n">second</span><span class="p">,</span> <span class="kt">int</span> <span class="n">third</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">SomeType</span><span class="p">;</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">second</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="n">TypedefName</span> <span class="o">=</span> <span class="n">SomeType</span><span class="o">&lt;</span><span class="n">OtherType</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>using 紧跟着的标识, 用来表示后面的模板类型. 标准制定时尝试过使用旧的关键字 typedef 来实现该功能, 但是无法得到一个完整连贯的解决方案, 因此引入了新的关键字. (严格说来 using 并不是一个新的关键字, 在使用 namespace 时, 我们就已经见过它了, 但在 C++11 中它又有了新的语义.）</p>

<p>除了模板别名之外, using 关键字还可以用在一般的类型中, 就想文章一开始的地方一样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">PFD</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>            <span class="c1">// 传统语法</span>
</span><span class='line'><span class="k">using</span> <span class="n">PFD</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>           <span class="c1">// 新增与否</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li>C++ standard  14.6.7 Template aliases;  7.1.3 The typedef specifier</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1489.pdf">Templates aliases for C++</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">Templates Aliases (Revision 3)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] GotW #1 Solution: Variable Initialization – or Is It?]]></title>
    <link href="http://bitdewy.github.com/blog/2013/05/12/gotw1/"/>
    <updated>2013-05-12T02:55:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/05/12/gotw1</id>
    <content type="html"><![CDATA[<p>原文在这里 <a href="http://herbsutter.com/2013/05/09/gotw-1-solution/">GotW #1 Solution: Variable Initialization – or Is It?</a></p>

<p><em>第一个问题是用来强调理解你写的代码的含义的重要性. 下面是几行简单的代码 &ndash; 大部分都与其他的有一些区别, 即使只是语法略有变化.</em></p>

<h2>JG 问题</h2>

<p>1. 下面的代码有什么不同?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// (a)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">();</span>                 <span class="c1">// (b)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{};</span>                 <span class="c1">// (c)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                <span class="c1">// (d)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>                <span class="c1">// (e)</span>
</span><span class='line'>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>               <span class="c1">// (f)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span>             <span class="c1">// (g)</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                 <span class="c1">// (h)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">widget</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>         <span class="c1">// (i)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Guru 问题</h2>

<p>2. 下面的每一行代码做了什么?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">);</span>   <span class="c1">// (a)</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>   <span class="c1">// (b)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3. 除了上面的情况以外, 使用 <code>{ }</code> 初始化对象还有什么其他的好处?</p>

<p>4. 什么时候使用 <code>( )</code> 以及 <code>{ }</code> 来初始化对象? 为什么?</p>

<!-- more -->


<h2>解决方案</h2>

<p>这几个问题展示了几件事:</p>

<ul>
<li>默认初始化, 显式初始化, 拷贝初始化, 以及初始化列表之间的区别.</li>
<li>初始化时 <code>( )</code> 与 <code>{ }</code> 之间的差异.</li>
<li>在现代 C++ 中要避免的, 看起来像初始化, 但完全和初始化无关的东西</li>
</ul>


<p>不过, 最重要的是: 如果你坚持问题 #4 中的两个简单的指导的话, 就可以忽略这些情况, 规则相当的简单, 而且默认情况下可以获得高效的性能.</p>

<h3>1. 下面的代码有什么不同?</h3>

<p>让我们一条一条的来看.</p>

<p><strong>情况 (a) 是默认初始化</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// (a)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这一行代码声明了一个 <code>widget</code> 类型的变量 <code>w</code>, 假定 <code>widget</code> 是一个 <code>class</code> 类型, 它会使用默认构造函数 <code>widget::widget()</code> 来初始化.</p>

<p><strong>情况 (b) 是一个 &ldquo;恼人&rdquo; 的无关转移, 是历史遗留问题</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">();</span>                 <span class="c1">// (b)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是 C++ 的一个陷阱: 第一眼看上去, 它看上去像另一个调用默认构造函数 <code>widget::widget()</code> 的变量声明. 事实上, 感谢语法二义性, 这是一个函数声明. 一个名为 <code>w</code>, 无参, 返回值是 <code>widget</code> 类型的函数声明. (如果你无法一眼看出的话, 考虑下上面的代码其实与 <code>int f()</code> 没有任何的差别, 而这个函数声明是显而易见的对吧.)</p>

<p>避免你认为 &ldquo;吖, 但是那些 <code>()</code> 是多于的, 这是程序员自己的错误, 因为他们没有直接写 <code>widget w;</code>&rdquo;, 注意, 这个的问题也会出现在你以为你正在使用临时对象初始化变量的时候:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// same problem (gadget and doodad are types)</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span> <span class="n">gadget</span><span class="p">(),</span> <span class="n">doodad</span><span class="p">()</span> <span class="p">);</span>  <span class="c1">// pitfall: not a variable declaration</span>
</span></code></pre></td></tr></table></div></figure>


<p>Scott Meyers 很多年前就称这个是 &ldquo;C++ 中最恼人的语法解析&rdquo;, 因为标准中解决语法二义性是这么说的: &ldquo;如果能够被解析为函数声明, 那么它就是一个函数声明.&rdquo;</p>

<p>好消息是, 这个问题将要成为历史, 在新的代码中你将不会遇到它, 因为 C++11 移除了这个陷阱. 注意 C++11 并没有修改语义 &ndash; C++11 的向后兼容 C++98 做的非常好, 包括这个语法二义性, 仍然是它原有的含义. 但是, C++11 通过提供新的语法取代情况 (b), 因此我们再也不会掉到这个陷阱中了.</p>

<p><strong>情况 (c) 干净明确</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{};</span>                 <span class="c1">// (c)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这儿我们有了第一个使用 <code>{ }</code> 而不使用 <code>()</code> 的理由: 对于任意的 class 类型 <code>widget</code>, 情况 (c) 做的事情像 (a) 一样的明确 &ndash; 无二义性, 干净, 明确.</p>

<p>&ldquo;哈哈, 但是等等, 它可没有那么简单!&rdquo; 有些人可能会反对. &ldquo;如果 <code>widget</code> 有一个接受 <code>std::initializer_list</code> 的构造函数那会怎么样呢? 他们都是被优先选择的, 所以, 如果 <code>widget</code> 有这么一个构造函数, 这个写法不会调用它吗?&rdquo;</p>

<p>答案是不会, 这个真的像你看到的一样简单, 因为标准中明确了, 如果可以的话, 空的 <code>{ }</code> 列表意味着调用默认构造函数. 不过, 能意识到 <code>initializer_list</code> 是好的, 让我们在后面再讨论它.</p>

<p><strong>情况 (d) 和 情况 (e) 是直接初始化</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                <span class="c1">// (d)</span>
</span><span class='line'><span class="n">widget</span> <span class="n">w</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>                <span class="c1">// (e)</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设 <code>x</code> 不是一个类型名, 这两个都是直接初始化. 因为变量 <code>w</code> 是由 <code>x</code> 直接调用 <code>widget::widget(x)</code> 初始化的. 如果 <code>x</code> 也是 <code>widget</code> 类型, 它会调用拷贝构造函数. 否则的话, 调用一个转换构造函数.</p>

<p>但是, 注意 <code>{x}</code>, 它会创建一个 <code>initializer_list</code>. 如果 <code>widget</code> 有接受 <code>initializer_list</code> 的构造函数的话, 这个构造函数是被优先选择的; 否则, 如果 <code>widget</code> 有接受任意 <code>x</code> 的类型的构造函数的话(包括类型转换), 这个构造函数将会被调用.</p>

<p>情况 (e) 有两个优于 (d) 的地方: 一, 与 (c) 一样, (e) 是明确, 无二义性的. 如果 <code>x</code> 是一个类型名, 那么 (d) 就是一个函数声明, 即使在作用域内有一个名为 <code>x</code> 的变量 (看下文), 而 (e) 不可能是一个函数声明.</p>

<p>第二: (e) 更安全, 因为它不允许有损转换, 一些内建类型是允许的. 考虑下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">i1</span><span class="p">(</span> <span class="mf">12.345</span> <span class="p">);</span>           <span class="c1">// ok: loss .345, we didn&#39;t like it anyway</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i2</span><span class="p">{</span> <span class="mf">12.345</span> <span class="p">};</span>           <span class="c1">// error: would be lossy implicit narrowing</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>情况 (f) 与 (g) 是拷贝初始化和拷贝类表初始化</strong></p>

<p>这是最后两个 non-auto 的情况:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>               <span class="c1">// (f)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是所谓的拷贝初始化. <em>从概念上来讲</em>, 变量 <code>w</code> 是由 <code>widget</code> 的转移构造函数或者拷贝构造函数初始化的. 有可能是在调用一个隐式转换函数之后(显式转换不会调用).</p>

<blockquote><p><strong>通常的错误:</strong> 这个绝对是初始化; 绝不是赋值, 所以绝对不会调用 <code>T::operator=()</code>. 是的, 我知道这有一个<code>=</code>赋值符号, 但是不要让这个符号影响到你 &ndash; 这仅仅是从 C 继承而来的符号, 不是赋值操作符.</p></blockquote>

<p>下面是语义:</p>

<ul>
<li>如果 <code>x</code> 的类型是 <code>widget</code>, (f) 与 (d) <code>widget w(x);</code> 的含义完全一致, 除非明确的构造函数不能使用. 他保证了只有一个构造函数被调用.</li>
<li>如果 <code>x</code> 是其他类型, <em>从概念上来讲</em>编译器首先将 <code>x</code> 隐式转换为 <code>widget</code> 类型的临时对象, 然后对临时右值使用转移构造函数, 如果没有好的转移构造函数, 那么会使用拷贝构造函数 &ndash; &ldquo;低效的转移&#8221;作为备选. 假设存在可用的隐式转换, (f) 就与 <code>widget w(widget(x))</code> 一致了.</li>
</ul>


<p>注意, 上面说了几次<em>从概念上来讲</em>. 这是因为通常编译器都会做优化, 优化掉临时变量, 如果存在隐式转换, 从 (f) 转换为 (d), 那么就优化掉了额外的转移操作. 但是, 尽管编译器这么做了, <code>widget</code> 的拷贝构造函数也必须是可访问的, 即使没有调用 &ndash; 拷贝构造函数的副作用可能发生也可能不发生, 就这些.</p>

<p>现在来注意一下增加的符号 <code>=</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span>             <span class="c1">// (g)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个是所谓的拷贝列表初始化. 它与 <code>widget w{x};</code> 的含义一致 除非显示的构造函数无法使用. 它保证了只有咦个的构造函数被调用.</p>

<p><strong>情况 (h) 和 (i) 也是拷贝初始化, 但是更简单</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                 <span class="c1">// (h)</span>
</span><span class='line'><span class="k">auto</span> <span class="n">w</span> <span class="o">=</span> <span class="n">widget</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>         <span class="c1">// (i)</span>
</span></code></pre></td></tr></table></div></figure>


<p>语义与 (f) 和 (g) 一样, 但是学习起来更简单, 因为使用了 <code>auto</code> 保证了右侧表达式类型推导的准确性. 需要注意的是 (i) 在隐式转换与显式转换的情况下都能正常工作.</p>

<p>(h) 与 (d) 的含义一致, <code>type_of_x w(x);</code>. 只有一个拷贝构造函数被调用. 它可以保证类型发生变化时, 程序还总是正确的: 因为 (h) 没有明确特性的类型, 它有两个有效的保证, 因为这不会存在类型的转换, 以及更好的维护性, 因为当程序中 <code>x</code> 的类型变更时, &lsquo;w&rsquo; 会自动变更类型与 <code>x</code> 保持一致.</p>

<p>当你想要明确类型或者需要显式的类型转换时, (i) 是最风格一致的, 而且一旦使用了 <code>{ }</code> 就可以避免有损的类型转换了. 大部分的编译器实现, 只会有一个构造函数调用 &ndash; 和我们看到的 (f) 与 (g) 相似, 概念上来讲会有两个构造函数调用, 一个转换构造函数或者拷贝构造函数用来创建临时的 <code>widget{x}</code> 然后紧接着一个转移构造函数来构造 <code>w</code>, 但是编译器会把后一个优化掉.</p>

<p>通常情况下, 我推荐你尝试这两种用法, 并倾向于使用它来伴随你舒服的成长. 现在几乎所有我写的局部变量声明都采用这种方式. (我知道会有一些人怀疑这种方式 &ndash; 更多的关于关键字 <code>auto</code> 的问题在其他的 GotW 中讨论.)</p>

<h3>2. 下面的每一行代码做了什么?</h3>

<p>在第二个问题的代码中, 我们创建了一个 <code>vector&lt;int&gt;</code> 并将参数 <code>10</code> 和 <code>20</code> 传给它的构造函数 &ndash; 第一种情况是 <code>(10, 20)</code>, 第二种情况是 <code>{10, 20}</code>.</p>

<p>两个都会调用构造函数, 但是会调用哪个呢? 嗯, <code>vector&lt;int&gt;</code> 有很多接受两个参数的构造函数, 但是只有下面两个能够正确的接受参数 <code>10</code> 和 <code>20</code>. 为了简单, 忽略掉默认的分配器参数, 两个构造函数应该是下面的样子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="p">(</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">);</span>    <span class="c1">// A: n copies of value</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="p">(</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span> <span class="p">);</span>  <span class="c1">// B: copy of values</span>
</span></code></pre></td></tr></table></div></figure>


<p>有两个简单的规则可以帮助我们确定哪个函数将被调用:</p>

<ul>
<li>在表达式的上下文中使用 <code>{ }</code> 你会得到一个 <code>initializer_list</code>.</li>
<li>接受 <code>initializer_list</code> 参数的构造函数会优于其他构造函数被选择, 同时会隐藏其他构造函数, 否则可能是可行的.</li>
</ul>


<p>有了这两条, 答案就很简单了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">);</span>    <span class="c1">// (a) calls A: 10 copies of the value 20</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span> <span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>    <span class="c1">// (b) calls B: the values 10 and 20</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. 除了上面的情况以外, 使用 <code>{ }</code> 初始化对象还有什么其他的好处?</h3>

<p>首先, 这叫做统一初始化, 因为它统一 &ndash; 所有的类型, 包括 <code>structs</code>, 数组, 标准库容器, 而且也不存在恼人的语法解析问题.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">mystruct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// C++98 </span>
</span><span class='line'><span class="n">rectangle</span>       <span class="n">w</span><span class="p">(</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">);</span>       <span class="c1">// oops, vexing parse </span>
</span><span class='line'><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">(</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">);</span>
</span><span class='line'><span class="n">mystruct</span>        <span class="n">m</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span>             <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>     <span class="n">v</span><span class="p">;</span>                              <span class="c1">// urk, need more code</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">//   to initialize this</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// C++11 (note: &quot;=&quot; is optional)</span>
</span><span class='line'><span class="n">rectangle</span>       <span class="n">w</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">};</span>
</span><span class='line'><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span>   <span class="o">=</span> <span class="p">{</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">};</span>
</span><span class='line'><span class="n">mystruct</span>        <span class="n">m</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span>             <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>     <span class="n">v</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意, 这不仅仅是个审美的问题. 考虑编写通用的能够初始化任何类型的代码&hellip; 我们正在做的, 让我们使用完美转发做为例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">forwarder</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">local</span> <span class="o">=</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">};</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>            <span class="p">(</span> <span class="mi">42</span> <span class="p">);</span>                  <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">rectangle</span><span class="o">&gt;</span>      <span class="p">(</span> <span class="n">origin</span><span class="p">(),</span> <span class="n">extents</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="mf">2.71828</span><span class="p">,</span> <span class="mf">3.14159</span> <span class="p">);</span>    <span class="c1">// ok</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">mystruct</span><span class="o">&gt;</span>       <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>                <span class="c1">// ok because of {}</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span>          <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>          <span class="c1">// ok because of {}</span>
</span><span class='line'><span class="n">forwarder</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span>    <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>          <span class="c1">// ok because of {}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果 <code>forwarder</code> 内部使用了 <code>( )</code> 做初始化符号的话, 那么最后三条是不合法的.</p>

<p>新的符号 <code>{ }</code> 在任何地方都能完美的工作, 包括类成员的初始化:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">widget</span><span class="o">::</span><span class="n">widget</span><span class="p">(</span> <span class="cm">/*...*/</span> <span class="p">)</span> <span class="o">:</span> <span class="n">mem1</span><span class="p">{</span><span class="n">init1</span><span class="p">},</span> <span class="n">mem2</span><span class="p">{</span><span class="n">init2</span><span class="p">,</span> <span class="n">init3</span><span class="p">}</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外, 它还能简单清晰的表达传递函数参数, 返回值, 而不需要一个具名的临时对象:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">draw_rect</span><span class="p">(</span> <span class="n">rectangle</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">draw_rect</span><span class="p">(</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">)</span> <span class="p">);</span>         <span class="c1">// C++98</span>
</span><span class='line'><span class="n">draw_rect</span><span class="p">({</span> <span class="n">origin</span><span class="p">,</span> <span class="n">selection</span> <span class="p">});</span>                  <span class="c1">// C++11</span>
</span><span class='line'>
</span><span class='line'><span class="n">rectangle</span> <span class="n">compute_rect</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>   <span class="c1">// ...</span>
</span><span class='line'>   <span class="k">if</span><span class="p">(</span><span class="n">cpp98</span><span class="p">)</span> <span class="k">return</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">);</span>  <span class="c1">// C++98</span>
</span><span class='line'>   <span class="k">else</span>      <span class="k">return</span> <span class="p">{</span><span class="n">origin</span><span class="p">,</span> <span class="n">selection</span><span class="p">};</span>           <span class="c1">// C++11</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. 什么时候使用 <code>( )</code> 以及 <code>{ }</code> 来初始化对象? 为什么?</h3>

<p>下面是简单的指导:</p>

<blockquote><p><strong>准则:</strong> 尽量在初始化时使用 <code>{ }</code>, 比如 <code>vector&lt;int&gt; v = { 1, 2, 3, 4 };</code> 或者 <code>auto v = vector&lt;int&gt;{ 1, 2, 3, 4 };</code>, 因为它有更好的一致性, 更正确, 可以避免去了解过去的陷阱. 在单参数的情况下你可能会仅仅看到一个赋值符号 <code>=</code>, 就像 <code>int i = 42;</code> 一样, 这种情况下, 省略括号是好的&hellip;</p></blockquote>

<p>上面的准则可以覆盖绝大部分情况, 但是也有一个例外:</p>

<blockquote><p>&hellip; 在极端情况下, 比如 <code>vector&lt;int&gt; v(10,20);</code> 或者 <code>auto v = vector&lt;int&gt;(10,20);</code> 时, 使用 <code>( )</code> 明确的调用会被 <code>initializer_list</code> 构造函数隐藏的构造函数.</p></blockquote>

<p>但是, 这个仅仅是在极端情况下, 因为默认构造函数以及拷贝构造函数已经很特别, 并且能与括号 <code>{ }</code> 很好的工作, 现在一个好的类的设计会避免用到 <code>()</code> 来提供用户定义的构造函数, 因为下面的设计准则:</p>

<blockquote><p><strong>准则</strong>: 当你设计一个类时, 避免提供一个与 <code>initializer_list</code> 构造函数会产生二义性的构造函数, 这样用户就不需要使用 <code>()</code> 来访问会被隐藏掉的构造函数.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用静态多态辅助动态多态]]></title>
    <link href="http://bitdewy.github.com/blog/2013/04/09/staitc-and-dynamic-polymorphism/"/>
    <updated>2013-04-09T23:13:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/04/09/staitc-and-dynamic-polymorphism</id>
    <content type="html"><![CDATA[<h2>静态多态 (编译期多态) 与动态多态 (运行期多态)</h2>

<p>关键字: 重载/模版和虚函数</p>

<p>类型: 编译期多态 (静态多态, 早绑定) 和运行期多态 (晚绑定)
编译期多态 (重载/模版), 运行期多态 (虚函数)</p>

<p>应用形式上:
静多态是发散式的, 让相同的实现代码应用于不同的场合.
动多态是收敛式的, 让不同的实现代码应用于相同的场合.</p>

<p>思维方式上:
静多态是泛型式编程风格, 它看重的是算法的普适性.
动多态是对象式编程风格, 它看重的是接口和实现的分离度.</p>

<h2>std::shared_ptr 中的 deleter 是如何工作的?</h2>

<p>标准库中的引用计数智能指针 shared_ptr 很有趣——你可以向其构造器传递一个函数或者仿函数 (function object, 或 functor), 当引用计数归零的时候, 它将在被引用对象上调用删除器 (deleter). 乍一看, 似乎没啥了不起啊, 但请看代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">shared_ptr</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">explicit</span> <span class="n">shared_ptr</span><span class="p">(</span><span class="n">U</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">D</span> <span class="n">deleter</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>注意 <code>shared_ptr&lt;T&gt;</code> 必然在析构时调用类型为 D 的删除器, 然而它根本不知道 D 为何物. 这个对象不能包含类型为 D 的数据成员, 也不能指向类型为 D 的对象, 因为声明其数据成员时, D 对它而言还是未知的. 那么, shared_ptr 对象如何跟踪删除器 (它在构造阶段传入: 当 T 对象将被销毁时, 还得使用它) 呢? 更通俗地说, 构造器如何将未知类型的信息传递给它正在构造的对象, 而这个对象本身对信息类型完全无知? 答案很简单: 让此对象包含一个指向已知类型基类的指针 (标准库中叫它 sp_counted_base), 然后让构造器以 D 为参数实例化一个派生于上述基类的模板 (标准库中叫 sp_counted_impl_p 和 sp_counted_impl_pd), 最后用声明于基类, 实现于派生类的虚函数 (标准库中使用 dispose) 去调用删除器. 关于这个问题, Scott Meyers 在 06 年 9 月份的一篇文章中已经有阐述, 详见: <a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">My Most Important C++ Aha! Moments</a>.</p>

<h2>结合静态多态和动态多态实现类型无关的容器</h2>

<p>使用 std::shared_ptr 中 deleter 的实现方式, 可以实现类型无关的容器. 代码主干如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">any</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">any</span><span class="p">()</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">any</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="k">new</span> <span class="n">holder</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">any</span><span class="p">(</span><span class="k">const</span> <span class="n">any</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">content</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">content</span> <span class="o">?</span> <span class="n">other</span><span class="p">.</span><span class="n">content</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">any</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">content</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="n">swap</span><span class="p">(</span><span class="n">any</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">content</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">any</span><span class="p">(</span><span class="n">rhs</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">any</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">any</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">rhs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">content</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">content</span> <span class="o">?</span> <span class="n">content</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">:</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">placeholder</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="o">~</span><span class="n">placeholder</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">placeholder</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">holder</span> <span class="o">:</span> <span class="k">public</span> <span class="n">placeholder</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">holder</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">held</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">typeid</span><span class="p">(</span><span class="n">ValueType</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">placeholder</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">holder</span><span class="p">(</span><span class="n">held</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">ValueType</span> <span class="n">held</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">holder</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">holder</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">placeholder</span><span class="o">*</span> <span class="n">content</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中, any 类持有一个 placeholder 的基类指针, 在构造 any 对象时, 通过 any 的模板构造函数, 根据具体类型创建具体的 placeholder 子类类型, any 类提供 type() 接口, 用于查询 any 类中存储的实际类型.boost::any 中有类似的实现.</p>

<p>使用方式如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">bitdewy</span><span class="o">::</span><span class="n">any</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">any_array</span><span class="p">;</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">any_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">.1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">any_array</span><span class="p">),</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">any_array</span><span class="p">),</span>
</span><span class='line'>                <span class="p">[](</span><span class="k">const</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">double</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bitdewy</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//LOG ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考</h3>

<ul>
<li><a href="http://svn.boost.org/svn/boost/trunk/boost/any.hpp">boost::any</a></li>
<li><a href="http://www.artima.com/cppsource/top_cpp_aha_moments.html">My Most Important C++ Aha! Moments</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QtScript 与信号槽]]></title>
    <link href="http://bitdewy.github.com/blog/2013/03/21/qtscript/"/>
    <updated>2013-03-21T14:53:00+08:00</updated>
    <id>http://bitdewy.github.com/blog/2013/03/21/qtscript</id>
    <content type="html"><![CDATA[<p>Qt从4.3开始, 提供了 <a href="http://zh.wikipedia.org/wiki/ECMAScript">ECMAScript</a> 支持，QtScript 模块提供了一些让 Qt 应用程序脚本化的类. 在 Qt4 中 Webkit 与 QtScript 使用了相同的 javascript 引擎实现.（Qt5 中, javascript 引擎使用了 google 的 V8）</p>

<h2>在 QtScript 中使用信号槽</h2>

<p>Qt Script 可以使用Qt的核心特性: 信号槽. 信号只能存在于 C++ 的代码中, 但槽函数，以及连接的动作可以放到 javascript 中来做</p>

<ol>
<li>C++ 调用 script: 连接 C++ 代码中的信号到 script 函数上. 这个 script 函数可以是 C++ 代码中包含的 script 字符串, 也可以是从文件中读进来的. 如果不想将 QObject 对象泄露到脚本的运行环境中时, 这个方法是非常有用的. 仅仅需要在 script 代码中定义信号需要怎么被响应, 剩下的就是把连接工作放到 C++ 代码里就可以了.</li>
<li>Script 调用 C++: script 可以连接注入到脚本环境中的 C++ 对象的信号和槽, 在这种情况下, 槽函数还是定义在 C++ 代码中, 但是信号和槽的连接完全是动态的（在 script 中完成）</li>
<li>纯script: script 可以定义信号的响应函数句柄, 然后使用句柄建立信号与槽的连接. 比如： script 可以定义一个函数用来响应 <code>QLineEdit::returnPressed()</code> 信号, 然后连接信号与 script 函数.</li>
</ol>


<!-- more -->


<p>使用 <code>qScriptConnect()</code> 函数连接 C++ 信号到 script 函数上. 下面的例子中, handler 用来处理 <code>QLineEdit::textChanged()</code> 信号:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">QScriptEngine</span> <span class="n">eng</span><span class="p">;</span>
</span><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span>
</span><span class='line'><span class="s">&quot;(function(text) { print(&#39;text was changed to&#39;, text); })&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">textChanged</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="p">)),</span> <span class="n">QScriptValue</span><span class="p">(),</span> <span class="n">handler</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>qScriptConnect()</code> 的前两个参数与 <code>QObject::connect()</code> 的完全一致. 第三个参数是 script 对象, 当 signal handler 被调用时, 它充当 <code>this</code> 的角色. 在上面的代码中, 我们传入了一个不可用的值, 此时 <code>this</code> 是全局对象. 第四个参数是 script 函数, 相当于槽函数.
下面的代码展示如何使用 <code>this</code> 参数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'><span class="n">QLineEdit</span> <span class="o">*</span><span class="n">edit2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s">&quot;(function() { print(&#39;I am&#39;, this.name); })&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">obj1</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">newObject</span><span class="p">();</span>
</span><span class='line'><span class="n">obj1</span><span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;the walrus&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QScriptValue</span> <span class="n">obj2</span> <span class="o">=</span> <span class="n">eng</span><span class="p">.</span><span class="n">newObject</span><span class="p">();</span>
</span><span class='line'><span class="n">obj2</span><span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;Sam&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit1</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">returnPressed</span><span class="p">()),</span> <span class="n">obj1</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
</span><span class='line'><span class="n">qScriptConnect</span><span class="p">(</span><span class="n">edit2</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">returnPressed</span><span class="p">()),</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建了两个 <code>QLineEdit</code> 对象, 然后定义了信号响应函数. 信号槽链接使用了相同的响应函数, 但是使用不同的 <code>this</code> 对象, 具体使用哪个, 取决于哪个对象发出信号, 因此 <code>print()</code> 语句输出的内容将会有所不同.</p>

<p>在某个项目中,设计之初曾经考虑过以下的交互方式: javascript 传入 json 对象, 其中某个 value 是匿名 function, 来实现异步调用. 这种方式看起来很美, 也与第一种方式类似, 但是存在问题. C++ 无法获得当前 webkit 的 javascript 运行环境. QtScript 曾考虑过提供 API 来访问 webkit 的 javascript 运行环境, 详细信息可以参考：<a href="https://bugreports.qt-project.org/browse/QTWEBKIT-2">https://bugreports.qt-project.org/browse/QTWEBKIT-2</a>, 但由于种种原因最终放弃了, 不得不说这是个遗憾.</p>

<h2>参考</h2>

<ul>
<li><a href="http://qt-project.org/doc/qt-4.8/qtscript.html">http://qt-project.org/doc/qt-4.8/qtscript.html</a></li>
<li><a href="http://qt-project.org/doc/qt-4.8/scripting.html">http://qt-project.org/doc/qt-4.8/scripting.html</a></li>
<li><a href="http://qt-project.org/doc/qt-4.8/qtwebkit-bridge.html">http://qt-project.org/doc/qt-4.8/qtwebkit-bridge.html</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
