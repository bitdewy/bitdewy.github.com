
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Bitdewy</title>
	<meta name="author" content="bitdewy">

	
	<meta name="description" content="看下面的声明，很和谐 1
int x; 等等，擦. 忘记初始化了，所以它的值是不确定的。也许，它可能会被初始化成 0。但是很遗憾这是不确定的。 再看看，解引用一个迭代器来初始化局部变量的例子： 1
2
3
4
5
6
7
8
template &lt;typename It&gt; // &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Bitdewy" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">Bitdewy</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:bitdewy.github.com">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		<a class="facebook" href="http://www.facebook.com/bitdew" title="Facebook">Facebook</a>
		
		
		<a class="google" href="https://plus.google.com/102998539730080432817?rel=author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/bitdewy" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/bitdewy" title="GitHub">GitHub</a>
		
    
		
		
		<a class="linkedin" href="http://www.linkedin.com/in/bitdewy">LinkedIn</a>
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:bitdewy.github.com">
	</form>
</nav>

</header>
	
		
<div id="banner" class="inner">
	<div class="container">
		<ul class="feed"></ul>
	</div>
	<small><a href="http://twitter.com/bitdewy">bitdewy</a> @ <a href="http://twitter.com">Twitter</a></small>
	<div class="loading">Loading...</div>
</div>
<script src="/javascripts/twitter.js"></script>
<script type="text/javascript">
	(function($){
		$('#banner').getTwitterFeed('bitdewy', 4, false);
	})(jQuery);
</script>

	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/11/12/emcpp-item-5/">
		
			[译] Item 5: Prefer Auto to Explicit Type Declarations.</a>
	</h2>
	<div class="entry-content">
		<p>看下面的声明，很和谐</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>等等，擦. 忘记初始化了，所以它的值是不确定的。也许，它可能会被初始化成 0。但是很遗憾这是不确定的。</p>

<p>再看看，解引用一个迭代器来初始化局部变量的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>  <span class="c1">// algorithm to dwim (&quot;do what I mean&quot;)</span>
</span><span class='line'><span class="kt">void</span> <span class="n">dwim</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">)</span>   <span class="c1">// for all elements in range from</span>
</span><span class='line'><span class="p">{</span>                       <span class="c1">// b to e</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">currValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'>      <span class="c1">// ...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>呃，用 <code>typename std::iterator_traits&lt;It&gt;::value_type</code> 来表示迭代器所指向的值？这样真的没问题嚒？</p>

<p>再来，如果我们想要一个闭包类型的局部变量。哦，好吧。只有编译器才知道这个闭包是什么类型，我们根本无法写出这个类型。</p>

<p>擦，擦，擦。C++ 写起来还真是头疼。没错，不过那都是过去了。有了 C++11 之后，这些问题都不存在了，我们有了 <code>auto</code>。<code>auto</code> 类型会根据初始化自动推导，所以它们必须被初始化。这意味着在现代 C++ 中你可以和那些变量未初始化的问题挥手说拜拜了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x1</span><span class="p">;</span>        <span class="c1">// potentially uninitialized</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x2</span><span class="p">;</span>       <span class="c1">// error! initializer required</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// fine, x&#39;s valye is well-defined</span>
</span></code></pre></td></tr></table></div></figure>


<p>迭代器解引用初始化局部变量也可以这么来写了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>  <span class="c1">// as before</span>
</span><span class='line'><span class="kt">void</span> <span class="n">dwim</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">auto</span> <span class="n">currValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'>      <span class="c1">// ...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



		
		<a href="/blog/2014/11/12/emcpp-item-5/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-12T15:55:00+08:00" pubdate data-updated="true">Nov 12<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/effective-modern-c-plus-plus/'>Effective Modern C++</a>


</div>
	
	<div class="comments"><a href="/blog/2014/11/12/emcpp-item-5/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/11/04/emcpp-item-4/">
		
			[译] Item 4: Know How to View Deduced Types</a>
	</h2>
	<div class="entry-content">
		<p>如何选择查看类型推导结果的工具依赖于你想在开发的那个阶段查看这个类型信息。下面来介绍三种可能的情况，编辑代码时，编译过程中，以及运行时。</p>

<h3>IDE 编辑器</h3>

<p>当你将鼠标移动到某处代码时，IDE 编辑器通常都会显示出类型（比如，变量，参数，函数的类型等），例如下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">theAnswer</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">theAnswer</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">theAnswer</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>IDE 编辑器应该显示变量 <code>x</code> 的类型是 <code>int</code>，变量 <code>y</code> 的类型是 <code>const int*</code>。</p>

<p>要让上面的情况可以工作，你的代码必须是可编译的，因为编辑器之所以能够提示出变量的类型，是因为已经有足够的信息供它内部的编译器（或者至少是编译器前端）来做类型推导的工作。如果信息不足够供编译器做类型推导的话，那么变量类型是不会提示出来的。</p>

<p>对于像 <code>int</code> 一样的简单类型，IDE 生成的信息通常都是正确的。但是对于更复杂的情况，就像后面我们将看到的一样，IDE 生成的信息也许就不是那么有帮助了。</p>

<h3>编译器诊断</h3>

<p>让编译器提示类型推导的类型的一个有效的办法是，用这个类型构造一个编译失败的错误。编译错误的信息会告诉你这个类型。</p>

<p>考虑之前的例子，我们想看一看 <code>x</code> 和 <code>y</code> 的类型。首先我们声明一个未定义的模板类，它看起来应该是下面这样；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>    <span class="c1">// declaration only for TD;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">TD</span><span class="p">;</span>                <span class="c1">// TD == &quot;Type Displayer&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>企图实例化这个模板会产生错误，因为这个模板类我们根本就没有定义。接下来，想要看 <code>x</code> 和 <code>y</code> 的类型，我们只需要用它们的类型实例化 TD 就可以了；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">TD</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">xType</span><span class="p">;</span>    <span class="c1">// elicit errors containing</span>
</span><span class='line'><span class="n">TD</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">yType</span><span class="p">;</span>    <span class="c1">// x&#39;s and y&#39;s types;</span>
</span><span class='line'>                          <span class="c1">// see Item 3 for info on decltype</span>
</span></code></pre></td></tr></table></div></figure>



		
		<a href="/blog/2014/11/04/emcpp-item-4/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-04T14:55:00+08:00" pubdate data-updated="true">Nov 4<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/effective-modern-c-plus-plus/'>Effective Modern C++</a>


</div>
	
	<div class="comments"><a href="/blog/2014/11/04/emcpp-item-4/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/10/21/emcpp-item-3/">
		
			[译] Item 3: Understand Decltype</a>
	</h2>
	<div class="entry-content">
		<p><code>decltype</code> 是一个奇怪的发明。给一个名字或者表达式，<code>decltype</code> 可以告诉你这个名字或者表达式的类型。通常的情况下，他告诉你的都是你预期的。但是偶尔也会有些出人意料。</p>

<p>我们从最典型的情况开始 —— 那些不会让你惊奇的情况。与模板类型推导和 <code>auto</code> 类型推导不同，<code>decltype</code> 通常只是鹦鹉学舌般的返回你传入的名字或表达式的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// decltype(i) is const int</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>    <span class="c1">// decltype(w) is const Widget&amp;</span>
</span><span class='line'>                            <span class="c1">// decltype(f) is bool(const Widget&amp;)</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>               <span class="c1">// decltype(Point::x) is int</span>
</span><span class='line'><span class="p">};</span>                          <span class="c1">// decltype(Point::y) is int</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>                   <span class="c1">// decltype(w) is Widget</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="p">{</span>                 <span class="c1">// decltype(f(w)) is bool</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>        <span class="c1">// simplified version of std::vector</span>
</span><span class='line'><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>              <span class="c1">// decltype(v) is vector&lt;int&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>            <span class="c1">// decltype(v[0]) is int&amp;</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是完全没有惊喜？</p>


		
		<a href="/blog/2014/10/21/emcpp-item-3/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-10-21T14:55:00+08:00" pubdate data-updated="true">Oct 21<span>st</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/effective-modern-c-plus-plus/'>Effective Modern C++</a>


</div>
	
	<div class="comments"><a href="/blog/2014/10/21/emcpp-item-3/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/09/18/emcpp-item-2/">
		
			[译] Item 2: Understand Auto Type Deduction</a>
	</h2>
	<div class="entry-content">
		<p>如果你已经阅读了 Item 1 模板类型推导，那么你应该已经掌握了 <code>auto</code> 的类型推导，出了下面要讲到的一个不同之外，其他都和 Item 1 完全一致，但是你肯定还有疑问，为什么模板类型推导涉及到了模板，函数以及参数，而 <code>auto</code> 却不涉及这些。</p>

<p>没错，但是这也没什么关系。其实模板类型推导与 <code>auto</code> 类型推导有直接的映射关系。有很直观的转换关系。</p>

<p>在 Item 1 中，我们使用下面的模板函数用来描述模板类型推导，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span> <span class="p">(</span><span class="n">expr</span><span class="p">);</span>    <span class="c1">// call f with some expression</span>
</span></code></pre></td></tr></table></div></figure>


<p>在调用函数 <code>f</code> 时，编译器使用表达式 <code>expr</code> 来推导类型 <code>T</code> 和 <code>ParamType</code>。</p>

<p>当使用 <code>auto</code> 来声明变量时，<code>auto</code> 代替了上面 <code>T</code> 的位置，同时变量的类型就是 <code>ParamType</code> 的类型。看下面的例子会更直观，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，变量 <code>x</code> 的类型标识符就是一个简单的 <code>auto</code>，在</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>中，类型标识符是 <code>const auto</code>，在</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>中，类型标识符是 <code>const auto&amp;</code>。推导上面 <code>x</code>, <code>cx</code> 以及 <code>rx</code> 的类型，编译器所做的事情就像是有一个模板函数一样，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_x</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>           <span class="c1">// conceptual template for deducing x&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_x</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is x&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_cx</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// conceptual template for deducing cx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_cx</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is cx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">func_for_rx</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>   <span class="c1">// conceptual template for deducing rx&#39;s type</span>
</span><span class='line'>
</span><span class='line'><span class="n">func_for_rx</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                     <span class="c1">// conceptual call: param&#39;s deduced type is rx&#39;s type</span>
</span></code></pre></td></tr></table></div></figure>





		
		<a href="/blog/2014/09/18/emcpp-item-2/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-09-18T23:04:00+08:00" pubdate data-updated="true">Sep 18<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/effective-modern-c-plus-plus/'>Effective Modern C++</a>


</div>
	
	<div class="comments"><a href="/blog/2014/09/18/emcpp-item-2/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/08/23/emcpp-item-1/">
		
			[译] Item 1: Understand Template Type Deduction</a>
	</h2>
	<div class="entry-content">
		<p>在使用一个复杂的系统时，我们可以不用知道具体的细节。从这个方面来说，C++ 的模板类型推导是很成功的。数以百万的程序员都使用过模板，即使他们可能很难描述清楚这些类型是如何推导的。</p>

<p>如果你是其中的一员，我有一个好消息，也有一个坏消息。好消息是，模板类型推导是最引人注目的 C++11 新特性 <code>auto</code> 的基础。如果你很清楚 C++98 中的模板类型推导，那么你会很容易明白 C++11 中的 <code>auto</code>。坏消息是，当使用 <code>auto</code> 时，有些类型推导会变得没有那么直观。因此完全掌握类型推导的规则是非常有必要的。Item 1 会介绍你必须知道的类型推导规则。</p>

<p>我们从一小段伪代码开始：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">f</span> <span class="p">(</span><span class="n">expr</span><span class="p">);</span>    <span class="c1">// call f with some expression</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编译期间，编译器使用表达式 <code>expr</code> 来推导两个类型：一个是 <code>T</code> 另一个是 <code>ParamType</code>。这两个类型通常是不一样的，因为 <code>ParamType</code> 通常是含有修饰的，比如 <code>const</code> 或者引用。举个例子，如果模板的声明如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// ParamType is const T&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后调用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>    <span class="c1">// call f with an int</span>
</span></code></pre></td></tr></table></div></figure>


<p>类型 <code>T</code> 会被推导为 <code>int</code>，而 <code>ParamType</code> 被推导为 <code>const int&amp;</code>。</p>

<p>将类型 <code>T</code> 推导为传入的参数类型是很自然的，即 <code>T</code> 的类型就是 <code>expr</code> 的类型。在上面的例子中，<code>x</code> 是 <code>int</code> 类型，<code>T</code> 被推导为 <code>int</code> 类型。但是有时候却不是这样的。类型推导不仅仅依赖于表达式 <code>expr</code> 的类型，同时还依赖于 <code>ParamType</code> 的形式。有下面三种情况：</p>

<ul>
<li>ParamType 是一个指针或者引用类型，但是不是全局引用。（全局引用将会在 Item 24 中讲述。现在你只需要知道他不同于引用，也不同于右值引用即可）。</li>
<li>ParamType 是一个全局引用。</li>
<li>ParamType 即不是指针也不是引用</li>
</ul>



		
		<a href="/blog/2014/08/23/emcpp-item-1/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-08-23T00:04:00+08:00" pubdate data-updated="true">Aug 23<span>rd</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/effective-modern-c-plus-plus/'>Effective Modern C++</a>


</div>
	
	<div class="comments"><a href="/blog/2014/08/23/emcpp-item-1/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/07/21/effective-modern-cpp-preview/">
		
			《Effecticve Modern C++》预览</a>
	</h2>
	<div class="entry-content">
		<p>虽然最近工作在用 javascript, 但 C++ 也没放下, <a href="http://www.aristeia.com">Scott Meyers</a> 的新书《Effective modern C++》终于在 O&#8217;Reilly <a href="http://shop.oreilly.com/product/0636920033707.do">上架了</a>. 第一时间买了一本. 2年前的时候, <a href="http://www.aristeia.com">Scott</a> 就给了<a href="http://blog.bitdewy.me/blog/2012/06/24/effective-c-plus-plus-11/">一版</a> Effective C++11 的初步想法, 两年后的今天, 顺带着 C++14 终于正式出炉了, 不过目前还是 early release 版本, 还没有经过 review, 正式版要到年底才会放出.</p>

<p>不得不说, C++ 现在终于有了它该有的样子. 大致浏览了一下, 如果现在才开始关注 C++11/C++14 的话, 非常推荐这本书. 如果看过前两代 《Effective C++》和《More effective C++》的话, 那你会再次找到久违的感觉.</p>

<p>全书共分为 6 章, 包括: 类型推导, 新关键字 auto, C++98 到 C++11/14 的变化, 智能指针, 右值引用转移语义与完美转发, lambda 表达式, 并发 API.</p>

<p>关于类型推导, 由于 C++11/14 引入了新的关键字 <code>auto</code>, <code>decltype</code>, 以及新的概念右值引用, 那么类型推导就不仅仅存在于模板中了, 因此从现在开始掌握类型推导的规则是 C++ 的必备技能了.</p>

<p>C++11/14 和以前相比, 变化非常的大, 在这本书中, 用了近 1/3 的章节来讲述如何从 C++98 过度到 C++11/14. 有些甚至推翻了之前的推荐做法, 比如 Item 13: Prefer const_iterators to iterators 就与作者之前的 《Effective STL》中的 item 26 完全相反. 所以对于每个写 C++ 代码的人来说, 这一部分是必须要更新的知识.</p>

<p>对于智能智能, 相信大家早就不陌生, 作者的《More Effective C++》中也讲到了智能指针. 这一次, 终于成为了标准, 本书中也讲到了各种类型智能指针合适的使用场景, 掌握了这些之后, 相信资源管理的问题, 就能够减少很多了.</p>

<p>转移语义很好的解决了性能问题, 完美转发解决了模板函数重载时爆炸式增长的问题, 而右值引用就是这两个特性的基础. 对于那些写库的人来说, 这些特性真是天大的好事.</p>

<p>关于 lambda 表达式, 有了 lambda 表达式, 标准库中的那些算法终于能变得好用了. 在没有 lambda 之前, 在使用每个标准库算法之前, 还需要一个仿函数, 这是一件多么不爽的事情.</p>

<p>对于并发, 在 C++98 以及之前, 标准连多线程的概念都没有, 我们只能使用平台相关的多线程设施, 甚至一些我们觉得没问题的多线程模型都会在这种情况下出问题. (比如: 这篇<a href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">C++ and the Perils of Double-Checked Locking</a>) 现在标准中不仅有了 thread, 甚至还有了更高级的 task, future, promise. 当然如果能有 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">Resumable Functions</a> 就更好了, 不过这个特性可能要等到 C++17 了.</p>


		
		<a href="/blog/2014/07/21/effective-modern-cpp-preview/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-07-21T22:14:00+08:00" pubdate data-updated="true">Jul 21<span>st</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>C++</a>


</div>
	
	<div class="comments"><a href="/blog/2014/07/21/effective-modern-cpp-preview/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/06/29/why-yield/">
		
			Javascript New Keyword: Yield</a>
	</h2>
	<div class="entry-content">
		<h2>生成器与迭代器</h2>

<p>在以前写代码的时候, 涉及到迭代算法时, 通常整个过程中都需要维护一个状态变量, 而我们想使用迭代算法的中间值得时候, 不得不使用回调函数.</p>

<p>下面是一个斐波那契数列的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">do_callback</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">fib</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">do_callback</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">j</span> <span class="o">+=</span> <span class="nx">t</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">n</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">fib</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中使用了回调函数, 将小于 10 的斐波那契数列的元素输出到控制台.</p>

<p>迭代器和生成器提供了一个新的, 更好的途径来做同样的事情. 下面是使用生成器实现的代码:</p>


		
		<a href="/blog/2014/06/29/why-yield/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-06-29T22:14:00+08:00" pubdate data-updated="true">Jun 29<span>th</span>, 2014</time></div>
	<div class="tags">

</div>
	
	<div class="comments"><a href="/blog/2014/06/29/why-yield/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/15/korea-seoul/">
		
			首尔-釜山-青岛8日游</a>
	</h2>
	<div class="entry-content">
		<p>五一假期请了 3 天假, 和几个比较好的朋友一起韩国自由行. (原本预谋好的是台湾自由行, 但是由于小伙伴的证件问题, 只能换了路线 ╮(╯▽╰)╭)</p>

<p>出国当然必备护照, 据说有小伙伴办护照填表格瞎填一通, 还被带到了小黑屋.( ⊙ o ⊙ ). 大家要小心千万不要乱填哈. 关于护照可以参考<a href="http://blog.bitdewy.me/blog/2014/01/28/passport/">这里</a>.</p>

<p>韩国签证还是比较容易办理, 如果没时间去领事馆的话淘宝花 300 块钱左右就可以代办了, 不需要本人办理, 不需要面签.</p>

<p>酒店在国内提前订好, 回避广告, 就不说在哪里定的了, 行程安排是 首尔-釜山-首尔 各住 2 晚. 人均 200 CNY/天. 釜山便宜一些, 首尔较贵, 但住的都不差. 如果能稍微提高一点点预算的话, 能住的非常好呢.</p>

<p>特别安排了 首尔-釜山-首尔 的路线, 坐了韩国的 KTX 高铁, 对外国游客韩国有 KR PASS, 可以直接在网站上预定. 定了 3 日票, 3 日内可以韩国火车随便乱坐, 虽然我们只坐了 首尔-釜山 的往返, 但也比直接买票划算不少. 关于 KR PASS 还差点搞出乌龙, KR PASS 有普通票和同行票, 同行票需要一个普通票带着才可以, 一张普通票最多可以带 5 个同行票(大概是 9 折左右的优惠), 差点全都买成同行票, 还好在出发前又重新定好. 人均 520 CNY.</p>

<p>作为马斯洛需求体系最底层的 WiFi 需求, 当然要提前做好工作, 由于不通韩语, 英语又没信心 ╮(╯▽╰)╭, 最终决定在国内定 wifi egg(3G路由), 国内还. 40CYN/天. 如果是韩国取韩国还的话, 还能再便宜一些. 但是作为一个极度缺乏安全感的人来说, 还是选择了多花一点点钱, 保证万无一失. ^_^</p>

<p>虽然做了不少准备工作, 也还是有不少 bug, 同行的小伙伴没有一个人用的是 中国电信, 而韩国只有 CMDA2000, 导致大家电话都无法使用, 不过 7-11 就有卖电话卡, 也不是什么大问题. 但是毕竟出门在外, 避免有了信号大家乱跑, 最终还是一致决定所有人都紧紧围绕在 WiFi egg 周围, 保持队形.(<em>^__^</em>) 不分开.</p>

<p>最后就是机票了, 往返机票大约 2400 CNY/人. 国际机票税比较高. 提前一个月定的机票, 如果再提前一些的话可能还会更便宜.</p>

<p>废话结束.</p>


		
		<a href="/blog/2014/05/15/korea-seoul/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-05-15T22:57:00+08:00" pubdate data-updated="true">May 15<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/travel/'>travel</a>


</div>
	
	<div class="comments"><a href="/blog/2014/05/15/korea-seoul/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/03/09/front-end-web-development-quiz-part1-css/">
		
			Web 前端开发小测验, Part 1 之 CSS</a>
	</h2>
	<div class="entry-content">
		<p>这是 <a href="http://www.devqin.com/">@devqin</a> 在 <a href="http://bb.ijser.cn/topic/46/%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E5%BE%97%E5%88%B0%E5%A4%9A%E5%B0%91%E5%88%86-%E8%87%AA%E6%88%91%E6%84%9F%E8%A7%89%E8%89%AF%E5%A5%BD%E8%80%85%E8%8E%AB%E5%85%A5-%E5%9B%A0%E4%B8%BA-%E5%AE%98%E6%96%B9%E8%AF%B4%E7%9A%84%E6%98%AF-maight-hurt-your-feelings">NADbb</a> 上发的一个找虐的测试. (原作者有个提示: Warning: might hurt your feelings).</p>

<p>我来挨个找证据, 今天是 part 1, CSS 部分.</p>

<h4>1)</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">ul</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">MaRGin</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Are CSS property names case-sensitive?</p>

<p>CSS 属性名是大小写敏感的吗 ?</p>

<p><strong>答</strong>: 不敏感. <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 的 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#forward-compatible-parsing">7.1 Forward-compatible parsing</a> 最后有这么一段话,</p>

<blockquote><p>All CSS style sheets are case-insensitive, except for parts that are not under the control of CSS. I.e., in CSS1, font family names and URLs can be case-sensitive. Also, the case-sensitivity of the CLASS and ID attributes is under the control of HTML.</p></blockquote>

<p>因此, 只有不受 CSS 控制的, 如 <code>font family</code> 的名字, <code>url</code>, 以及受 <code>HTML</code> 控制的 <code>ID</code> 和 <code>class</code> 大小写敏感, 其他受 CSS 控制的内容都是大小写不敏感的.</p>

<h4>2) Does setting <code>margin-top</code> and <code>margin-bottom</code> have an affect on an inline element ?</h4>

<p><code>margin-top</code> 与 <code>margin-bottom</code> 对内联元素是否有效 ?</p>

<p><strong>答</strong>: 没效果, <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/">Cascading Style Sheets, level 1</a> 的 <a href="http://www.w3.org/TR/2008/REC-CSS1-20080411/#inline-elements">4.2 Inline elements</a> 中有如下描述:</p>

<blockquote><p>If the inline element has margins, borders, padding or text decorations attached, these will have no effect where the element is broken.</p></blockquote>

<p>CSS2.1 中, <a href="http://www.w3.org/TR/CSS21/box.html#propdef-margin-bottom">8.3 Margin properties: &lsquo;margin-top&rsquo;, &lsquo;margin-right&rsquo;, &lsquo;margin-bottom&rsquo;, &lsquo;margin-left&rsquo;, and &lsquo;margin&rsquo;</a> 节关于 <code>margin-top</code> 和 <code>margin-bottom</code> 有如下描述:</p>

<blockquote><p>These properties have no effect on non-replaced inline elements.</p></blockquote>

<p>关于 non-replaced 与 replaced element 的定义可以参考 CSS2.1 中的 <a href="http://www.w3.org/TR/CSS21/conform.html#replaced-element">Replaced element</a></p>

<h4>3) Does setting <code>padding-top</code> and <code>padding-bottom</code> on an inline element add to its dimensions ?</h4>


		
		<a href="/blog/2014/03/09/front-end-web-development-quiz-part1-css/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-03-09T01:30:00+08:00" pubdate data-updated="true">Mar 9<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/css/'>css</a>, <a class='category' href='/blog/categories/web/'>web</a>


</div>
	
	<div class="comments"><a href="/blog/2014/03/09/front-end-web-development-quiz-part1-css/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/01/28/passport/">
		
			护照, 往来港澳通行证以及大陆居民往来台湾地区通行证办理记录</a>
	</h2>
	<div class="entry-content">
		<p>首先, 吐槽一下, 在自己国家的土地上都不能自由通行, 还需要办理各种证件. (╯‵□′)╯︵┻━┻</p>

<p>以西安为例, 西安市出入境管理中心在科技路二号(西斜七路十字西南角), 工作时间为法定工作日 9:00-17:00. 据说中午有休息时间. 由于本人 14:50 才到, 中午休息时间未知. (如果一次性需要办多个证件, 需要填多张表格, 所以即使中午休息时间到也没有关系, 领表格自行填写, 填写完之后再办手续).</p>

<p>表格的填写一般都有样例, 不过样例可能已经与现在填写的版本不一致, 这个不用担心, 主要填写基本信息, 不知如何填写的可以留空. 办理时, 工作人员会最后确认的. (这次给我办理的是个制服美女. O(∩_∩)O 哈哈~ 跑题了.</p>

<h2>护照</h2>

<p>护照是一个国家的公民出入本国国境和到国外旅行或居留时, 由本国发给的一种证明该公民国籍和身份的合法证件. 没有护照是没法出国的. 目前对大陆免签的国家非常少啊, 非常少. (╯‵□′)╯︵┻━┻</p>

<p>护照申请表格一式一份 2 张, 需要本人填写的只有一些基本信息, 办理过程需要录入指纹, 申请表格有一栏是需要工作人员确认信息完成后, 当面签字的. 如果需要邮寄的话, 需要在最后填写邮寄地址. 如果旧护照已过期, 那么与首次申请办理护照没有区别, 旧护照可以自己留作纪念.</p>

<h2>往来港澳通行证</h2>

<p>内地居民因私往来香港或澳门特别行政区旅游, 探亲, 从事商务, 培训, 就业等非公务活动, 向户口所在地的市, 县公安出入境管理部门提出申请, 凭公安出入境管理部门签发的往来港澳通行证及有效签注才能前往.</p>

<p>如果持有大陆护照, 以及入台的各种证件, 和香港转机机票, 则不需要往来港澳通行证即可在港澳最多停留 7 日.</p>

<p>由于西安目前还不是港澳自由行的城市, 因此还不能办理个人 G 签, 只能办理团队 L 签. 如果只想去香港, 那么只能从深圳找当地旅行团协助过关. 至于有效期及签注次数个人自行选择. 本人选择的是澳门 1 次有效签注, 有效期 1 年. 香港 2 次有效签注, 有效期 1年.</p>

<p>往来港澳通行证申请表格一式一份 1 张, 除了基本信息, 需要注意的是申请的签注类型, 首选个人 G 签, 如果所在城市不支持, 那工作人员会自动帮助你更改为团队 L 签. 如果需要邮寄的话, 需要在最后填写邮寄地址.</p>


		
		<a href="/blog/2014/01/28/passport/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-01-28T19:20:00+08:00" pubdate data-updated="true">Jan 28<span>th</span>, 2014</time></div>
	<div class="tags">

</div>
	
	<div class="comments"><a href="/blog/2014/01/28/passport/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    bitdewy

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'bitdewy';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>