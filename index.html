
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Bitdewy</title>
	<meta name="author" content="bitdewy">

	
	<meta name="description" content="首先, 吐槽一下, 在自己国家的土地上都不能自由通行, 还需要办理各种证件. (╯‵□′)╯︵┻━┻ 以西安为例, 西安市出入境管理中心在科技路二号(西斜七路十字西南角), 工作时间为法定工作日 9:00-17:00. 据说中午有休息时间. 由于本人 14:50 才到, 中午休息时间未知. ( &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Bitdewy" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">Bitdewy</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:bitdewy.github.com">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		<a class="facebook" href="http://www.facebook.com/bitdew" title="Facebook">Facebook</a>
		
		
		<a class="google" href="https://plus.google.com/102998539730080432817?rel=author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/bitdewy" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/bitdewy" title="GitHub">GitHub</a>
		
    
		
		
		<a class="linkedin" href="http://www.linkedin.com/in/bitdewy">LinkedIn</a>
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:bitdewy.github.com">
	</form>
</nav>

</header>
	
		
<div id="banner" class="inner">
	<div class="container">
		<ul class="feed"></ul>
	</div>
	<small><a href="http://twitter.com/bitdewy">bitdewy</a> @ <a href="http://twitter.com">Twitter</a></small>
	<div class="loading">Loading...</div>
</div>
<script src="/javascripts/twitter.js"></script>
<script type="text/javascript">
	(function($){
		$('#banner').getTwitterFeed('bitdewy', 4, false);
	})(jQuery);
</script>

	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/01/28/passport/">
		
			护照, 往来港澳通行证以及大陆居民往来台湾地区通行证办理记录</a>
	</h2>
	<div class="entry-content">
		<p>首先, 吐槽一下, 在自己国家的土地上都不能自由通行, 还需要办理各种证件. (╯‵□′)╯︵┻━┻</p>

<p>以西安为例, 西安市出入境管理中心在科技路二号(西斜七路十字西南角), 工作时间为法定工作日 9:00-17:00. 据说中午有休息时间. 由于本人 14:50 才到, 中午休息时间未知. (如果一次性需要办多个证件, 需要填多张表格, 所以即使中午休息时间到也没有关系, 领表格自行填写, 填写完之后再办手续).</p>

<p>表格的填写一般都有样例, 不过样例可能已经与现在填写的版本不一致, 这个不用担心, 主要填写基本信息, 不知如何填写的可以留空. 办理时, 工作人员会最后确认的. (这次给我办理的是个制服美女. O(∩_∩)O 哈哈~ 跑题了.</p>

<h2>护照</h2>

<p>护照是一个国家的公民出入本国国境和到国外旅行或居留时, 由本国发给的一种证明该公民国籍和身份的合法证件. 没有护照是没法出国的. 目前对大陆免签的国家非常少啊, 非常少. (╯‵□′)╯︵┻━┻</p>

<p>护照申请表格一式一份 2 张, 需要本人填写的只有一些基本信息, 办理过程需要录入指纹, 申请表格有一栏是需要工作人员确认信息完成后, 当面签字的. 如果需要邮寄的话, 需要在最后填写邮寄地址. 如果旧护照已过期, 那么与首次申请办理护照没有区别, 旧护照可以自己留作纪念.</p>

<h2>往来港澳通行证</h2>

<p>内地居民因私往来香港或澳门特别行政区旅游, 探亲, 从事商务, 培训, 就业等非公务活动, 向户口所在地的市, 县公安出入境管理部门提出申请, 凭公安出入境管理部门签发的往来港澳通行证及有效签注才能前往.</p>

<p>如果持有大陆护照, 以及入台的各种证件, 和香港转机机票, 则不需要往来港澳通行证即可在港澳最多停留 7 日.</p>

<p>由于西安目前还不是港澳自由行的城市, 因此还不能办理个人 G 签, 只能办理团队 L 签. 如果只想去香港, 那么只能从深圳找当地旅行团协助过关. 至于有效期及签注次数个人自行选择. 本人选择的是澳门 1 次有效签注, 有效期 1 年. 香港 2 次有效签注, 有效期 1年.</p>

<p>往来港澳通行证申请表格一式一份 1 张, 除了基本信息, 需要注意的是申请的签注类型, 首选个人 G 签, 如果所在城市不支持, 那工作人员会自动帮助你更改为团队 L 签. 如果需要邮寄的话, 需要在最后填写邮寄地址.</p>


		
		<a href="/blog/2014/01/28/passport/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-01-28T19:20:00+08:00" pubdate data-updated="true">Jan 28<span>th</span>, 2014</time></div>
	<div class="tags">

</div>
	
	<div class="comments"><a href="/blog/2014/01/28/passport/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/01/19/gotw-95/">
		
			[译]GotW #95 Solution: Thread Safety and Synchronization</a>
	</h2>
	<div class="entry-content">
		<p><em>原文地址: <a href="http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/">GotW #95 Solution: Thread Safety and Synchronization</a></em></p>

<p><em>这篇 GotW 是来回答一些关于线程安全与同步的问题的. 我们的讨论几乎适用于所有主流语言</em></p>

<h1>问题</h1>

<h2>JG 问题</h2>

<p><strong>1) 竞态条件(race condition)指的是什么? 它有很严重吗?</strong></p>

<p><strong>2) 什么是正确同步的程序? 你是如何实现的? 请具体说明.</strong></p>

<h2>Guru 问题</h2>

<p><strong>3) 考虑下面的代码, <code>some_obj</code> 是一个多个线程可见的共享变量.</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// thread 1 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_reads_from</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>  <span class="c1">// passes some_obj by const &amp;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// thread 2 (performs no additional synchronization)</span>
</span><span class='line'><span class="n">code_that_modifies</span><span class="p">(</span> <span class="n">some_obj</span> <span class="p">);</span>    <span class="c1">// passes some_obj by non-const &amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>如果线程 1 与线程 2 能够并行, 那么当 <code>some_ojb</code> 是如下类型时, 代码是否能够正确同步?</strong></p>

<ul>
<li>a) <code>int</code></li>
<li>b) <code>string</code></li>
<li>c) <code>vector&lt;map&lt;int,string&gt;&gt;</code></li>
<li>d) <code>shared_ptr&lt;widget&gt;</code></li>
<li>e) <code>mutex</code></li>
<li>f) <code>condition_variable</code></li>
<li>g) <code>atomic&lt;unsigned&gt;</code></li>
</ul>


<p><strong>提示: 虽然有 7 个类型, 但实际上答案只有两种.</strong></p>

<p><strong>4) 外部同步, 意味着使用共享对象的代码需要自己来保证对象的同步. 回答下面有关外部同步的问题:</strong></p>

<ul>
<li>a) 一般的外部同步的职责是什么?</li>
<li>b) 什么是&#8221;基本的线程安全保障&#8221;?</li>
<li>c) 哪些内部同步是在共享变量的实现中需要做的?</li>
</ul>


<p><strong>5) 完全的内部同步类型(线程安全类型), 意味着所有的同步在对象内部完成, 外部不需要再进行同步. 哪些类型是内部同步的, 为什么?</strong></p>


		
		<a href="/blog/2014/01/19/gotw-95/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-01-19T23:54:00+08:00" pubdate data-updated="true">Jan 19<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>C++</a>, <a class='category' href='/blog/categories/gotw/'>GotW</a>


</div>
	
	<div class="comments"><a href="/blog/2014/01/19/gotw-95/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/01/12/why-make-shared/">
		
			Why Make_shared ?</a>
	</h2>
	<div class="entry-content">
		<p>C++11 中引入了智能指针, 同时还有一个模板函数 <code>std::make_shared</code> 可以返回一个指定类型的 <code>std::shared_ptr</code>, 那与 <code>std::shared_ptr</code> 的构造函数相比它能给我们带来什么好处呢 ?</p>

<h2>优点</h2>

<h3>效率更高</h3>

<p><code>shared_ptr</code> 需要维护引用计数的信息,</p>

<ul>
<li>强引用, 用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放).</li>
<li>弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话).</li>
</ul>


<p>如果你通过使用原始的 new 表达式分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">widget</span><span class="p">();</span>
</span><span class='line'><span class="n">shared_ptr</span> <span class="n">sp1</span><span class="p">{</span> <span class="n">p</span> <span class="p">},</span> <span class="n">sp2</span><span class="p">{</span> <span class="n">sp1</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://y6bhba.bay.livefilestore.com/y1pDu8kORu85CKSKHFVBvapxrccVoMAjc8W0d6mScWwunuhqV8n25QZKgZhM6MPtFGV1c6dPgjil7g/sharedptr1.png" alt="" /></p>

<p>如果选择使用 <code>make_shared</code> 的话, 情况就会变成下面这样:</p>


		
		<a href="/blog/2014/01/12/why-make-shared/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-01-12T21:01:00+08:00" pubdate data-updated="true">Jan 12<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>C++</a>


</div>
	
	<div class="comments"><a href="/blog/2014/01/12/why-make-shared/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/01/06/windows-api-raii/">
		
			当 Windows API 遇上 RAII</a>
	</h2>
	<div class="entry-content">
		<h2>什么是 RAII (Resource Acquisition Is Initialization) ?</h2>

<p>RAII (Resource Acquisition Is Initialization), 也称为&#8221;资源获取就是初始化&#8221;, 是 C++ 语言的一种管理资源, 避免泄漏的惯用法. C++ 标准保证任何情况下, 已构造的对象最终会销毁, 即它的析构函数最终会被调用. 简单的说, RAII 的做法是使用一个对象, 在其构造时获取资源, 在对象生命期控制对资源的访问使之始终保持有效, 最后在对象析构的时候释放资源.</p>

<p>RAII 是保证代码异常安全的重要基础设施. RAII 的使用场景有很多, 如: C++11 中的智能指针, scope lock, scope exit 等等. (早在2000年，<a href="http://erdani.com/">Andrei Alexandrescu</a> 就在DDJ杂志上发表了一篇文章，提出了这个叫做 <a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758">ScopeGuard</a> 的设施)</p>

<h2>当 Windows API 遇上 RAII</h2>

<p>Windows API 大多是 C 语言风格的函数和句柄, 或者是 COM 风格的接口, 这些用起来都不太方便, 需要进行一定的封装. 至于为什么要封装就不用多说了, 如果你想要异常安全, 想要不必在每个分支中都写清理代码的话, 你一定知道利用 RAII 封装的意义.</p>

<p>ATL 中有对 COM 接口的封装, 智能指针 <code>CComPtr</code>, <code>CComQIPtr</code> 解决了一遍遍的手工 <code>Release</code> 以及 <code>QueryInterface</code>. 但对于普通的 C 语言风格的函数和句柄呢? 难道还要一遍遍的 <code>CloseHandle</code> , <code>ReleaseDC</code>, <code>GlobalUnlock</code> 麽? 弱爆了.</p>

<p>借助 <code>ScopeGuard</code> 和 lambda 表达式(⊙_⊙)？ 可以是可以, 但是并不是所有的资源获取都会成功, 那么每次都要产生一个具名的 <code>ScopeGuard</code>, 在申请失败的时候调用 <code>Dismiss</code>, 取消清理的动作嘛? 像这样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Acquire</span> <span class="n">Resource1</span>
</span><span class='line'><span class="n">ScopeGuard</span> <span class="n">release1</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource1 */</span> <span class="p">})</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">release1</span><span class="p">.</span><span class="n">Dismiss</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Acquire</span> <span class="n">Resource2</span>
</span><span class='line'><span class="n">ScopeGuard</span> <span class="n">release2</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="cm">/* Release Resource2 */</span> <span class="p">})</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Resource2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">release2</span><span class="p">.</span><span class="n">Dismiss</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">// throw exception or return or...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



		
		<a href="/blog/2014/01/06/windows-api-raii/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-01-06T00:18:00+08:00" pubdate data-updated="true">Jan 6<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>C++</a>


</div>
	
	<div class="comments"><a href="/blog/2014/01/06/windows-api-raii/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/12/23/cps-async/">
		
			异步编程和延续传递风格</a>
	</h2>
	<div class="entry-content">
		<h2>什么是延续传递风格(Continuation-passing Style)?</h2>

<p>Continuation-passing style(CPS) 是指将控制流 (Control flow) 显式的当做参数传递的编程风格. 函数的返回不在通过 return 语句, 而是将返回值当做参数, 调用控制流. 延续传递风格的函数都会有一个额外的参数k, 显式的表示了continuation (可以理解成控制流的流向, what comes next). 当延续传递风格函数需要返回的时候, 调用k, 并将返回值作为k的参数.</p>

<p>延续传递风格的函数都有一个额外的参数 k, 表示控制流. 函数需要返回, 必须显式的调用 k.
在函数的末尾调用了另外一个函数, 这种调用称为尾调用, tail call. 相应的在尾部递归调用, 称之为尾递归, tail recursion. 延续传递风格的所有函数都是尾调用.</p>

<p>看一个实际的例子, 假设我们有一个函数 <code>show</code> 可以用来打印一些东西, 通常的做法是我们调用一个函数然后存储或者修改它的返回值, 然后把它传给下一个函数,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">show</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">make_one</span> <span class="o">=</span> <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// prints 1</span>
</span><span class='line'><span class="n">show</span><span class="p">(</span><span class="n">make_one</span><span class="p">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>在延续传递风格中, 函数需要增加一个参数用来处理函数返回的结果, 它是这个函数处理完之后需要的后续处理,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">one_cont</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">k</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Also prints 1</span>
</span><span class='line'><span class="n">one_cont</span><span class="p">(</span><span class="n">show</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用延续传递风格最初主要用于编译高级语言时一种中间代码表示, 有了这种中间代码, 编译器的复杂度大大降低. 各种的控制流都能变为 CPS. 有很多办法可以将非 CPS 代码自动转换为 CPS 的代码. 有兴趣可以去研究下 <a href="http://book.douban.com/subject/1762126/">Compiling with Continuations</a> 这本书.</p>


		
		<a href="/blog/2013/12/23/cps-async/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-12-23T00:51:00+08:00" pubdate data-updated="true">Dec 23<span>rd</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/fp/'>FP</a>


</div>
	
	<div class="comments"><a href="/blog/2013/12/23/cps-async/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/12/08/cpp11-tuple/">
		
			C++11 Std::tuple 和它的应用</a>
	</h2>
	<div class="entry-content">
		<p>模板类 <code>std::tuple</code> 是一个固定大小, 存储元素类型不同的集合. 它是 <code>std::pair</code> 的泛化版本.</p>

<p>一个 tuple 可以显示的声明它每个元素的类型, 也可以用 <code>std::make_tuple</code> 模板函数来实现自动类型推导. 可以用 <code>std::get</code> 指定索引来访问 tuple 中的元素. 如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">(</span><span class="s">&quot;bitdewy&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;bitdewy&quot;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">);</span>   <span class="c1">// t will be of type tuple&lt;string, int, double&gt;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'><span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当编译期我们需要一个存放不同类型数据的集合, 但又不想定义一个具名的类时 tuple 是非常有用的. 例如 <code>std::function</code> 和 <code>std::bind</code> 就使用 tuple 来存放参数(我们都知道 <code>std::bind</code> 从第二个参数开始, 就是函数的参数了, 参数个数是不定的, 类型也是不定的, 这太适合用 <code>tuple</code> 来定义以及存储函数参数列表了). 尤其是 C++11 开始支持变长模板参数了, 这样一来 tuple 就变得更方便了.</p>

<h2>std::tie</h2>

<p>很多时候我们都希望函数能够返回两个或者更多个值, <code>std::tie</code> 可以帮助我们解决这个问题. <code>std::tie</code> 会构造一个每个元素都是左值引用的 <code>std::tuple</code>. 所以当一个函数返回一个 <code>std::tuple</code> 时, 我们可以使用 <code>std::tie</code> 构造一个 <code>std::tuple</code> 来接收这些返回值. 同时, 如果我们的类的每个元素都支持比较的话, 我们还可以直接使用它来构造一个 <code>std::tuple</code> 来使用 <code>std::tuple</code> 的比较函数. 如下:</p>


		
		<a href="/blog/2013/12/08/cpp11-tuple/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-12-08T17:36:00+08:00" pubdate data-updated="true">Dec 8<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>C++</a>, <a class='category' href='/blog/categories/c-plus-plus-11/'>C++11</a>


</div>
	
	<div class="comments"><a href="/blog/2013/12/08/cpp11-tuple/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/11/18/cryptopp-aes-rsa/">
		
			Crypto++ 试用</a>
	</h2>
	<div class="entry-content">
		<p>由于某些需求, 需要研究一下加密解密的相关内容, 于是找到了 crypto++, 常见的加密算法, 这里面差不多都有了, 但是想用的话, 还是需要先补一下密码学相关的基础知识.</p>

<h2>对等加密</h2>

<p>对等加密 (Reciprocal cipher) 又称为对称密钥加密 (Symmetric-key algorithm), 对称加密, 私钥加密, 共享密钥加密, 是密码学中的一类加密算法. 该类密码的加密算法是它自己本身的逆反函数, 所以其解密算法等同于加密算法, 也就是说, 要还原对等加密的密文, 套用加密同样的算法即可得到明文. 换句话说, 若参数 (或密钥) 合适的话, 两次连续的对等加密运算后会回复原始文字. 在数学上, 这有时称之为对合. 在实际应用中, 体现为加密和解密使用同一个密钥, 或者知道一方密钥能够轻易计算出另一方密钥.</p>

<p>常见的对称加密算法有 DES, 3DES, AES, Blowfish, IDEA, RC4, RC5, RC6.</p>

<p>在对称钥匙密码学中, 加密和解密使用相同的钥匙, 也许对不同的信息使用不同的钥匙, 但都面临钥匙管理的难题. 由于每对通讯方都必须使用异于他组的钥匙, 当网络成员的数量增加时, 钥匙数量成二次方增加. 更尴尬的难题是: 当安全的通道不存在于双方时, 如何建立一个共有的钥匙以利安全的通讯? 如果有通道可以安全地建立钥匙, 何不使用现有的通道. 这个 &ldquo;鸡生蛋, 蛋生鸡&rdquo; 的矛盾是长年以来密码学无法在真实世界应用的阻碍.</p>

<h2>公开密钥加密</h2>

<p>公开密钥加密 (英语: Public-key cryptography, 也称为非对称(密钥)加密), 该思想最早由雷夫·莫寇 (Ralph C. Merkle) 在 1974 年提出, 之后在 1976 年. 狄菲 (Whitfield Diffie) 与赫尔曼 (Martin Hellman) 两位学者以单向函数与单向暗门函数为基础, 为发讯与收讯的两方创建密钥.</p>

<p>非对称密钥, 是指一对加密密钥与解密密钥, 这两个密钥是数学相关, 用某用户密钥加密后所得的信息, 只能用该用户的解密密钥才能解密. 如果知道了其中一个, 并不能计算出另外一个. 因此如果公开了一对密钥中的一个, 并不会危害到另外一个的秘密性质. 称公开的密钥为公钥; 不公开的密钥为私钥.</p>


		
		<a href="/blog/2013/11/18/cryptopp-aes-rsa/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-11-18T00:04:00+08:00" pubdate data-updated="true">Nov 18<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>C++</a>, <a class='category' href='/blog/categories/cryptography/'>cryptography</a>


</div>
	
	<div class="comments"><a href="/blog/2013/11/18/cryptopp-aes-rsa/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/11/11/return-type-resolver/">
		
			返回值类型推导</a>
	</h2>
	<div class="entry-content">
		<p>模版函数的参数类型可以自动推导, 它可以让我们在调用函数的时候不必写丑陋的<code>&lt;&gt;</code>, 但如果是返回值类型需要自动推导, 似乎就没有那么容易了. 虽然语言本身不支持返回值的类型自动推导, 但我们可以尝试其他的办法来完成这项任务.</p>

<h2>目的</h2>

<p>在使用函数返回值初始化变量或给变量赋值时模版函数能够自动推导出类型.</p>

<h2>例子</h2>

<p>在某些情况下, 明确被初始化的变量类型是有用的. 考虑下面的例子, 我们使用随机数来初始化 STL 容器. 但是我们不知道用户会选择哪个具体的容器类型. 它可能是 <code>std::list</code>, <code>std::vector</code> 或者其他的行为像 STL 容器的自定义类型. 最直接的方法如下所示:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;random&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">Container</span> <span class="n">GetRandomN</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">GetRandomN</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



		
		<a href="/blog/2013/11/11/return-type-resolver/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-11-11T10:21:00+08:00" pubdate data-updated="true">Nov 11<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>C++</a>


</div>
	
	<div class="comments"><a href="/blog/2013/11/11/return-type-resolver/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/10/20/aop/">
		
			面向切面编程(AOP)</a>
	</h2>
	<div class="entry-content">
		<p>上周同事问了个没法回答的问题, <em>“统计, 日志应该放到哪一层, 或者哪个模块中?”</em></p>

<p>首先, 所有的编程范式都不是万能的, 更不用说<a href="http://existentialtype.wordpress.com/2011/03/15/teaching-fp-to-freshmen/">反并发、反模块化</a>的面向对象范式了. 我们不能总是以同一种编程范式来思考问题. 类似日志, 权限验证, 事务管理等会横跨多个模块的东西, 我们需要新的思路来解决代码割裂的问题.</p>

<h2>面向切面编程</h2>

<p>面向切面编程 (AOP), 不是什么新玩意儿, 早在 199x 年开始, 研究人员就对面向对象思想的局限性进行了分析. 研究出了一种新的编程思想, 借助这一思想可以通过减少代码重复模块从而帮助开发人员提高工作效率. 随着研究的逐渐深入, AOP 也逐渐发展成一套完整的程序设计思想, 各种应用 AOP 的技术也应运而生. 比较著名的有 Java 阵营的 AspectJ 和 Spring AOP, C++ 中也有 AspectC++.</p>

<h3>AOP 中的概念</h3>

<ul>
<li>cross-cutting concerns, (横切关注点)指的是一些具有横越多个模块的行为, 使用传统的软件开发方法不能够达到有效的模块化的一类特殊关注点. 如日志, 权限验证等不属于业务逻辑, 但多个模块都需要插入的东西, 即属于横切关注点.</li>
<li>advice, (通知)指的是切面中的具体逻辑. 如打印日志, 验证权限.</li>
<li>pointcut, (切入点)指的是切面代码要插入的位置.</li>
<li>aspect, (切面)指的是通知以及切入点模块化之后的整体.</li>
</ul>


<p>上面的内容都属于动态横切, 基本上所作的工作就是方法拦截, 插入指定的代码. 还有一种静态横切, Mixin 它可以可以在不修改原有职责的基础上增加新的职责, 可以模拟多继承, 而不增加耦合性, 不过这就不是本文所要讨论的内容了.</p>

<p>看下面的伪代码来感受一下 AOP:</p>


		
		<a href="/blog/2013/10/20/aop/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-10-20T13:58:00+08:00" pubdate data-updated="true">Oct 20<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/aop/'>AOP</a>


</div>
	
	<div class="comments"><a href="/blog/2013/10/20/aop/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/09/23/exception-and-multithread/">
		
			异常与多线程</a>
	</h2>
	<div class="entry-content">
		<p>C++ 的异常机制为程序员提供了一种处理错误的方式, 使程序员可以用更自然的方式处理错误.(但 C++ 的异常存在各种坑, 参考《More Effective C++》Item 13: Catch exceptions by reference).</p>

<p>有些时候, 我们不得不使用多线程来提高工作的执行效率, 但由于异常都是基于线程的, 如何在线程间传递异常, 就成为了一个问题. C++11 之前异常是无法在线程之前传递的, C++11 在这方面提供了支持.</p>

<h2>使用 C++11 中的异常相关内容实现在线程间传递异常</h2>

<p>相关类如下:</p>

<p><code>std::exception_ptr</code></p>

<ul>
<li>一个智能指针类型的异常对象, 支持 bool 操作符, 可以存储空异常 (null) 对象. 也支持比较 (operator==).</li>
</ul>


<p><code>std::current_exception</code></p>

<ul>
<li>当在异常处理块中 (catch块) 调用时, 会捕获当前异常对象并由被捕获的对象创建一个 <code>std::exception_ptr</code> 对象并返回.</li>
</ul>


<p><code>std::make_exception_ptr</code></p>

<ul>
<li>接受一个 Exception 对象参数, 并由这个异常对象创建一个 <code>std::exception_ptr</code> 对象</li>
</ul>


<p><code>std::rethrow_exception</code></p>

<ul>
<li>接受一个 <code>std::exception_ptr</code> 参数, 重新抛出这个异常</li>
</ul>


<p>(<em>以上的一切, 很大一部分都是因为 C++ 的值传递特性引起的一系列不适!!!</em>, !!(╯&#8217; &ndash; &lsquo;)╯︵ ┻━┻)</p>


		
		<a href="/blog/2013/09/23/exception-and-multithread/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-09-23T23:30:00+08:00" pubdate data-updated="true">Sep 23<span>rd</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/exception/'>exception</a>, <a class='category' href='/blog/categories/multithread/'>multithread</a>


</div>
	
	<div class="comments"><a href="/blog/2013/09/23/exception-and-multithread/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    bitdewy

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'bitdewy';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>