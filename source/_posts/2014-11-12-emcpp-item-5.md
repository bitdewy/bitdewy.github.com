---
layout: post
title: "[译] Item 5: Prefer auto to explicit type declarations."
date: 2014-11-12 15:55
comments: true
categories: [Effective Modern C++]
---

看下面的声明，很和谐

``` cpp
int x;
```

等等，擦. 忘记初始化了，所以它的值是不确定的。也许，它可能会被初始化成 0。但是很遗憾这是不确定的。

再看看，解引用一个迭代器来初始化局部变量的例子：

``` cpp
template <typename It>  // algorithm to dwim ("do what I mean")
void dwim(It b, It e)   // for all elements in range from
{                       // b to e
	while (b != e) {
		typename std::iterator_traits<It>::value_type currValue = *b;
		// ...
	}
}
```

呃，用 `typename std::iterator_traits<It>::value_type` 来表示迭代器所指向的值？这样真的没问题嚒？

再来，如果我们想要一个闭包类型的局部变量。哦，好吧。只有编译器才知道这个闭包是什么类型，我们根本无法写出这个类型。

擦，擦，擦。C++ 写起来还真是头疼。没错，不过那都是过去了。有了 C++11 之后，这些问题都不存在了，我们有了 `auto`。`auto` 类型会根据初始化自动推导，所以它们必须被初始化。这意味着在现代 C++ 中你可以和那些变量未初始化的问题挥手说拜拜了：

``` cpp
int x1;        // potentially uninitialized
auto x2;       // error! initializer required
auto x3 = 0;   // fine, x's valye is well-defined
```

迭代器解引用初始化局部变量也可以这么来写了:

``` cpp
template <typename It>  // as before
void dwim(It b, It e)
{
	while (b != e) {
		auto currValue = *b;
		// ...
	}
}
```

由于 `auto` 类型推导（Item 2），它也可以表示那些只有编译器才知道的类型了：

``` cpp
auto derefUPLess =                         // comparison func.
  [](const std::unique_ptr<Widget>& p1,    // for Widgets
     const std::unique_ptr<Widget>& p2)    // pointed to by
  { return *p1 < *p2; };                   // std::unique_ptrs
```

很酷吧。C++14 更牛逼了，lambda 可以用 auto 类型的参数：

``` cpp
auto derefUPLess =          // C++14 comparison
  [](const auto& p1,        // function for
     const auto& p2)        // values pointed
  { return *p1 < *p2; };    // to by anything pointer-like
```

尽管很酷，但你也许会想我们不需要使用 auto 来声明一个闭包，我们有 `std::function`。是的，可以，但是这也许会和你想的不太一样。现在你可能会想 `std::function` 对象到底是什么？接下来我们把这个问题讨论清楚。

`std::function` 是 C++11 标准库中的模板类，是函数指针的升级版。函数指针只能指向函数，而 `std::function` 对象可以表示任何可调用的对象，即任何可以像函数一样调用的对象。就像你必须给函数指针声明一个明确类型一样（类型签名必须与想要调用的函数类型一致），你必须明确 `std::function` 对象所涉及到的类型。也就是 `std::function` 的模板参数。举个例子，你想要声明一个 `std::function` 对象 `func` 它可以调用如下签名的函数：

``` cpp
bool(const std::unique_ptr<Widget>&,    // C++11 signature for
	 const std::unique_ptr<Widget>&)    // std::unique_ptr<Widget>
	                                    // comparison function
```

你需要这么写：

```cpp
std::function<bool(const std::unique_ptr<Widget>&, const std::unique_ptr<Widget>&)> func;
```

由于 lambda 表达式生成可一个可调用的对象，那么闭包可以存在一个 `std::function` 对象中。也就是说我们可以像下面这样

## 需要记住的

-
