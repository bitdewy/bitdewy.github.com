---
layout: post
title: "[译] Item 5: Prefer auto to explicit type declarations."
date: 2014-11-12 15:55
comments: true
categories: [Effective Modern C++]
---

看下面的声明，很和谐

``` cpp
int x;
```

等等，擦. 忘记初始化了，所以它的值是不确定的。也许，它可能会被初始化成 0。但是很遗憾这是不确定的。

再看看，解引用一个迭代器来初始化局部变量的例子：

``` cpp
template <typename It>  // algorithm to dwim ("do what I mean")
void dwim(It b, It e)   // for all elements in range from
{                       // b to e
	while (b != e) {
		typename std::iterator_traits<It>::value_type currValue = *b;
		// ...
	}
}
```

呃，用 `typename std::iterator_traits<It>::value_type` 来表示迭代器所指向的值？这样真的没问题嚒？

再来，如果我们想要一个闭包类型的局部变量。哦，好吧。只有编译器才知道这个闭包是什么类型，我们根本无法写出这个类型。

擦，擦，擦。C++ 写起来还真是头疼。没错，不过那都是过去了。有了 C++11 之后，这些问题都不存在了，我们有了 `auto`。`auto` 类型会根据初始化自动推导，所以它们必须被初始化。这意味着在现代 C++ 中你可以和那些变量未初始化的问题挥手说拜拜了：

``` cpp
int x1;        // potentially uninitialized
auto x2;       // error! initializer required
auto x3 = 0;   // fine, x's valye is well-defined
```

迭代器解引用初始化局部变量也可以这么来写了:

``` cpp
template <typename It>  // as before
void dwim(It b, It e)
{
	while (b != e) {
		auto currValue = *b;
		// ...
	}
}
```

由于 `auto` 类型推导（Item 2），它也可以表示那些只有编译器才知道的类型了：

``` cpp
auto derefUPLess =                         // comparison func.
  [](const std::unique_ptr<Widget>& p1,    // for Widgets
     const std::unique_ptr<Widget>& p2)    // pointed to by
  { return *p1 < *p2; };                   // std::unique_ptrs
```

很酷吧。C++14 更牛逼了，lambda 可以用 auto 类型的参数：

``` cpp
auto derefUPLess =          // C++14 comparison
  [](const auto& p1,        // function for
     const auto& p2)        // values pointed
  { return *p1 < *p2; };    // to by anything pointer-like
```

尽管很酷，但你也许会想我们不需要使用 auto 来声明一个闭包，我们有 `std::function`。是的，可以，但是这也许会和你想的不太一样。现在你可能会想 `std::function` 对象到底是什么？接下来我们把这个问题讨论清楚。

`std::function` 是 C++11 标准库中的模板类，是函数指针的升级版。函数指针只能指向函数，而 `std::function` 对象可以表示任何可调用的对象，即任何可以像函数一样调用的对象。就像你必须给函数指针声明一个明确类型一样（类型签名必须与想要调用的函数类型一致），你必须明确 `std::function` 对象所涉及到的类型。也就是 `std::function` 的模板参数。举个例子，你想要声明一个 `std::function` 对象 `func` 它可以调用如下签名的函数：

``` cpp
bool(const std::unique_ptr<Widget>&,    // C++11 signature for
	 const std::unique_ptr<Widget>&)    // std::unique_ptr<Widget>
	                                    // comparison function
```

你需要这么写：

```cpp
std::function<bool(const std::unique_ptr<Widget>&, const std::unique_ptr<Widget>&)> func;
```

由于 lambda 表达式生成可一个可调用的对象，那么闭包可以存在一个 `std::function` 对象中。也就是说在 C++11 中， 不使用 auto 我们可以像下面这样：

``` cpp
std::function<bool(const std::unique_ptr<Widget>&, const std::unique_ptr<Widget>&)> derefUPLess
    = [](const std::unique_ptr<Widget>& p1, const std::unique_ptr<Widget>& p2) {
    	return *p1 < *p2;
    };
```

但一定要明白，即使我们显示的给出了参数类型，但 `std::function` 与 `auto` 也不完全一样。用 `auto` 类型来接受一个闭包，它的类型与实际类型是一致的，内存的占用也是完全一样的。而用 `std::function` 来接受一个闭包，那么对于给定的签名，内存占用是固定的。而这个大小可能不足以存储该闭包，这个时候 `std::function` 的构造函数会在堆上分配足够的内存来存储这个闭包。也就是说，通常情况下 `std::function` 对象会比 `auto` 对象使用更多的内存。同时会阻止函数内连，让函数调用多一个间接层，通过 `std::function` 来调用一个闭包集合总是要比 auto 声明的闭包要慢。换句话说，`std::function` 通常都会比 `auto` 更大，更慢，而且还可能抛出 `out-of-memory` 异常。另外，像上面的例子，`auto` 会比完整类型更简洁。总之，当需要持有一个闭包时，`auto` 是比 `std::function` 更好的选择。（另外还有一个类似的东西是 `std::bind`，同样的也是选择使用 `auto` 而不是 `std::function`，不过，在 Item 34 中，我会尽力说服你用 lambda 表达式来代替 `std::bind`）。

## 需要记住的

-
