---
layout: post
title: "[译] Item 3: Understand decltype"
date: 2014-10-21 14:55
comments: true
categories: [Effective Modern C++]
---

`decltype` 是一个奇怪的发明。给一个名字或者表达式，`decltype` 可以告诉你这个名字或者表达式的类型。通常的情况下，他告诉你的都是你预期的。但是偶尔也会有些出人意料。

我们从最典型的情况开始 —— 那些不会让你惊奇的情况。与模板类型推导和 `auto` 类型推导不同，`decltype` 通常只是鹦鹉学舌般的返回你传入的名字或表达式的类型：

```
const int i = 0;    // decltype(i) is const int

bool f(const Widget& w);    // decltype(w) is const Widget&
                            // decltype(f) is bool(const Widget&)

struct Point {
	int x, y;               // decltype(Point::x) is int
};                          // decltype(Point::y) is int


Widget w;                   // decltype(w) is Widget

if (f(w)) {                 // decltype(f(w)) is bool
	// ...
}

template<typename T>        // simplified version of std::vector
class vector {
public:
    // ...
    T& operator[](std::size_t index);
    // ...
};

vector<int> v;              // decltype(v) is vector<int>

if (v[0] == 0) {            // decltype(v[0]) is int&
	// ...
}
```

是不是完全没有惊喜？

在 C++11 中，`decltype` 的作用也许就是声明一个返回值类型依赖于模板参数的模板函数。举个例子，假设我们准备写一个以容器 (接受下标操作的) 和索引 `index` 为参数的函数，验证用户之后返回。返回值的类型与容器下标操作的类型相同。

`T` 类型容器的 `operator[]` 返回值类型通常是 `T&`。对于 `std::deque` 来说，是这个样，对于 `std::vector` 来说，大部分情况下也是的，不过对于 `std::vector<bool>` 来说，情况就不一样了，它的返回值不是 `bool&`。这就是我们要在 Item 6 中讨论的问题。在这里，最重要的是，我们要知道容器的 `operator[]` 的返回值依赖于容器。

`decltype` 可以让这个问题变得简单，下面的代码展示如何利用 `decltype` 来计算返回值。它还可以进一步的精简，我们稍后再说：

```
template <typename Container, typename Index>
auto authAndAccess(Container& c, Index i) -> decltype(auto)  // works, but requires refinement 
{
	authenticateUser();
	return c[i];
}
```

函数名前面的 `auto` 在类型推导中什么用处都没有。取而代之的是 C++11 的尾随返回值类型 (trailing return type)。函数返回值的类型在函数参数列表之后声明 (在 -> 符号之后)。尾随返回值类型的好处是，函数的参数可以用于声明返回值类型。在 `authAndAccess` 中，我们的返回值类型声明用到了参数 `c` 与 `i`。如果我们将返回值类型置于函数名前，那么我们就无法使用 `c` 和 `i`，因为这时它们还没有声明。

上面的声明中，`autoAndAccess` 的返回值与我们预期的完全一致，就是容器 `Container` 的 `operator[]` 的返回值类型。

C++11 支持单句 `lambda` 的返回值类型推导，而 C++14 进行了扩展，支持所有 `lambda` 和函数，包括那些多条语句的。这意味着在上面的例子中，使用 C++14 我们可以省略掉尾随返回值类型，仅仅保留最前面的 `auto` 即可。在这里，`auto` 是类型推导的占位符。编译器会根据函数的具体实现来推导函数的返回值类型。

```
template<typename Container, typename Index>  
auto authAndAccess(Container& c, Index i)    // C++14, not require
{
	authenticateUser();
	return c[i];            // return type deduced from c[i]
}
```
但是，在这里返回值类型推导使用的是哪个类型推导规则？模板？ `auto` ? 还是 `decltype` ?

也许你会有些惊讶，函数的 `auto` 返回值类型遵循的是模板类型推导规则。看起来 `auto` 类型推导规则，在这里是一个更好的选择，不过 `auto` 类型推导与模板类型推导机会是完全一致的。唯一的区别就是模板类型推导无法推导大括号初始化。

## 需要记住的

- 
